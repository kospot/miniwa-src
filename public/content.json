{"meta":{"title":"Miniwa","subtitle":"this is a test","description":null,"author":"miniwa","url":"http://miniwa.com.cn"},"posts":[{"title":"二月冲绳之旅","date":"2018-03-02T06:30:39.000Z","path":"2018/03/02/2018-02-19-chongsheng/","text":"这是我俩第一次的出国之旅，考虑到英语水平有限和治安环境因素，选了一个离我国最近的地方——冲绳。在这之前又考虑过泰国、新加坡，想到那些地方国人太多，就先hold住了。签证是找自己公司代办，给钱就行。当时距离春节还有几个星期，公司的人说要赶紧了，领事馆那边有可能在节前暂停办理的。所以赶紧去排了4.5寸的大头贴，交了资料，所幸不多久就办好了。公司代办还是挺方便地，啥都不用干，交资料就行。 交通工具：广州出发去南沙做轮船过香港，香港直飞冲绳 这里有两个地方可以知晓一下： 1、南沙有两班去香港的船，一个是到中环城，一个是到香港机场；有签证可直接过去7天；到香港机场的需要是当天或者第二天早上10点之前的飞机，它的方便之处是直接在这边搞好行李托管和登记，直接去到机场的候机大厅。 2、大陆直飞冲绳的飞机不多，上海才有，实惠的更是少之又少；而香港班次选择比较多，价格也便宜，我们选的是一架A330，总体感觉还好。 2月19日广州出发香港妹子说想坐一下轮船，我们的机票是第二天11点的，不能直接坐去香港机场了，所以下午在南沙坐下的末班轮船过了香港，历时1.5个小时。坐船的时候感觉很平坦，不怎么摇晃，人也不多，感觉还是十分nice的。到了香港之后，在那边逛了一下，吃了个饭，然后做机场大巴过去了香港机场。港币是直接在这边的提款机取的。大约一个小时左右，从中环抵达了香港机场，在那边办理了行李托运，然后就找个地方休息了一下，漫漫长夜，别问我怎么度过~哈哈！ 第二天一早，我们便起来去吃了个简单的早餐。漫长的等待，终于等到登记时刻。在那边发现，香港人都挺喜欢一家人出去旅行的，而且小学生的英语还特别牛逼，简直秒杀我等。 …未完待续","permalink":"http://miniwa.com.cn/2018/03/02/2018-02-19-chongsheng/","categories":[{"name":"闲暇游记","slug":"闲暇游记","permalink":"http://miniwa.com.cn/categories/闲暇游记/"}],"tags":[]},{"title":"egg整合数据校验","date":"2018-02-13T16:05:45.000Z","path":"2018/02/14/2018-02-14-egg-validate/","text":"egg官方的插件egg-validate依赖了parameter包，其只做了两个处理 Copy Code1234567891011121314// egg-validate/app.jsapp.validator = new Parameter();// egg-validate/app/extend/context.jsvalidate(rules, data) &#123; data = data || this.request.body; const errors = this.app.validator.validate(rules, data); if (errors) &#123; this.throw(422, &apos;Validation Failed&apos;, &#123; code: &apos;invalid_param&apos;, errors, &#125;); &#125;&#125; 可见其做了两件事： 1、启动时创建了一个实例 2、封装了一个调用方法，和错误的时候自定义了一个http状态，抛出 Copy Code1234[ &#123;message: &apos;should not be empty&apos;, code: &apos;invalid&apos;, field: &apos;name&apos;&#125;, &#123;message: &apos;should be an integer&apos;, code: &apos;invalid&apos;, field: &apos;age&apos;&#125;] 这里有几个不好的地方： 1、没有暴露自定义parameter校验返回的信息，只能用这些提示。不能满足业务需求 2、封装的validate方法个人感觉不够友好，直接抛出错误 3、parameter的实现比较简单，使用比较方便，但对于自定义要求比较高需求灵活性还不够，例如它在对string校验时，为空的提示语不能自定义，只有配置了format的才可以自定义提示 前两点覆盖的方式重写，但重写了，跟直接引用parameter并没有太大区别。所以建议还是直接用parameter这个插件。用法比较简单，直接拓展context上下文。 Copy Code123456789101112131415161718192021222324// extend/context.jsconst VALIDATOR = Symbol(&apos;Application#validator&apos;); // 定义一个全局唯一的属性var Parameter = require(&apos;parameter&apos;);module.exports = &#123; get validator () &#123; const that = this if (!this[VALIDATOR]) &#123; this[VALIDATOR] = new Parameter(&#123; translate () &#123; // 翻译成多语言 const arg = [...arguments] return that.__(...arg) &#125; &#125;) &#125; return this[VALIDATOR] &#125;, validate(rules, data) &#123; data = data || this.request.body; const errors = this.validator.validate(rules, data); console.log(errors) return errors &#125;&#125;; parameter的使用 1、插件提示语是英文的，那需要支持多语言，所幸其暴露了translate的配置项，引入egg-i18n即可 2、定义了一些简写： &#39;int&#39; =&gt; {type: &#39;int&#39;, required: true} &#39;integer&#39; =&gt; {type: &#39;integer&#39;, required: true} &#39;number&#39; =&gt; {type: &#39;number&#39;, required: true} &#39;date&#39; =&gt; {type: &#39;date&#39;, required: true} &#39;dateTime&#39; =&gt; {type: &#39;dateTime&#39;, required: true} &#39;id&#39; =&gt; {type: &#39;id&#39;, required: true} &#39;boolean&#39; =&gt; {type: &#39;boolean&#39;, required: true} &#39;bool&#39; =&gt; {type: &#39;bool&#39;, required: true} &#39;string&#39; =&gt; {type: &#39;string&#39;, required: true, allowEmpty: false} &#39;email&#39; =&gt; {type: &#39;email&#39;, required: true, allowEmpty: false, format: EMAIL_RE} &#39;password&#39; =&gt; {type: &#39;password&#39;, required: true, allowEmpty: false, format: PASSWORD_RE, min: 6} &#39;object&#39; =&gt; {type: &#39;object&#39;, required: true} &#39;array&#39; =&gt; {type: &#39;array&#39;, required: true} [1, 2] =&gt; {type: &#39;enum&#39;, values: [1, 2]} /\\d+/ =&gt; {type: &#39;string&#39;, required: true, allowEmpty: false, format: /\\d+/} 3、一个简单的例子： Copy Code12345678910111213const error = this.ctx.validate(&#123; content: &apos;string&apos;, difficulty: [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;], type: [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;], options: &#123; type: &apos;array&apos;, itemType: &apos;object&apos;, required: false, rule: &#123; text: &#123;type: &apos;string&apos;, format: /^\\S&#123;6,&#125;$/, message: &apos;选项的内容不能少于3个字&apos;&#125; &#125; &#125;&#125;) 需要注意一点，ctx.request.body或者ctx.request.query里拿到的只有字符串或者对象，没有数字类型，所以别用int或者integer","permalink":"http://miniwa.com.cn/2018/02/14/2018-02-14-egg-validate/","categories":[{"name":"实战应用","slug":"实战应用","permalink":"http://miniwa.com.cn/categories/实战应用/"}],"tags":[{"name":"eggjs","slug":"eggjs","permalink":"http://miniwa.com.cn/tags/eggjs/"},{"name":"node","slug":"node","permalink":"http://miniwa.com.cn/tags/node/"}]},{"title":"记一次node捉取表格数据的实践","date":"2017-09-10T12:40:20.000Z","path":"2017/09/10/2017-09-10-get-data/","text":"最近在公司办理了人才引入，递交了资料，然后就等待公示；公示的名单会在改网页中展示http://www.hrssgz.gov.cn/vsgzpiapp01/GZPI/Gateway/PersonIntroducePublicity.aspx，点进去查看一番觉得坑爹的是每页只显示几条，而且还有60页之多，这简直是反人类。于是便想着把所有的数据搞下来！ 第一步肯定是F12看看请求的格式了，又翻页看了一下请求，大致了解了流程： 每次请求会拿到VIEWSTATEGENERATOR、VIEWSTATE等着些后端的code值 __EVENTTARGET表明是第一页还是尾页、或者上一页下一页 ToPage为当前的页码 接口的地址都是这一个/vsgzpiapp01/GZPI/Gateway/PersonIntroducePublicity.aspx 采用post的方式请求 http请求体 页面跳转处理 跳转执行函数 第二步模拟请求，获取返回的html，截取数据拿到第一页的表格，存储起来，并拿第二页的请求参数 这里借助了两个npm的包request、cheerio request一个node发送http请求十分好用的包，可以任意拼装http头部所有字段，模拟现实的浏览器请求也不成问题 cheerio可以让你再node中像在浏览器里一样使用jquery的包，可以方便地操作dom节点 具体实现如下，会把结果写入到当前的一个data.html文件里： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var fs = require(&apos;fs&apos;), request = require(&apos;request&apos;), cheerio = require(&apos;cheerio&apos;)// 缓存的结果var result = &apos;&apos;function write(str)&#123; fs.writeFile(&apos;./data.html&apos;, str, function (err) &#123; if (err) throw err; &#125;);&#125;// 为了好看一点，包装一下function wrapHtml(str) &#123; var header = &apos;&lt;tr class=&quot;ListHeader&quot; align=&quot;center&quot;&gt; &lt;td&gt;姓名&lt;/td&gt;&lt;td&gt;单位名称&lt;/td&gt;&lt;td&gt;批复结果&lt;/td&gt;&lt;td&gt;审批单位&lt;/td&gt;&lt;td&gt;公示开始时间&lt;/td&gt;&lt;td&gt;公示结束时间&lt;/td&gt; &lt;/tr&gt;&apos; str = &apos;&lt;table&gt;&apos; + header + str +&apos;&lt;/table&gt;&apos; return &apos;&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;最新名单&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &apos;+str+&apos;&lt;/body &gt; &lt;/html&gt;&apos;&#125;function query(data)&#123; request.post(&#123; url: &apos;http://www.hrssgz.gov.cn/vsgzpiapp01/GZPI/Gateway/PersonIntroducePublicity.aspx&apos;, formData: data &#125;, function (error, response, body) &#123; var startIndex = body.indexOf(&apos;&lt;tr class=&quot;ListItem&quot;&gt;&apos;) var endIndex = body.indexOf(&apos;&lt;/table&gt;&apos;) result += body.slice(startIndex, endIndex) var formData = getFormData(body) //如果formdata没值标示没有下一页了，也就可以结束了 if(formData)&#123; query(formData) &#125;else&#123; write(wrapHtml(result)) console.log(&apos;读取完成&apos;); &#125; &#125;)&#125;//在body中获取下一页的参数function getFormData (body) &#123; const $ = cheerio.load(body) if($(&apos;#NextLBtn&apos;).attr(&apos;disabled&apos;) == &apos;disabled&apos;)&#123; return false &#125; var total = $(&apos;#PageCount&apos;).text() var cur = $(&apos;#ToPage&apos;).val() console.log(&apos;继续读取第&apos;+Number(+cur + 1)+&apos;页，&apos; + &apos;共&apos;+total+&apos;页&apos;); return &#123; __EVENTTARGET: &apos;NextLBtn&apos;, __VIEWSTATE: $(&apos;#__VIEWSTATE&apos;).val(), __VIEWSTATEGENERATOR: $(&apos;#__VIEWSTATEGENERATOR&apos;).val(), ToPage: cur &#125;&#125;//开始拿第一页的数据query() 下面是执行的结果 总的来说流程还是比较简单的，拿到表格之后也可以随意搜索名字了。node确实是给前端带来了很大的改变，让前端可以从浏览器走出去，可以任意的操作计算机系统的资源，而目前更是广泛应用到静态服务器、SSR、资源打包优化、桌面应用等。可以说Web2.0让js死而复生，node让js脱胎换骨。js如火如荼也很大程度上得益于当今项目开源的浪潮，前不久更是看到了一些开源的神经网络js库，相信不久的将来，在AI、VR等新技术领域js也定能分得一杯羹。 其实作为IT人士，一直觉得我们不应该太过局限于工作，与技能结合起来，让能力更好地改变我们的生活，结合生活我们才能有所创造。铁饭碗不是来源于组织的强大稳健，而是产品与技术创新。","permalink":"http://miniwa.com.cn/2017/09/10/2017-09-10-get-data/","categories":[{"name":"实战应用","slug":"实战应用","permalink":"http://miniwa.com.cn/categories/实战应用/"}],"tags":[]},{"title":"关于ES6的这些你知道吗","date":"2017-09-09T01:23:11.000Z","path":"2017/09/09/2017-09-09-about-es6/","text":"使用vue开发的时候经常使用es6的语法，下面是一些自己工作中的一些笔记。希望多多补充： 1、箭头函数 箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域 编译时通过bind外围的this来绑定对象 2、在for in 和for of循环中let和const每一次迭代都会创建一个新的绑定123for(let i = 0; i &lt; 10; i++)&#123; setTimeout(function()&#123;console.log(i)&#125;)&#125; 123for(var i = 0; i &lt; 10; i++)&#123; setTimeout(function()&#123;console.log(i)&#125;)&#125; string的三个查找字符串的方法 includes、startsWith、endsWith string重复的方法repeat 剩余参数-由三个点和一个紧跟着的具名参数指定，它会是包含传递给函数的其余参数的一个数组 1234567function pick(object, ...keys)&#123; let result = Object.create(null); for(let i = 0; i &lt; keys.length; i++)&#123; result[keys[i]] = object[keys[i]] &#125; return result;&#125; 3、特殊操作符 ‘…’ 可作为扩展运算符或者剩余操作符，扩展指把属性展开；而剩余指把多个元素变为一个元素（塞到数组里） 相当于Function.prototype.apply，把数组展开，可用于一下几个方向 把数组变成多个形参，进行函数调用 把两个数组合并成一个 数组解构（提取的结果是一个数组对象） 将类数组对象转换成数组 具体如下： 12345678910111213141516171819var students = [&apos;Abby&apos;,&apos;Andy&apos;];var otherStudents = [&apos;Jane&apos;,&apos;Tom&apos;];students.push(...otherStudents);/*********************/var parts = [&apos;shoulders&apos;, &apos;knees&apos;];var lyrics = [&apos;head&apos;, ...parts, &apos;and&apos;, &apos;toes&apos;];/*********************/var students = [&apos;Abby&apos;, &apos;Andy&apos;, &apos;Jane&apos;, &apos;Tom&apos;];var somestudents, otherStudents;[somestudents, ...otherStudents] = students ;/*********************/var nodeList = document.querySelectorAll(&apos;div&apos;);var array = [...nodeList]; 4、Object.assign对象属性混合 针对深度拷贝，需要使用其他方法，因为 Object.assign() 拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。 Object.getOwnPropertyDescriptor()返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性） Object.assign 会跳过那些值为 null 或 undefined 的源对象 继承属性（原型链上）和不可枚举属性是不能拷贝的 原始类型会被包装为 object，只有字符串的包装对象才可能有自身可枚举属性 拷贝过程中可能会产生异常，已经拷贝成功的属性不会受到影响，还未拷贝的属性将不会再被拷贝","permalink":"http://miniwa.com.cn/2017/09/09/2017-09-09-about-es6/","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://miniwa.com.cn/categories/基础知识/"}],"tags":[]},{"title":"vuex知识总结","date":"2017-09-01T14:20:12.000Z","path":"2017/09/01/2017-09-01-vuex-base/","text":"状态管理一个状态管理的库，会涉及到这三部分：state、view、actions。可以知道的是： state会影响view view会影响action 但会影响state的是什么呢？action，action可能是单一的或者是来自于多个视图的。 vuex的特点是把数据单独隔离，形成一棵树状图。单独隔离就意味着它有自己的生态系统。输入和输出，其中action作为数据的输入，state作为数据的输出。如下图： 图中有一个奇怪的地方，多了一个mutations，而且与state相连的是mutations而不是actions。 vuex里有这么一个规则： 只能在mutaions里修改state，actions不能直接修改state mutations即变化，修改state的数据，而且只能是同步的，不能存在异步的操作。如果需要异步怎么办呢？把异步操作放在actions里，拿到数据再通过mutations同步处理。 vuex做的其实是把职权明确了，责任细分了。所以它文档里也说，小系统可以不用。状态数据少，没有细分的必要。 使用方法 Action 通过 store.dispatch 方法触发 Mutations 通过 store.commit 方法触发 12345678910111213141516// 触发动作actions: &#123; incrementAsync (&#123; commit &#125;) &#123; setTimeout(() =&gt; &#123; commit(&apos;increment&apos;) &#125;, 1000) &#125;&#125;store.dispatch(&apos;increment&apos;)// 触发变化mutations: &#123; increment (state, n) &#123; state.count += n &#125;&#125;store.commit(&apos;increment&apos;, 10) 为了更方便地读取state里面的数据，其还提高了一些维护的方法： getters 就像计算属性一样，getters的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算 mapGetters 将 store 中的 getters 映射到局部计算属性 mapMutations 将组件中的 methods 映射为 store.commit 调用 mapActions 将组件的 methods 映射为 store.dispatch 调用 1234567891011121314methods: &#123; ...mapMutations([ &apos;increment&apos; // 映射 this.increment() 为 this.$store.commit(&apos;increment&apos;) ]), ...mapMutations(&#123; add: &apos;increment&apos; // 映射 this.add() 为 this.$store.commit(&apos;increment&apos;) &#125;) ...mapActions([ &apos;increment&apos; // 映射 this.increment() 为 this.$store.dispatch(&apos;increment&apos;) ]), ...mapActions(&#123; add: &apos;increment&apos; // 映射 this.add() 为 this.$store.dispatch(&apos;increment&apos;) &#125;)&#125; getter 既然是会缓存的，那怎么带参数呢？github里有人建议这样写： 12345getters: &#123; getListByVal: (state) =&gt; (val) =&gt; &#123; return state.list.find(item =&gt; item.value = val) &#125;&#125; 模块划分当状态比较多的时候，vuex支持模块划分，可以通过模块划分，让store树简化一下。每个模块拥有自己的 state、mutation、action、getter。 对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象 getter 根节点状态会作为第三个参数暴露出来 内部的 action，局部状态通过 context.state 暴露出来， 根节点状态则为 context.rootState 12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态","permalink":"http://miniwa.com.cn/2017/09/01/2017-09-01-vuex-base/","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://miniwa.com.cn/categories/基础知识/"}],"tags":[]},{"title":"追忆厦门鼓浪屿","date":"2017-08-20T12:40:20.000Z","path":"2017/08/20/2017-08-20-xiamen/","text":"还记得上次去鼓浪屿的时候还是2015年的10月份，黄金周刚过，我和小艺用周末的时间飞了过去厦门。这是我们俩第一次一起坐飞机！为了早早抛弃杂心的琐事，周五晚上，我们便过去了机场，第二天一大早坐了旅店的小货车过去了值机台满怀着激动和紧张的心情。第一次自己登机，总算是顺利。 见到了即将带我们飞的飞机 经过两个小时的旅程，我们终于抵达了厦门的。正如图中所言，美丽厦门，从这里开始。这座承载着几千年历史的海滨城市，等着我们领略它的美丽动人。 此次厦门之行，我们的计划只有鼓浪屿，所以下机之后，便前往了码头坐轮渡。在船上，可以看到整个厦门，天水相接，与现代的钢筋水泥浑然天成。虽是金秋时节，海风和浪花早已熄灭了这热情高涨的太阳，迎着风，甚是清爽自在。真不知当年郑成功是何番心情登上这座美丽的岛屿。 鼓浪屿离着不远，不多时便抵达了岸边。可能是国庆刚过的原因，这里的人不算太多。整个岛面积不大，岛上不准车辆行走，所以行人基本都是徒步。除了游客便是居民了，民房密密麻麻地遍布着，各种风情小旅馆和特色小吃店，以及文艺情怀的小店。真是一个消磨时间的好地方。 厦门除了小清新之外，还是有挺多美食的。 在厦门肯定少不了去海边走走，平时深居内陆的我们，对海有一种莫名的喜欢。吹吹海风，听听海声。","permalink":"http://miniwa.com.cn/2017/08/20/2017-08-20-xiamen/","categories":[{"name":"闲暇游记","slug":"闲暇游记","permalink":"http://miniwa.com.cn/categories/闲暇游记/"}],"tags":[]},{"title":"我和小艺的广州阳朔两日闲游","date":"2017-08-19T02:38:19.000Z","path":"2017/08/19/2017-08-05-yangshuoyouji/","text":"广西阳朔，山水秀丽，价美物廉，向来是大学生毕业游的首选之地，我们也不例外。三年前，是五个小时的大巴；三年后，两个小时的动车。时代发展变化很快，时间的缩短也让我们有了再去一次走走的念头。于是乎网上订票，可也奇怪广州南到阳朔的车票十分抢手，两周后的票都没了。实属无奈，然而抢票这事，念念不忘，必有回响。经过抢票神器一天的忙碌，票票在手。东风已备，周五晚上随便准备了一些粮草和下饭神剧，以及十分纠结的在飞猪上定了个不记得叫什么名字的酒店。第二天一大早就赶往广州南站，顺利坐上了火车。这匆忙的行程，想必也不会如此顺心。果然，在车上的时候方知酒店未落实，催促之下，飞猪商家告知没房了。无奈为了落地在决定了。 两个小时的车程，终于抵达了阳朔，出了高铁站便有接驳的官方大巴前往阳朔镇上（价格20），大概五十分钟的行程，在阳朔高铁车站（专门往来高铁站和阳朔的车站）那边下车。然后找了当地的一间维也纳酒店入住，一共两间西街店和印象店，西街店比较靠近车站和西街，价格也贵一点；印象店在印象刘三姐那边，远一点，便宜一点，窗户也大个十倍吧！一天一夜价格350左右。 在酒店休息了一会，下午叫了个滴滴，去了十里画廊那边。一路上出了车，就是车轮、车镜子、车喇叭~~~尽是车。现在骑自行车的人少了，骑电动车、小车的人多了。真是与时俱进啊。不知是现代的车融不进美景还是多了几份喧嚣，十里画廊让人有点名不副实的感觉。我们在大榕树那边下的车，然后就去看了看大榕树，路遇神棍，缘起一炷香，神明非贪财之辈，又岂会怪我少捐这一点功德钱呢？以后景点的庙还是远观不可近拜。 大榕树还真是大，粗如枝干的气根直插大地，仿佛在大地的花屁股上打了好几针。出了大榕树便租了一台电动车，也不贵，不记时，天明到天黑。 于是我们就骑着车往回走，顺便回到镇上。一路吹着热风、看着景色，也是另一番滋味。 在西街那边打电话，叫他们的人来取车，然后退了我们押金。我们就去西街逛了一下。当地人说，白天游客都被带到景点去了，人比较少，有的都是一些散客。阳朔的西街集合了小车、手信、酒吧、饮食等众多的小店。阳朔最出名的两道菜是啤酒鱼和酿大田螺，其中啤酒鱼当地人说哪里味道都差不多，景区的里面贵一点。我们逛累了就找了一家静吧歇息了一下~ 酒吧的驻场歌手都是几个场来回跑的，可能下午人比较少，歌手也是偶尔唱唱 按照电视情节，看到这情景，通常男主都会主动上去献唱一首，博得群众演员的青睐。不过，我这嘹亮的歌声就不嫌丑了，毕竟导演也不在这。逛完一圈，我们就去江边走走了。 阳朔主要是两条江，漓江和遇龙河，图上是西街后面的漓江，景色还是挺美丽的，还有市民在那游泳，小屁孩在玩耍。漓江和遇龙河都可以漂流，漓江是有浆的，遇龙河是手动竹筏。有人说漓江是大家闺秀，遇龙河是小家碧玉，两者各有千秋。不过我们这次都没去！哈哈！别问为什么，热辣辣的天，只想在空调底下看蓝天白云。 这鲜豆腐挺好吃的 朦朦胧胧的大片既视感 第二天，早上在酒店吃了简单的自助早餐，真的是吃过的最简单的自动早餐。中午退了房，又去西街吃了个饭，然后再逛了一下 小女朋友最喜欢的还是这地道的螺蛳粉，小店，绝对称得上物美价廉。 下午四点多便去车站坐车去动车站了。 简短的两天时间，没去什么大景点，毕竟只是想来这睡睡觉，呼吸一下新鲜空气，放松一下自己 大自然的恩宠，阳朔的景色还是挺美丽的。","permalink":"http://miniwa.com.cn/2017/08/19/2017-08-05-yangshuoyouji/","categories":[{"name":"闲暇游记","slug":"闲暇游记","permalink":"http://miniwa.com.cn/categories/闲暇游记/"}],"tags":[]},{"title":"vue-router的使用","date":"2017-08-18T12:23:19.000Z","path":"2017/08/18/2017-08-18-vue-router/","text":"vue-router作为一个官方的路由组件，是应用开发的必备神器。比较突出的有以下几点： 提供了视图渲染的详尽钩子、和路由的携带信息meta 可以方便地切换history模式和hash模式 在视图组件里可以方便地使用路由信息和路由对象 支持路由嵌套，可以拿到路由的匹配路径方便显示激活菜单 组件化的调用方式route-link和route-view，并自动关联 提供了常用方法的封装如：back, go, redirect 如此优秀的组件，下面我们来看看怎么使用。第一步，肯定是初始化了： 123456789101112// 注入组件Vue.use(Router)export default new Router(&#123; mode: &apos;history&apos;, // history模式，看着像活生生的后端渲染 routes: [ &#123; path: &apos;/view/index&apos;, //路径 name: &apos;index&apos;, // 别名，通过别名跳转可以避免url变更需要修改多处地方 component: Index // 对应的视图组件 &#125; ]&#125;) 想成为一个优秀的组件，这样人性化的初始方式是必不可少的了，而它更强大的地方在于，可以支持redirect配置，如果你想把一个路由重定向到另外一个地方，可以这样子 12345678910export default new Router(&#123; mode: &apos;history&apos;, // history模式，看着像活生生的后端渲染 routes: [ &#123; path: &apos;/view/index&apos;, name: &apos;index&apos;, redirect: &#123;name: &apos;xxxxx&apos;&#125; &#125; ]&#125;) 路由的嵌套如下所示： 1234567891011121314export default new Router(&#123; mode: &apos;history&apos;, // history模式，看着像活生生的后端渲染 routes: [ &#123; path: &apos;/view/index&apos;, name: &apos;index&apos;, component： Index, children: [ path: &apos;test&apos;, component： Test ] &#125; ]&#125;) 路由嵌套需要注意的地方有两个： 上面栗子中children的path实际为 /view/index/test，如果children的path以斜杠开头，则表示为绝对路径，不收父的path影响 嵌套路由是一个新的视图，不会替换掉父视图；Index里必须包含一个route-view组件，否则不会渲染Test 需要注意的是如果path有相应的route-link，那视图激活的时候也会在该route-link下自动增加active的class，可以利用这个显示激活的菜单。如果这个不能满足，也可以根据route的matched属性，该属性会记录当前所有已匹配的路由。如上面这个例子的/view/index/test，matched属性会有两个路由信息’/view/index’和’/view/index/test’，根据这个可以把一级和二级的菜单也激活起来 在视图的component里，可以通过this.$route访问当前路由的数据信息，this.$router访问路由封装的方法。这两个对象可以很方便地操作页面的跳转和获取页面的参数 this.$route常用的参数如下： params 记录路径参数 query 记录search参数 meta 记录路由自定义的元信息 name 当前路由的别名 path 当前路由的路径 this.$router常用方法： push 路由跳转，并压入历史的堆栈 replace 路由替换，不会压入历史堆栈，也就是说back的时候，会忽略掉 back 返回 redirect 重定向 上面的push和replace，redirect都可以写到name，params，query等参数 总的来说，vue router是一个用起来十分顺手和顺心的组件。唯一遇到坑的是在微信浏览器里，微信浏览器对history支持不友好，可以切换路由哦，但是不会改变url。其实这也不能怪vue router，它也是有心无力。","permalink":"http://miniwa.com.cn/2017/08/18/2017-08-18-vue-router/","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://miniwa.com.cn/categories/基础知识/"}],"tags":[]},{"title":"环形统计图","date":"2017-02-16T11:23:19.000Z","path":"2017/02/16/2016-06-08-pie/","text":"#环形图的生成 最近遇到一个环形图的需求，图形的线是圆角的，最开始想用highchart，无奈不支持圆角，于是乎，另辟蹊径。经历了css3–&gt;canvas–&gt;graphics的历程。 graphics是一款js的svg库，里面的接口比canvas的友好。而且svg的兼容性还不赖。最开始想着椭圆的进度如何画，后来发现直接用弧线比较直接快捷。代码如下： demo [http://miniwa.com.cn/apps/pie/index.html] 123456789101112131415161718var stage = acgraph.create(&apos;container&apos;); var bigCircle = stage.circle(180, 180, 180);//最外面的大圆 bigCircle.fill(&apos;#ddd&apos;).stroke(&apos;#ddd&apos;); stage.path() //为了实现圆角用弧线变宽最为进度 .circularArc(180, 180, 160, 160, -90, 90) .stroke(&#123; color: &apos;#129090&apos;, //颜色 thickness: 40, //宽度 lineCap: &quot;ROUND&quot; //圆角 &#125;) var smallCircle = stage.circle(180, 180, 140);//里面的小圆 smallCircle.fill(&apos;#fff&apos;).stroke(&apos;#ddd&apos;);","permalink":"http://miniwa.com.cn/2017/02/16/2016-06-08-pie/","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://miniwa.com.cn/categories/基础知识/"}],"tags":[]},{"title":"javascript模板","date":"2016-06-08T11:23:19.000Z","path":"2016/06/08/2016-06-08-javascript-template/","text":"最早使用的js模板是这样子的 123456String.prototype.template = function(e, t) &#123; return this.replace(t || /\\$&#123;([^&#123;&#125;]*)&#125;/g, function(t, r) &#123; return e[r] !== undefined &amp;&amp; e[r] !== null &amp;&amp; e[r].toString() || &quot;&quot; &#125; )&#125; 主要是通过正则来匹配，替换数据，不足之处是不能嵌入js的语句，对于一些需要遍历输出的就略显蛋疼了！想起underscore的template和ejs的模板，于是去看了一下它们的实现，主要原理还是：把不需要js的当作字符串，把需要js执行的直接用js执行，通过动态创建函数，执行模板。具体实现如下： 12345678910111213141516171819202122&lt;script type=&quot;text/template&quot; id=&quot;tplStr&quot;&gt; &lt;ul&gt; &lt;% for(var i=0; i &lt;users.length; i++) &#123; %&gt; &lt;li&gt;&lt;a href=&quot;&lt;%=users[i].url%&gt;&quot;&gt;&lt;%=users[i].name%&gt;&lt;/a&gt;&lt;/li&gt; &lt;% &#125; %&gt; &lt;/ul&gt;&lt;/script&gt;function template(tplStr)&#123; var result = &quot;var _ary =[]; with(data)&#123;_ary.push(&apos;&quot; + tplStr .replace(/[\\r|\\s|\\t]/ig, &apos; &apos;) .replace(/&lt;%=(.*?)%&gt;/g, &quot;&apos;);_ary.push($1);_ary.push(&apos;&quot;) .replace(/&lt;%/g, &quot;&apos;);&quot;) .replace(/%&gt;/g, &quot;;_ary.push(&apos;&quot;) + &quot;&apos;);&#125;return _ary.join(&apos;&apos;)&quot;; var fun = new Function(&quot;data&quot;, result); return &#123; render: function(data)&#123; console.log(&quot;by function: &quot;, fun.apply(data, arguments)); &#125; &#125; &#125; 步骤如下： 前面加上 var _ary =[]; with(data){_ary.push(‘ &lt;%=users[i].url%&gt; 替换成’);_ary.push(users[i].url);_ary.push(‘ &lt;% 替换成 ‘); %&gt; 替换成 ;_ary.push(‘ 尾部加上’);}return _ary.join(‘’) 这里需要用with来暂时改变作用域链，以避免数据对象未知引起的错误，通过with可以忽略顶级的数据变量。最后通过apply来执行函数，可以使this指向当前的数据。 总的来说，难点在于如何把不变的当成字符串，需要就是执行的，让其直接执行。","permalink":"http://miniwa.com.cn/2016/06/08/2016-06-08-javascript-template/","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://miniwa.com.cn/categories/基础知识/"}],"tags":[]},{"title":"node模块加载","date":"2016-04-10T03:50:12.000Z","path":"2016/04/10/2016-04-12-node-npm/","text":"node的模块分为核心模块和文件模块，核心模块是node提供的内置模块，在node源码编译过程中，编译进了二进制执行文件，部分模块在node进程启动时就已经加载进内存中；而文件模块则是运行时动态加载。正如浏览器的缓存一样，node会对引入过的模块进行缓存，以减少二次引入的开销；不同的是node会缓存模块的结果对象而不只是文件。模块的加载包括三个步骤： 路径分析 文件定位 编译执行 路径分析node的require方法接受一个标识符作参数，实现模块加载，而该标识符主要有以下几类： 核心模块，如http、fs、path等 .或者..开头的相对路径文件模块 以/开始的绝对路径文件模块 非路径形式的文件模块，如第三方插件 文件定位核心模块 核心模块是优先加载的，也因为这个，与核心模块同名的第三方模块将不会加载。 路径形式的文件模块 以.或者..或者/开始的标识符，都会当做文件模块处理，会先将其转化为真实的路径，并以真实的路径作为索引，缓存到内存中，以便第二次加载。 第三方模块 这类模块可能是一个文件也可能是一个包，加载比较耗时。其查找文件的方式如下： 在当前文件目录下的node_modules目录 父目录下的node_modules目录 父目录的父目录的node_modules目录··· 直到根目录的node_modules目录 对于不包含后缀名的标识，node会按.js、.json、.node的次序尝试查找文件，在尝试过程中是同步的，所以写的时候如果带上后缀会速度快一点。 如果node找到一个和标识符一样的文件夹，node会当一个包来处理，查找目录下的package.json文件，通过JSON.parse解析文件的内容，从中找出main属性指定的文件名进行定位，如果仍没有文件则会找默认的index.js、index.json、index.node。 编译执行在node中，每个文件模块都是一个对象它的定义如下：123456789101112function Module(id, parent)&#123; this.id = id; this.exports = &#123;&#125;; this.parent = parent; if(parent &amp;&amp; parent.children)&#123; parent.children.push(this); &#125; this.filename = null; this.loaded = false; this.children = [];&#125; 在编译和执行的时候，node会按上面构建一个对象，再把找到的模块文件载入到对象中。对于不同的文件扩展名，node会用不同的方式载入： .js文件。通过fs模块读取后编译执行 .node文件。是用c或者c++编写的扩展文件，通过dlopen()方法加载后编译生成的文件 .json文件。通过fs读取后用JSON.parse()解释返回结果 其余扩展名文件。被当成.js文件载入 每次模块载入之后，都会将其文件路径作为索引缓存到Module.cache对象上，以提高二次引入性能。 在载入模块文件过程中，为了避免局部变量污染，会对js文件进行头尾包装，在头部添加(function (exports, require, module, filename, dirname) ；在尾部添加)。这样每个文件之间就进行了作用域隔离，包装后的文件会通过vm原生模块的runInThisContext（类似eval，只是具有具体的上下文，不会污染全局）返回一个function，而其exports会返回给调用方。 需要注意的是：模块里既然有exports可以导出接口，为何需要module.exports呢123456789101112131415function test(module, exports)&#123; module.exports = 100; exports = 100;&#125;var module = &#123;exports: 10&#125;, exports = 10;console.log(&quot;before-&gt;module.exports:&quot;, module.exports);console.log(&quot;before-&gt;exports:&quot;, exports);test(module, exports);console.log(&quot;after-&gt;module.exports:&quot;, module.exports);console.log(&quot;after-&gt;exports:&quot;, exports);//输出如下//before-&gt;module.exports: 10//before-&gt;exports: 10//after-&gt;module.exports: 100//after-&gt;exports: 10 以上的原因是：基础数据类型（number、string、boolean）的形参修改不会影响实参的值，而数组、对象的形参修改会反映到实参上。这里涉及到的是按值传递和按共享传递。 按值传递：函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。 按共享传递：对象是可变的，调用者和被调用者共享同一个对象，两者的修改都会互相可见。","permalink":"http://miniwa.com.cn/2016/04/10/2016-04-12-node-npm/","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://miniwa.com.cn/categories/基础知识/"}],"tags":[]},{"title":"reactjs总结","date":"2016-04-10T03:50:12.000Z","path":"2016/04/10/2016-04-10-react-resume/","text":"在项目中使用了reactjs框架，其对组件更加彻底，编写起来也更加方便。对外暴露的接口、api也不多。在这里想总结一下： ReactElement：拥有四个属性type，props，key，ref，不携带方法，原型上什么都没有 ReactNode：可以是ReactElement、string、number、ReactNode实例数组（ReactFragment） ReactComponent：组件，一个简单的js类，构造函数 React.unmountComponentAtNode只可以移除有React.render方法渲染的组件，而对其内部的子组件无效，会返回false React.componentWillReceiveProps接口的this.props是旧的props，新的props需要在形参里获取；初次渲染时，不会触发 this.forceUpdate在界面的数据不只是包含state还有别的时候调用 特殊的DOM属性key，在差异检查的时候会确保组件是否保留，在diff的时候，如果前后key一样，则改组件还保留在dom中只会更新数据，不一样的时候，才会移除重新生成 this.props.children返回的不是自己的子组件，而是父组件传递给你的子组件 JSX并不会返回组件的引用，而是一个ReactElement，一个描述组件结构的对象，通过Render.render函数返回的才是组件的实例 JSX只是函数调用和对象创建的语法糖，只能用表达式不能使用if else for等 同一个组件调用React.render获取到的实例是同一个对象，不会生成多个；如需重新生成一个新的饿，需先移除旧的","permalink":"http://miniwa.com.cn/2016/04/10/2016-04-10-react-resume/","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://miniwa.com.cn/categories/基础知识/"}],"tags":[]},{"title":"css居中显示","date":"2016-04-10T03:50:12.000Z","path":"2016/04/10/2015-12-05-css-center/","text":"在页面中居中可以分为水平居中和垂直居中。对水平居中常用的是margin: 0 auto，浏览器会自动计算左右的margin，那同时要实现垂直居中呢？可以如下：12345678.absolute-center &#123; margin: auto; position: absolute; overflow: auto; top: 0; left: 0; bottom: 0; right: 0; width: 50%; height: 50%;&#125; 这种做法可以兼容ie8-ie10，但是必须要有宽高。 除此之外，也可以通过left和top设置为50%，再加上margin-left和margin-right分别设为负的宽高的50%","permalink":"http://miniwa.com.cn/2016/04/10/2015-12-05-css-center/","categories":[{"name":"CSS样式","slug":"CSS样式","permalink":"http://miniwa.com.cn/categories/CSS样式/"}],"tags":[]},{"title":"js的垃圾回收机制","date":"2015-11-06T03:50:12.000Z","path":"2015/11/06/2015-11-6-reback-js/","text":"简介js无法管理内存单元，内存的分配和回收都是自动进行的。但是自动并不意味着可以不用管。如果自动分配的内存，因为使用问题而无法释放，这就会造成内存泄露了。要了解js的垃圾回收，先得清楚内存的生命周期。不管什么语言，内存生命周期基本一致：分配所需空间 –&gt; 读写分配的内存空间 –&gt; 不需要的时候将其释放\\归还 。那垃圾回收则是跟第三步相关。那回收的关键就落在如何判断“不需要”了。全局变量不会被回收，局部变量才可以回收。 要想完全将无用的内存释放掉，显然是无法通过某种算法做到的，垃圾回收只能近似地把无用的内存回收。而这种近似地算法有：引用计数和标记-清除。 引用垃圾回收算法主要依赖于引用的概念。js地数据类型分为基本类型和引用类型，引用类型就是为了解决复杂数据结构的数据不要存储多份的问题。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它 原型 的引用（隐式引用）和对它属性的引用（显式引用）。 引用计数法给每个分配的变量一个count记录引用的次数，当函数结束的时候，会扫描一下这个计算，如果变量的引用次数为零，则表明该变量没有引用指向它，则其可被回收。 123456789101112131415161718var o = &#123; a: &#123; b:2 &#125;&#125;; // 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o// 很显然，没有一个可以被垃圾收集var o2 = o; // o2变量是第二个对“这个对象”的引用o = 1; // 现在，“这个对象”的原始引用o被o2替换了var oa = o2.a; // 引用“这个对象”的a属性// 现在，“这个对象”有两个引用了，一个是o2，一个是oao2 = &quot;yo&quot;; // 最初的对象现在已经是零引用了 // 他可以被垃圾回收了 // 然而它的属性a的对象还在被oa引用，所以还不能回收oa = null; // a属性的那个对象现在也是零引用了 // 它可以被垃圾回收了 这个算法的不足是：如果一个对象引用另一个（形成了循环引用），他们可能“不再需要”了，但是他们不会被回收。所以才有了标记-清除算法。 标记-清除算法在标记清除算法里改变了策略，不以引用为0作为标识，而是以是否可达，即是否可以有跟对象访问得到。即使存在循环引用，但是由根不可达的时候，也将其回收。这个算法中有两个角色： collector：垃圾收集器 mutator：内存使用者，可以分配、读取、写入内存 collector可以回收不再使用的内存来供mutator进行NEW操作的使用。 其有两个阶段：标记(mark)和清除(sweep)， 标记阶段：collector从mutator根对象开始进行遍历，对从mutator根对象可以访问到的对象都打上一个标识，一般是在对象的header中，将其记录为可达对象。 清除阶段：collector对堆内存(heap memory)从头到尾进行线性的遍历，如果发现某个对象没有标记为可达对象-通过读取对象的header信息，则就将其回收。 垃圾回收机制的时机垃圾回收机制是由程序自动执行的，其会根据需要来执行回收程序。delete，并不会触发垃圾回收，与直接释放内存（只能通过解除引用来间接释放）没有关系。 （Node与其他语言不同的一个地方，就是其限制了JavaScript所能使用的内存（64位为1.4GB，32位为0.7GB））","permalink":"http://miniwa.com.cn/2015/11/06/2015-11-6-reback-js/","categories":[{"name":"js原理","slug":"js原理","permalink":"http://miniwa.com.cn/categories/js原理/"}],"tags":[]},{"title":"Backbone总结","date":"2015-10-10T13:50:12.000Z","path":"2015/10/10/2015-10-10-backbone/","text":"为什么选择Backbone项目之初，需要选择一个框架作为底层开发，当时想到的是angular、backbone、vue，其都是MV*的开发方式。而我考虑的几点是 学习成本低，可以快速上手 框架的利用率和总体体积 框架的更新周期 框架的讨论热度兼顾这几方面，选择了Backbone。Backbone的视图功能是比较单一和广泛的，可以随意使用，没有太多的条条框框。但是不足的是Collection和Model的功能跟View不匹配，View对于Collection和Model而言显得有点功能单薄。 BackboneBackbone的视图创建很简单，只是创建了几个公共的方法和提供一些事件监听和发布的发放，其自身不具备模板功能，和视图与Model的绑定功能，很多事情还是需要自己在程序里编写。 Backbone的Router可以实现前端的路由，而且还具备了pushState实现无刷新跳转，不过这样子需要取消所有的跳转。Router的不足是不能创建多个子的Router配置，所有的配置都扔到一个地方，也是挺难维护的。另外Router还无法监听匹配不上的事件，后来在源码里发现它找不到匹配的路由时直接跳过了，什么都没有做，所以需要监听的话，可以重写它的loadurl方法。 12345678910111213Backbone.history.loadUrl = function(fragment) &#123; fragment = this.fragment = this.getFragment(fragment); var result = _.any(this.handlers, function(handler) &#123; if (handler.route.test(fragment)) &#123; handler.callback(fragment); return true; &#125; &#125;); if(result == false)&#123; Backbone.history.trigger(&quot;router:nomatch&quot;, fragment); &#125; return result; &#125; Backbone的Model和Collection支持ResetApi，不过在项目中没怎么用，因为接口也不是resetApi风格的，基本都是自己写后端的数据请求。 Backbone在使用的时候需要注意视图的划分，划分得太细需要写太多的代码，但是耦合太多，则后期可能不好维护，需要一些经验做基础，预测一下可变的部分。","permalink":"http://miniwa.com.cn/2015/10/10/2015-10-10-backbone/","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://miniwa.com.cn/categories/基础知识/"}],"tags":[]},{"title":"浅析模块化和seajs","date":"2015-09-20T07:23:12.000Z","path":"2015/09/20/2015-09-20-seajs-source/","text":"模块化带来的问题前端交互的复杂和更新的频繁，对程序的可维护性和健壮性提出了更大的要求。基于本地文件的后端模块化，给了前端模块化很大的启示。模块化开发给维护和开发带来了很大的好处，每个功能按模块区分，不同功能通过接口沟通，各司其职，各行其道。那么模块化就要求一个功能一个模块，但是js语言本并没有模块化的功能，也无法声明模块的依赖，而且一个模块一个请求，这在分秒必争的浏览器显然是一个逆发展。总的来说，模块化需要解决以下问题： 模块的声明定义和接口的导出 模块的依赖机制 资源的优化整合 解决了以上问题，才能让模块化成为可能。 如何模块化模块的声明定义和接口的导出 js语言里本身不具备模块的功能，没关系，硬的没有，可以来软的。通过模拟实现模块的功能，以seajs为例，seajs的模块定义如下：12345678define(&quot;ModuleA&quot;, function(require, exports)&#123; var moduleB = require(&quot;ModuleB&quot;); return &#123; test: function()&#123; console.log(&quot;test&quot;); &#125; &#125;&#125;) seajs通过define函数实现模块定义功能，该函数实际上是定义了一个模块名称为ModuleA的模块，模块的内容为Factory函数，即回调函数。导出的接口导出是return的值，或者可以通过exports变量实现导出。 模块的依赖机制 模块的依赖指的是模块里面引用了别的模块，所依赖的模块与自身模块的关系维护。加载过的模块第二次再次require的时候怎么办？Factory会运行两次？答案是否定的，同一个模块不该运行两次。js里如何发现依赖？在seajs里是通过正则表达式解决的，seajs会将factory函数tostring一下，拿到函数体，再进行正则匹配拿到依赖的模块，然后去加载依赖的模块，如果发现依赖的模块也有依赖，则再起加载~递归地加载。上面的ModuleA加载的时候发现ModuleB需要先加载，则会发起一个ModuleB的加载，在浏览器里seajs是通过生产script标签进行js加载的，监听其onload事件来执行模块注册，每次加载过的模块都会保存一份到seajs.cache里，每次加载都会先判断cache里有没有，没则发起http去获取模块代码，有则看看模块是否已经运行过factory函数，如没有则运行并返回结果，有则直接返回结果。seajs3.0里做了一个优化，每次用script加载完后，都会删除该dom节点以减轻dom树的内存压力。（ps：seajs里是允许循环依赖的，不过并没有解决循环依赖，不过循环依赖这种逻辑上有问题的组织方式本就不该存在。） 模块既然是一个文件，那seajs里是如何标识一个模块的呢？也就是它的模块唯一标识的管理。seajs由于是以网络文件为基础的，它在请求每个模块的时候都会生给模块分配一个id，对与define定义的模块，会加上网络域名的前缀，如果模块本身没有id，则以模块的路径为基础如文件/static/modules/init/init.js的文件，若define的时候没有指定id，直接define(factory)，则它会以http://xxx.com:xx/static/modules/init/init.js作为模块的唯一id。值得一提的是，seajs的默认当前工作空间为sea.js文件的当前目录。也就是说require(&quot;jquery&quot;)的时候，如果jquery不是iyige别名，则它会去sea.js的当前目录里去找jquery文件。 资源的优化整合 模块化增加了文件的数量，而且由于seajs以网络文件为基础，本地找不到模块的时候，就回去加载网络上的模块，所以这也给打包带来很大的挑战。把多个模块合并成一个大文件，这也就放弃了模块当个加载的机会。那一个文件有多个模块的时候，怎么去区分一个模块呢？这就只能通过模块的id了，也就是说构建的时候需要动态生成模块的id。所以合并之前要做一个模块id提取和依赖提取的操作。 seajs的误区seajs里有几个地方很容易让人引起误解。 seajs是异步加载文件，但默认不是按需加载，模块只要require了，就会被加载。所以我们会看到network里有一些模块我们并没有用到，但是它第一次的时候已经加载了。要让其不加载，做到按需加载，只能调用require.async了。 require函数并不会发起模块文件的请求，模块文件的请求时在入口函数时，通过对factory进行正则匹配的时候发起的；require只是会触发factory的执行和获取接口。 模块化是大势所趋，但seajs的模块化方案只是js的模块化，并不是完全彻底的前端模块化。相比而言react的模块化更加彻底和完整。但是seajs的模块化可以借助构建工具完善。","permalink":"http://miniwa.com.cn/2015/09/20/2015-09-20-seajs-source/","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://miniwa.com.cn/categories/基础知识/"}],"tags":[]},{"title":"影子(shadow)DOM","date":"2015-09-20T07:23:12.000Z","path":"2015/09/20/2015-09-25-shadow-dom/","text":"shadow dom是一种把类的概念迁移到html上的实践，主要是解决一个文档中可能需要大量交互的多个dom树的建立以及其各自的功能边界问题。目前只有少量浏览器支持，下面一起来了解webkit中的shadow dom。 在代码编写过程中，我们常常会定义一个组件，把只关乎自身的东西内聚。例如：react的自定义组件、或者其他MV*框架中的组件。但这其实只是逻辑上的独立，再HTML中，它并没有独立开来，所有的节点也都是交由最顶级的HTML管理。对DOM树的遍历或者样式的选择，都会当来潜在的弊端。如果我们可以实现DOM树的封装和独立，使不同的DOM树之间可以相互独立，又可以独自渲染；那势必会使得组件化更加彻底。W3C工作组于是提出了影子DOM的概念，其使得一些DOM在特定范围内可见，而在网页的DOM树中不可见，但是渲染的结果中却包含了该节点。 HTML5新支持的特性，例如视频、音频等也都是影子DOM的思想，或许有人会疑惑，既然它不可见，那在事件传播中如何处理？W3C规定，其目标会变为包含该影子DOM的节点对象。那如何创建一个影子DOM呢？如下所示： 1234567891011121314&lt;div id=&quot;div&quot;&gt;&lt;/div&gt;&lt;script&gt;var div = document.getElementById(&quot;div&quot;), root = div.webkitCreateShadowRoot(), shdowImg = document.createElement(&quot;img&quot;), txtP = document.createElement(&quot;p&quot;); shdowImg.src = &quot;http://miniwa.com.cn/img/favicon.png&quot;;txtp.innerHTML = &quot;this is a test&quot;;root.appendChild(shdowImg);root.appendChild(txtp); &lt;/script&gt;","permalink":"http://miniwa.com.cn/2015/09/20/2015-09-25-shadow-dom/","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://miniwa.com.cn/categories/基础知识/"}],"tags":[]},{"title":"javascript的继承","date":"2015-09-12T11:23:19.000Z","path":"2015/09/12/2015-09-12-js-base-extend/","text":"继承的基础Brendan Eich在设计js语言时，面向对象编程正值兴盛之期，而定位为简易脚本语言的js需不需要兼顾面向对象的功能呢？Brendan Eich的答案是肯定的。但是js里面，函数、Object、Array等一切都是对象，也没有Class的类概念。那得用什么机制让对象联系起来呢？Brendan Eich想到了构造函数，通过new直接接一个构造函数来生成一个实例，也就是把类的概念和function糅合在一起，但是简单的构造函数与类的区别是无法共享属性和方法，function内部的都是实例new出来的对象特有的属性或方法。考虑到这一点，Brendan Eich给每个函数添加了prototype的属性，作为new出来的实例的公共属性或者方法。于是乎，在new出来的实例里都会有一个引用指向其构造函数的prototype对象。 12345678var Man = function(name)&#123; this.name = name;&#125;Man.prototype.say = function()&#123; console.log(&quot;my name is &quot; + this.name);&#125;var manA = new Man(&quot;A&quot;);var manB = new Man(&quot;B&quot;); 这里的say方法在内存中只有一份，manA和manB都引用了该方法。实际上，在new的时候执行了以下几步： 创建一个新的空对象，这个对象的类型是object； 设置对象的构造函数（prototype.construtor所指向的构造函数），以及一些基础属性； 执行构造函数，当this关键字被提及的时候，使用新创建的对象的属性； 返回新创建的对象； 由于每个实例都保存了构造函数的prototype，而且prototype里有每个实例的公共方法或者属性，那如果构造函数里自定义了一些属性与prototype里的重名了（js里函数名是唯一的标识，形参不作为函数的标识），那怎么办？js里是以实例的属性优先，找不到的时候再去prototype里面查找，并会沿着prototype的链条查找； 继承的方式继承是为了达到子承父业的效果，可以对一个对象拓展，得到一个功能更加强大的新对象。那js里可以如何实现这种效果呢？ 方式一 在执行构造函数的时候，直接绑定子与父的关系，即通过call或者apply在子类的构造函数里，用子类的上下文执行以下父类的方法，从而把父类的属性绑定到子类，实现继承。12345678var Man = function(name)&#123; this.name = name;&#125;var ChildMan = function(name)&#123; Man.apply(this, arguments); this.age = 12;&#125;var manA = new ChildMan(&quot;A&quot;); 这里的不足之处是：子类的实例里，每一个都拥有了一份独立的属性，并没有共享，只是形式上的继承，同源不同宗。 方式二 利用原型链的上溯特性实现继承，把父类的prototype赋值给子类的prototype。这里就可以灵活实现了 如果不介意修改父类会影响子类，可以直接把ChildMan.prototype = Man.prototype； 否则需要用把父对象的实例赋值给子类的prototype，即ChildMan.prototype = new Man()； 再则，不想执行父类构造函数，可以先利用一个空的构造函数来实例化一个Man，如下123var F = function()&#123;&#125;;F.prototype = Man.prototype;ChildMan.prototype = new F(); 方式很多，原理都是拿到父类的prototype，但是上面的方法都需要注意子类的构造函数，修改了子类的prototype之后，其构造函数也会跟着改变，这时候还需要改回来，加上ChildMan.prototype.constructor = ChildMan；为什么一定要加上？因为当调用instanceOf的时候，会通过对象的构造函数来区分。 继承的方式各种各样，没有最好的，只有最适合的。如果是一个单例模式的对象，根本就不用考虑是否会影响到父类；但是如果对象会有很多实例的，则完全不同。所以，选择最合适的，才是最好的。","permalink":"http://miniwa.com.cn/2015/09/12/2015-09-12-js-base-extend/","categories":[{"name":"js原理","slug":"js原理","permalink":"http://miniwa.com.cn/categories/js原理/"}],"tags":[]}]}