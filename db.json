{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/apps/logo.png","path":"apps/logo.png","modified":0,"renderable":0},{"_id":"source/apps/canvas-dice/README.md","path":"apps/canvas-dice/README.md","modified":0,"renderable":0},{"_id":"source/apps/canvas-dice/index.html","path":"apps/canvas-dice/index.html","modified":0,"renderable":0},{"_id":"source/apps/dear/index.html","path":"apps/dear/index.html","modified":0,"renderable":0},{"_id":"source/apps/canvas-dice/index.js","path":"apps/canvas-dice/index.js","modified":0,"renderable":0},{"_id":"source/apps/pie/index.html","path":"apps/pie/index.html","modified":0,"renderable":0},{"_id":"themes/archer/source/assets/example_qr.png","path":"assets/example_qr.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/favicon.ico","path":"assets/favicon.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/avatar/logo.png","path":"avatar/logo.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/loading.svg","path":"assets/loading.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css","path":"css/mobile.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff","path":"font/Source Sans Pro.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","path":"font/Source Sans Pro.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/webfontloader.min.js","path":"lib/webfontloader.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js","path":"scripts/share.js","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/index.js","path":"intro/index.js","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","path":"font/Oswald-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","path":"font/SourceCodePro-Regular.ttf.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","path":"font/SourceCodePro-Regular.ttf.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/jquery.min.js","path":"lib/jquery.min.js","modified":0,"renderable":1},{"_id":"source/apps/dear/source/default.css","path":"apps/dear/source/default.css","modified":0,"renderable":0},{"_id":"source/apps/dear/source/functions.js","path":"apps/dear/source/functions.js","modified":0,"renderable":0},{"_id":"source/apps/dear/source/jscex-async-powerpack.min.js","path":"apps/dear/source/jscex-async-powerpack.min.js","modified":0,"renderable":0},{"_id":"source/apps/dear/source/jscex-builderbase.min.js","path":"apps/dear/source/jscex-builderbase.min.js","modified":0,"renderable":0},{"_id":"source/apps/dear/source/jscex-async.min.js","path":"apps/dear/source/jscex-async.min.js","modified":0,"renderable":0},{"_id":"source/apps/dear/source/jscex-jit.js","path":"apps/dear/source/jscex-jit.js","modified":0,"renderable":0},{"_id":"themes/archer/source/intro/404-bg.jpg","path":"intro/404-bg.jpg","modified":0,"renderable":1},{"_id":"source/apps/pie/graphics.min.js","path":"apps/pie/graphics.min.js","modified":0,"renderable":0},{"_id":"source/apps/dear/source/jscex-parser.js","path":"apps/dear/source/jscex-parser.js","modified":0,"renderable":0},{"_id":"source/apps/dear/source/love.js","path":"apps/dear/source/love.js","modified":0,"renderable":0},{"_id":"source/apps/dear/source/jscex.min.js","path":"apps/dear/source/jscex.min.js","modified":0,"renderable":0},{"_id":"source/apps/dear/source/jquery.min.js","path":"apps/dear/source/jquery.min.js","modified":0,"renderable":0},{"_id":"themes/archer/source/scripts/main.js","path":"scripts/main.js","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/index-bg.jpg","path":"intro/index-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/post-bg.jpg","path":"intro/post-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/index-bg1.jpg","path":"intro/index-bg1.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/index-bg3.jpg","path":"intro/index-bg3.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/about-bg.jpg","path":"intro/about-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/index-bg2.jpg","path":"intro/index-bg2.jpg","modified":0,"renderable":1},{"_id":"source/apps/dear/Love-Music.mp3","path":"apps/dear/Love-Music.mp3","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"a49f7895e54fc4ad26ed667219914137ebe0a8e9","modified":1464497268269},{"_id":"themes/archer/.gitignore","hash":"d734edbdd316a19eae0ac2421256ac60dd61a1f8","modified":1527347826739},{"_id":"themes/archer/.eslintrc.json","hash":"f398447605f56aa0bb9e250f8df0651a1f79ac45","modified":1527347826738},{"_id":"themes/archer/LICENSE","hash":"35f4fb806270f8243459c870a2141e795dfab166","modified":1527347826741},{"_id":"themes/archer/README.md","hash":"f04b6612409893d42cf6a9322cc7f1968ee30565","modified":1527347826742},{"_id":"themes/archer/_config.yml","hash":"bb519a55443f877f6ec77bbcf495ef644ad851fc","modified":1527932786002},{"_id":"themes/archer/webpack.config.js","hash":"369feedf559c96614506523dbabe95206ef2d20c","modified":1527347826885},{"_id":"themes/archer/webpack.prod.js","hash":"b6d35f7e9a9718b3e5e3e17c52fcc5e7c38330b0","modified":1527347826887},{"_id":"themes/archer/gulpfile.js","hash":"80904133877d92adc62964fe798f81579f7b33a7","modified":1527907038901},{"_id":"themes/archer/package.json","hash":"d7bc8a5073dc9fd24186125ebf104fda2195119a","modified":1527901483059},{"_id":"source/about/index.md","hash":"4f2bccf1e95e4dd5c86a3fc80fae398ca3174f65","modified":1527388154082},{"_id":"source/apps/logo.png","hash":"a2c1b4fe8468f927c967ea791d6e5e9071147949","modified":1463244822177},{"_id":"source/_posts/2015-09-12-js-base-extend.markdown","hash":"052d67acae4a801c732c2db295cad27198a2b0ef","modified":1527350548275},{"_id":"source/_posts/2015-10-10-backbone.markdown","hash":"d7b69b308154aeb95285edfb03e9fd7a7b9e1bd4","modified":1527350548400},{"_id":"source/_posts/2015-09-25-shadow-dom.markdown","hash":"e6fad2fb55fe3fd49464709a0e0412c91120439f","modified":1527350585725},{"_id":"source/_posts/2015-11-6-reback-js.markdown","hash":"86dc0e319a03b1711e4c5be4bd4b7b936214da44","modified":1527350548462},{"_id":"source/_posts/2016-04-12-node-npm.markdown","hash":"d810c34fb4067c806c4bc43de829a0fa4deb312a","modified":1527350548556},{"_id":"source/_posts/2016-04-10-react-resume.markdown","hash":"7498ea8dd88ea1ed897b01afabd69027cf517a76","modified":1463745919584},{"_id":"source/_posts/2015-09-20-seajs-source.markdown","hash":"1c0e783187ff37f8b0decdcf005cf64ef0f32ae6","modified":1527350548321},{"_id":"source/_posts/2015-12-05-css-center.markdown","hash":"8b050294c405ac7f67b5c6b42fc5b802dea78749","modified":1527350548525},{"_id":"source/_posts/2016-06-08-javascript-template.markdown","hash":"fc828eea9891cbadf7ef98b56fddf8b435fed932","modified":1527350548603},{"_id":"source/_posts/2016-06-08-pie.markdown","hash":"b58314c3e2cfbea5e3eea7143b5e2f5ee17be18e","modified":1527350548618},{"_id":"source/_posts/2017-08-18-vue-router.markdown","hash":"801b30841a20dac9b1aad21fd1532a6e7d3e5161","modified":1527350548650},{"_id":"source/_posts/2017-09-01-vuex-base.markdown","hash":"e55333ea29b251f8c2177c049337d0506b002102","modified":1527350548696},{"_id":"source/_posts/2017-09-09-about-es6.markdown","hash":"bf53585178a8a32add15330219586b51f067afb6","modified":1527388620088},{"_id":"source/_posts/2017-08-05-yangshuoyouji.markdown","hash":"f6d90be4787bf37ac511f2c9444fa8630a212abf","modified":1527909772665},{"_id":"source/_posts/2017-09-10-get-data.markdown","hash":"00d0129ce3b8d451bc9db9080603c8a15f55ce89","modified":1527351342547},{"_id":"source/_posts/2017-08-20-xiamen.markdown","hash":"b429845c5d160c08a0a611bbfff4636d513c1b8c","modified":1527909743915},{"_id":"source/_posts/2018-02-14-egg-validate.md","hash":"4ea864cdc3963921bf8f922249c56e6605fb10be","modified":1527908909822},{"_id":"source/_posts/2018-02-19-chongsheng.md","hash":"de9cc58317c7f6afb30271190a659b81f696b9f6","modified":1527926823535},{"_id":"themes/archer/docs/develop-guide-en.md","hash":"8a544d8196d456cbae1de78ba01bd7530f9653b1","modified":1527347826746},{"_id":"themes/archer/docs/README-en.md","hash":"eb815eb7e1cbeebb5070d41c19fb22673ff8676b","modified":1527347826745},{"_id":"themes/archer/docs/develop-guide-zh.md","hash":"f20432b5b6453ad7f452b06d5adbfe558a15646f","modified":1527347826747},{"_id":"themes/archer/layout/404.ejs","hash":"a054b4ea1147846bed4252dd56182cb8e32d95eb","modified":1527347826753},{"_id":"themes/archer/layout/about.ejs","hash":"990df15653a99453617e72dfc195fa0a75b9a5d1","modified":1527347826784},{"_id":"themes/archer/layout/site-meta.ejs","hash":"28b014bc19e934e3b118064e32d68d8a32a6a682","modified":1527347826789},{"_id":"themes/archer/layout/layout.ejs","hash":"b9a228de6f2711ad42f484ceb030199a8a501271","modified":1527908162706},{"_id":"themes/archer/layout/post.ejs","hash":"2837097d55f8db50efdb5a249343c1128dd8c392","modified":1527910287209},{"_id":"themes/archer/layout/index.ejs","hash":"ca1e93247351c10095f2bf16efe31019ce31b040","modified":1527907468148},{"_id":"themes/archer/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1527347826710},{"_id":"themes/archer/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1527347753209},{"_id":"themes/archer/.git/config","hash":"5eebe6b6c747b81932b497364062f5b1841954bc","modified":1527347826724},{"_id":"themes/archer/.git/index","hash":"42e577144ee715a493ff57512da6e971bbe97c13","modified":1527910242432},{"_id":"themes/archer/.git/packed-refs","hash":"e63ee3a2a2d39db85641ceebf802270e0500049b","modified":1527347826698},{"_id":"source/apps/canvas-dice/README.md","hash":"cbf89fa3b0ddc3a68336ff377f567803349dfde1","modified":1462294370050},{"_id":"source/apps/canvas-dice/index.html","hash":"91b6bfc2c1704302c70adb343f162004bbad71dc","modified":1462294369894},{"_id":"source/apps/dear/index.html","hash":"93571e4051383b8885584f8d86f4b595bbfb267b","modified":1462294368568},{"_id":"source/apps/canvas-dice/index.js","hash":"93e400d24e7eb40ed5774683010fc0a6335c5c6b","modified":1462294369754},{"_id":"source/apps/pie/index.html","hash":"8d35456c5fb6217bba83c744395c4f56464a65f4","modified":1527921977005},{"_id":"source/_posts/2017-09-09-about-es6/about-es6.jpg","hash":"bfa72a71f715a8bad23b8029cecb645f46801f76","modified":1504919377132},{"_id":"source/_posts/2017-09-10-get-data/step1.png","hash":"d3edd166b8c52bd0b56bba2dd4a4f38cfef2e7b5","modified":1505010136168},{"_id":"source/_posts/2017-09-10-get-data/step3.png","hash":"7c696732a0e62f61cfe3e7954a515fc8cc595335","modified":1505010211173},{"_id":"source/_posts/2017-09-10-get-data/step4.png","hash":"472cdb010f92387187d65f6fee991b23d3cdda39","modified":1505010290156},{"_id":"themes/archer/layout/_partial/base-footer.ejs","hash":"212cf39a45202649c9230bc4a4fe961fd80ec14b","modified":1527388568864},{"_id":"themes/archer/layout/_partial/base-background-image.ejs","hash":"eb7fe98366b96c5541667ea9e85cbbacb36e307a","modified":1527782126642},{"_id":"themes/archer/layout/_partial/base-head.ejs","hash":"ef4944b445d494d0aaae30fa785811c6401978f4","modified":1527388560393},{"_id":"themes/archer/layout/_partial/base-preload-polyfill.ejs","hash":"065f8d6c4aae6782e6819815911f7feb6402a4ec","modified":1527347826760},{"_id":"themes/archer/layout/_partial/base-share.ejs","hash":"593398145ff712f3c01fff9fe2d2b38bfa8bb20b","modified":1527347826763},{"_id":"themes/archer/layout/_partial/base-title-tags.ejs","hash":"e1b4893af2b18f502bad1b552c3f3381ecc3021f","modified":1527347826765},{"_id":"themes/archer/layout/_partial/base-social.ejs","hash":"92ac580acc20bde7b3345bfe132671b9043bfbd6","modified":1527347826764},{"_id":"themes/archer/layout/_partial/base-profile.ejs","hash":"53551f68f343f1b8feb5e4866befbeac812c23ba","modified":1527921888609},{"_id":"themes/archer/layout/_partial/intro-height.ejs","hash":"fc03729825ac7ffd4045f910bbd936bc5841c65e","modified":1527347826775},{"_id":"themes/archer/node_modules/image-optimizer-cli/.editorconfig","hash":"abbb6e0366542662ff3be2cdcbec3ff81d5e1f29","modified":1514315467000},{"_id":"themes/archer/layout/_partial/base-header.ejs","hash":"6ab9795643a755b24ce62128a22c60cee99e9075","modified":1527907358173},{"_id":"themes/archer/source/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1527347826797},{"_id":"themes/archer/source/assets/favicon.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1527347826798},{"_id":"themes/archer/source/avatar/logo.png","hash":"a2c1b4fe8468f927c967ea791d6e5e9071147949","modified":1463244822177},{"_id":"themes/archer/source/assets/loading.svg","hash":"85082b002bae1335114b71550350907884187e38","modified":1527347826800},{"_id":"themes/archer/node_modules/image-optimizer-cli/index.js","hash":"f192719723d12e7ba507272a4719ec4a632d8cfe","modified":1527901481137},{"_id":"themes/archer/source/css/mobile.css","hash":"9993d456a1c838fbbe834dba11d365e85e77b788","modified":1527908037481},{"_id":"themes/archer/source/css/style.css","hash":"f7b81485740ad6d1c6f7e7ab6d7c5f79b763bcd0","modified":1527908037474},{"_id":"themes/archer/node_modules/image-optimizer-cli/package.json","hash":"84218c0e9a003dec01621dd4bd40edfa67bcb36d","modified":1527901480242},{"_id":"themes/archer/source/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1527347826810},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1527347826811},{"_id":"themes/archer/source/lib/webfontloader.min.js","hash":"6f18a92bbe8bed93113449ed6ff8d148c1e7565a","modified":1527347826830},{"_id":"themes/archer/src/scss/_common.scss","hash":"de6686083c920d425997f090839a5fb3a9174d46","modified":1527352125447},{"_id":"themes/archer/src/scss/_mixin.scss","hash":"46d9e40be9000d23494a80cdd74fea61328ffdfa","modified":1527347826857},{"_id":"themes/archer/src/scss/_normalize.scss","hash":"9123aa118cc636b4bfe718b87274d0b9732d8e89","modified":1527347826858},{"_id":"themes/archer/src/scss/_variables.scss","hash":"35111feb58a46ed571d6de03e37f6ea39f07865a","modified":1527347826881},{"_id":"themes/archer/src/scss/mobile.scss","hash":"537465908c65f704403f8f21059085e7d0c5473c","modified":1527347826883},{"_id":"themes/archer/src/scss/style.scss","hash":"a3ab7cfddfb17979079fada4834db00b7c51f133","modified":1527781457404},{"_id":"themes/archer/source/scripts/share.js","hash":"f122b2a267f664b809870f08535175945c3a53aa","modified":1527907073125},{"_id":"themes/archer/source/intro/index.js","hash":"474f3187ab32f826d0e131f916ef829e88c31439","modified":1527901956053},{"_id":"themes/archer/src/js/fancybox.js","hash":"62a190b65d777057e86394d81869fbfa5051ca28","modified":1527347826838},{"_id":"themes/archer/src/js/browser.js","hash":"6e98eacb585fc24fe1f14e80dcb8d3b7d1b463fb","modified":1527347826837},{"_id":"themes/archer/src/js/init.js","hash":"fb1ea412d1306f07a62f95c56c732ad891036769","modified":1527347826840},{"_id":"themes/archer/src/js/main.js","hash":"76afb243aae296609cb3ed800d26b30d6294dfbe","modified":1527781562180},{"_id":"themes/archer/src/js/initSidebar.js","hash":"d94a9da296c56e9b75def4386849df2b3b80e982","modified":1527347826841},{"_id":"themes/archer/src/js/mobile.js","hash":"27b974d628a94f5abd700ca7757bcd153d866442","modified":1527347826844},{"_id":"themes/archer/src/js/scroll.js","hash":"149f251f6ae1a319eecfc903ece61b9a6f4bede4","modified":1527347826846},{"_id":"themes/archer/src/js/share.js","hash":"0c0ccd800e063bda901b99e5bfbe96c72723e5ba","modified":1527347826848},{"_id":"themes/archer/src/js/sidebar.js","hash":"34046a7c8e13b92d7fefb2f5ce0851e2d070cdc5","modified":1527907072013},{"_id":"themes/archer/src/js/tag.js","hash":"18f58d928583ba84f2c53d069d57acd4d21677af","modified":1527347826850},{"_id":"themes/archer/src/js/util.js","hash":"da642e9e6b50ef56a6f85dab85d19b087e4ba373","modified":1527347826853},{"_id":"themes/archer/.git/logs/HEAD","hash":"660f2e170b0bf28d69a7bbd559234c04f2495983","modified":1527347826717},{"_id":"themes/archer/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1527347753258},{"_id":"themes/archer/src/js/toc.js","hash":"e6778bb114307cccdb5462b150fb4c79e0435f99","modified":1527347826851},{"_id":"themes/archer/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1527347753222},{"_id":"themes/archer/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1527347753231},{"_id":"themes/archer/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1527347753232},{"_id":"themes/archer/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1527347753229},{"_id":"themes/archer/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1527347753243},{"_id":"themes/archer/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1527347753241},{"_id":"source/_posts/2017-08-05-yangshuoyouji/20.JPG","hash":"846dfb46e87775eca0bc3b1d67df07e9dd12e63f","modified":1503105896078},{"_id":"source/_posts/2017-09-10-get-data/step5.png","hash":"290f5f8dd4ffef838572a819eda90ef8842a3e61","modified":1505010548119},{"_id":"source/_posts/2017-08-20-xiamen/3.JPG","hash":"41e51535a84c160755bf6746ada4d489620d0d53","modified":1503232548722},{"_id":"themes/archer/layout/_partial/comment/custom.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1527347826767},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1527900807205},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1527347826813},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1527347826814},{"_id":"themes/archer/source/lib/jquery.min.js","hash":"0c3192b500a4fd550e483cf77a49806a5872185b","modified":1527347826829},{"_id":"source/apps/dear/source/default.css","hash":"a18eba21f1dea9722dcebef5bf92a102c7013a5b","modified":1462294365511},{"_id":"source/apps/dear/source/functions.js","hash":"e218c3d4ff7e9197417e361ca880f6154b1f64db","modified":1462294364450},{"_id":"source/apps/dear/source/jscex-async-powerpack.min.js","hash":"033e94c70ee9ede1afbe16d84719c0a309154d2a","modified":1462294366540},{"_id":"source/apps/dear/source/jscex-builderbase.min.js","hash":"bc568f8645624a9d52736a434b5ba816225b6cf3","modified":1462294364840},{"_id":"source/apps/dear/source/jscex-async.min.js","hash":"0e709db93a3c6ad1a59b14e906cf7d463b179d88","modified":1462294364575},{"_id":"themes/archer/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1527347753249},{"_id":"themes/archer/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1527347753253},{"_id":"themes/archer/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1527347753255},{"_id":"source/apps/dear/source/jscex-jit.js","hash":"13a6c3f7d2cad91b35e1eafc7d15d18fdacb198b","modified":1462294365745},{"_id":"themes/archer/source/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1527347826817},{"_id":"themes/archer/src/js/swiper.min.js","hash":"2a849b7dfd9c6a335f9deff23de164eb939a383d","modified":1527780856039},{"_id":"themes/archer/package-lock.json","hash":"12702b5d6e32fd986a48afb46c4981fe7338c248","modified":1527901483187},{"_id":"source/apps/pie/graphics.min.js","hash":"a7104ac1f8a6a64f9ea948a1b9e39d651198a073","modified":1503072189951},{"_id":"source/_posts/2017-08-05-yangshuoyouji/10.JPG","hash":"63fe16cdbe4f8c532332193bf4052293c25ef877","modified":1503105892001},{"_id":"source/_posts/2017-08-05-yangshuoyouji/12.JPG","hash":"22f45234761be1d2cf2fc07d4aeaeba42abf3571","modified":1503105892824},{"_id":"source/_posts/2017-08-05-yangshuoyouji/13.JPG","hash":"5f60b5b14c956d799f56d215764c704c8ab71dba","modified":1503105893224},{"_id":"source/_posts/2017-08-05-yangshuoyouji/17.JPG","hash":"817ba53f25c46d4cd109abf1ebc51592f3004841","modified":1503105894877},{"_id":"source/apps/dear/source/jscex-parser.js","hash":"b858660942bba307ee9292abca18d125f4356b66","modified":1462294364341},{"_id":"source/apps/dear/source/love.js","hash":"e48cbbd92c06869cd0c8063897f81fc05d70a5b5","modified":1462294364216},{"_id":"source/apps/dear/source/jscex.min.js","hash":"9c360d252d6b4b38debdc6acec990ddbf1146f54","modified":1462294365121},{"_id":"source/_posts/2017-08-20-xiamen/1.JPG","hash":"6a8d1d82d97d7d0b7ae25365c1b97e65edbbc7ef","modified":1503232547064},{"_id":"source/_posts/2017-08-20-xiamen/11.JPG","hash":"d88d5951a5881b71c495411c17f51e13511c55d1","modified":1503232554493},{"_id":"source/_posts/2017-08-05-yangshuoyouji/7.JPG","hash":"192ae7aec16d84b5a61a80ece25c415e18581632","modified":1503105890807},{"_id":"source/_posts/2017-08-05-yangshuoyouji/19.JPG","hash":"7807d2fa13642cbce5fcab5d8aeb692e7c312701","modified":1503105895675},{"_id":"source/_posts/2017-09-10-get-data/step2.png","hash":"2096c9d1bc2ddcde59deed44a791f1b2d6ab5ee1","modified":1505010172593},{"_id":"themes/archer/layout/_partial/comment/changyan.ejs","hash":"60189b4c02a1b886ecfdc758c55c9a24fa7d36af","modified":1527347826767},{"_id":"themes/archer/layout/_partial/comment/youyan.ejs","hash":"483c07212879b116b772f428547c9962be96d2ce","modified":1527347826772},{"_id":"themes/archer/layout/_partial/comment/disqus.ejs","hash":"cfdb15116abe89f4b54f7bb18a0b23a597c47a60","modified":1527347826768},{"_id":"themes/archer/layout/_partial/comment/gitment.ejs","hash":"c043a98e33252b9a628bfd31c4a3b2883dce2b99","modified":1527347826770},{"_id":"themes/archer/layout/_partial/critical-css/critical-style.ejs","hash":"c22a713d188bf15e5db02b69b2b3714eb431dc79","modified":1527347826774},{"_id":"themes/archer/layout/_partial/comment/livere.ejs","hash":"a6acb5d7778ade98ba5b6932e38a585460513f49","modified":1527347826771},{"_id":"themes/archer/layout/_partial/sidebar/base-sidebar.ejs","hash":"21be7273e0538475481b4287a256025c65c5df3c","modified":1527906059994},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-categories.ejs","hash":"4feb7c3d17a3c8994eb095d43d75fbd0f1ed5b4f","modified":1527347826781},{"_id":"themes/archer/layout/_partial/script/font-loader.ejs","hash":"4ab770014b1037510d4ef914799d2b7c78f8b890","modified":1527347826777},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-tags.ejs","hash":"e96750b1aa7113322696857882b1e1fde11c1fc4","modified":1527347826782},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-archives.ejs","hash":"237a1b8002661065407a6bf96c3188eb09597525","modified":1527347826780},{"_id":"themes/archer/node_modules/image-optimizer-cli/lib/crawl.js","hash":"7575e1351747e90de1107f6b3b03d4c9ec125c31","modified":1526555954000},{"_id":"themes/archer/node_modules/image-optimizer-cli/lib/optimize.js","hash":"cacd1f0be93dd33469d984a62666e2c4e95f5086","modified":1519762049000},{"_id":"themes/archer/node_modules/image-optimizer-cli/lib/log.js","hash":"9c5743f7699aece9d831322a9909542715ee0a94","modified":1515876320000},{"_id":"themes/archer/src/scss/_partial/_404.scss","hash":"6631872bf75d10a0ccc5c03704e428d74d6835c5","modified":1527347826861},{"_id":"themes/archer/src/scss/_partial/_index-page.scss","hash":"4a20a4e39f94b4253a0f18f994e3cfb8215be3bc","modified":1527907846129},{"_id":"source/apps/dear/source/jquery.min.js","hash":"d1e1f3f0828fa66fb5744f42bc912694e06300f9","modified":1462294366353},{"_id":"themes/archer/src/scss/_partial/slide.scss","hash":"16bb9daf33ec818e293eff5cae7fad701f72e1d2","modified":1527781147749},{"_id":"themes/archer/src/scss/_partial/_post-page.scss","hash":"62f05d88a76066add3a1518b1fdf876178cb5245","modified":1527908037218},{"_id":"themes/archer/.git/refs/heads/master","hash":"64e1cca1d57c5c1f684261682d80e606e6ab12ca","modified":1527347826714},{"_id":"source/_posts/2017-08-05-yangshuoyouji/1.JPG","hash":"c1f428e34c7b3cfd13e9327287eac5fac266762d","modified":1503105888174},{"_id":"source/_posts/2017-08-05-yangshuoyouji/11.JPG","hash":"86b60d9666f3b09e13d196876133a499891ed6f9","modified":1503105892415},{"_id":"source/_posts/2017-08-05-yangshuoyouji/2.JPG","hash":"a142f9e743c5b2c2992c4e30685118820eb27078","modified":1503105888582},{"_id":"source/_posts/2017-08-05-yangshuoyouji/3.JPG","hash":"c91f709283ff89b60cccc6496665e4f6a355ec14","modified":1503105888983},{"_id":"source/_posts/2017-08-05-yangshuoyouji/18.JPG","hash":"3d21d43115fc14e683b17c8f8bf082bf1cffb872","modified":1503105895289},{"_id":"source/_posts/2017-08-05-yangshuoyouji/9.JPG","hash":"26c5d87200f410f17cb34aaee35db7bf062e3d0e","modified":1503105891603},{"_id":"source/_posts/2017-08-20-xiamen/10.JPG","hash":"b113c95603dd8a9821e8fbbfde0abb6a3b001397","modified":1503232553756},{"_id":"source/_posts/2017-08-20-xiamen/12.JPG","hash":"168e57d21db323bdaa4c1c2eaf708180ae9496df","modified":1503232555246},{"_id":"source/_posts/2017-08-20-xiamen/14.JPG","hash":"d7a524eeff2e5539f5076b53d343ecb1094bead1","modified":1503232556886},{"_id":"source/_posts/2017-08-20-xiamen/17.JPG","hash":"d111d5ff704a44ed7598fb150516ef46f2e074ae","modified":1503232559249},{"_id":"source/_posts/2017-08-20-xiamen/2.JPG","hash":"4ac8a4dac9c726e7a2928d407f1422dc41845b2c","modified":1503232547900},{"_id":"source/_posts/2017-08-05-yangshuoyouji/8.JPG","hash":"3e355528a6e5da7fa182f3599cf3bf723e0beb3e","modified":1503105891199},{"_id":"source/_posts/2017-08-20-xiamen/8.JPG","hash":"be4f04dd0cbbfefb474525c83208f2e4509bac2f","modified":1503232552336},{"_id":"themes/archer/docs/snap.png","hash":"0b2a8bf016f6eed576abfdcdb7dcf8de51c12562","modified":1527347826750},{"_id":"source/_posts/2017-08-20-xiamen/9.JPG","hash":"e923f3b4580f707e3a3a60f59e9b23420f6f0063","modified":1503232553022},{"_id":"source/_posts/2017-08-20-xiamen/16.JPG","hash":"c9d6e868dbe313f720f134d8f4c1101dc42637b0","modified":1503232558458},{"_id":"source/_posts/2017-08-20-xiamen/4.JPG","hash":"0fa661e8c599d11eb28252faed83c89ec55bed06","modified":1503232549404},{"_id":"themes/archer/source/scripts/main.js","hash":"92c173d9fd20efbcd942302a0df1b79e72012920","modified":1527907073123},{"_id":"themes/archer/source/intro/index-bg.jpg","hash":"5d0361fa6460ea24b60975cbaf4c0e9a3641a59c","modified":1527902746129},{"_id":"themes/archer/source/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1527347826827},{"_id":"themes/archer/source/intro/index-bg1.jpg","hash":"6c3156a87a682941d03014355b14dbdd235a9eb2","modified":1527902746255},{"_id":"source/_posts/2017-08-05-yangshuoyouji/14.JPG","hash":"cc963e77d8e71c0407e1aff0548d7b6a9c85603c","modified":1503105893641},{"_id":"themes/archer/.git/objects/pack/pack-0de2d99d83161293ccff94414bbf8129b2f0f8fa.idx","hash":"27d94b27cc56339c8098b5c5b4b5ea639932269a","modified":1527347826428},{"_id":"source/_posts/2017-08-05-yangshuoyouji/15.JPG","hash":"983e0b3fb69fc99d048aaa027e18e9f91d6f82a4","modified":1503105894049},{"_id":"source/_posts/2017-08-05-yangshuoyouji/16.JPG","hash":"a1d0bb2a8cfc6884853e1227f7862df556ac0e78","modified":1503105894452},{"_id":"source/_posts/2017-08-05-yangshuoyouji/4.JPG","hash":"3d4a8457940cf202dbc4a751f40fb48c8cf424e9","modified":1503105889422},{"_id":"source/_posts/2017-08-05-yangshuoyouji/5.JPG","hash":"632e88251748bdc3d564e22d09d8bad3e5f8daea","modified":1503105889934},{"_id":"source/_posts/2017-08-20-xiamen/13.JPG","hash":"9bc39079c131b2f7ef0085528019661e870e1d8e","modified":1503232555944},{"_id":"source/_posts/2017-08-20-xiamen/6.JPG","hash":"f8d84c6446ef2d5ca0e13c98e47f59c14682db5b","modified":1503232550849},{"_id":"source/_posts/2017-08-20-xiamen/7.JPG","hash":"07b32a30022a2598dba23e85d2f8f23c6b478ce7","modified":1503232551643},{"_id":"source/_posts/2017-08-20-xiamen/5.JPG","hash":"aadb103bf38867e887cac4bdbe4d875623ca5a83","modified":1503232550111},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/ansi-styles/index.js","hash":"b61182f5204ff5f4f64a7c666569975205a9e3c0","modified":1519983217000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/ansi-styles/package.json","hash":"b145b08dc3578bc90cf91c4a4a191014fbc9d8f1","modified":1527901480424},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/chalk/index.js","hash":"612bca2861fd84ccca956db0cf7a528fda99e4d4","modified":1518344730000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/chalk/package.json","hash":"f47cdf0cca6683cfb30dd829aef46099692b1c65","modified":1527901480274},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/chalk/index.js.flow","hash":"f449fe1d90bbb743ffc32a8a29364d6ef2debc30","modified":1524719704000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/ansi-styles/license","hash":"5aaf48196ddd4d007a3067aa7f30303ca8e4b29c","modified":1496344655000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/has-flag/index.js","hash":"73ee55646b931a37ef3b38fd6d22cd56332d6724","modified":1514920575000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/chalk/license","hash":"5aaf48196ddd4d007a3067aa7f30303ca8e4b29c","modified":1496344655000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/chalk/templates.js","hash":"ae6bfdd37656f7ae4e35e4b4f56e0053af538fd8","modified":1520012334000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/has-flag/package.json","hash":"1add7e13a260443160ce3d9b5dc9872a18fd1259","modified":1527901480274},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/has-flag/license","hash":"5aaf48196ddd4d007a3067aa7f30303ca8e4b29c","modified":1496344655000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/minimist/.travis.yml","hash":"6f47845eac101b08d34b0cfb4cb6d0614b69b4b2","modified":1438902274000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/chalk/readme.md","hash":"3cca523d2882142c7124422f1eee7496eabfb01c","modified":1524206575000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/ansi-styles/readme.md","hash":"3673eb4048729e8286ddb3566f361d01bad50682","modified":1518353760000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/minimist/index.js","hash":"cfede1ccd2ee41f74022c002b5c6d05e65c482c0","modified":1440424576000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/minimist/package.json","hash":"7b4df6bcff7dc96ef15e47fa0253ec768ef7bf00","modified":1527901480274},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/supports-color/browser.js","hash":"9800d972941ea5bf3e0838f8686dbe9ff97ba98b","modified":1521908559000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/minimist/readme.markdown","hash":"067b8f01bd1fcf09a6418e3db4b323c8eb9ad479","modified":1438902274000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/supports-color/license","hash":"5aaf48196ddd4d007a3067aa7f30303ca8e4b29c","modified":1521908559000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/supports-color/package.json","hash":"df221f21a2825b7099d523908b453af3cddcd8be","modified":1527901480274},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/minimist/LICENSE","hash":"b2e68ce937c1f851926f7e10280cc93221d4f53c","modified":1438902274000},{"_id":"themes/archer/node_modules/image-optimizer-cli/lib/helper/usage.js","hash":"adff121cb97372611dc0c5dbab29a5288cb8c0f9","modified":1519759116000},{"_id":"themes/archer/src/scss/_partial/_partial/_footer.scss","hash":"1938574e03a8a272cf99ac5d0bdc1fad9e4da641","modified":1527347826864},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/supports-color/readme.md","hash":"90d71263768deafa581e770a71913323c0c52ab4","modified":1521908559000},{"_id":"themes/archer/node_modules/image-optimizer-cli/lib/processor/jpg.js","hash":"56ee9935962848fced3472c5aa1137db3f1c503b","modified":1519761958000},{"_id":"themes/archer/node_modules/image-optimizer-cli/lib/processor/png.js","hash":"d16cbac68ff2c9e875e93336e2b6b2f394003c11","modified":1526554795000},{"_id":"themes/archer/src/scss/_partial/_partial/_paginator.scss","hash":"ad14edda32d4e3f05819eda783db321402d37356","modified":1527347826868},{"_id":"themes/archer/src/scss/_partial/_partial/_intro.scss","hash":"61ab9f1c187b0c0795935ac3769c202c4dd86aea","modified":1527782528281},{"_id":"themes/archer/src/scss/_partial/_partial/_profile.scss","hash":"e88fa63587af0ee490591ff5e8953c8e875dcfd6","modified":1527347826870},{"_id":"themes/archer/src/scss/_partial/_partial/_header.scss","hash":"f166c2ba859f2ce76e7ade441c83cbc81bdf184e","modified":1527347826866},{"_id":"themes/archer/src/scss/_partial/_post/_code.scss","hash":"5510884dd3b02190d6daf63dc4ac516c12e26216","modified":1527347826875},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-archive.scss","hash":"93cd6d629472a409199ebe432380261ab0973dca","modified":1527347826877},{"_id":"themes/archer/src/scss/_partial/_partial/_scrollbar.scss","hash":"eabe9fd56908ce595eedc90bb211412aba5d433c","modified":1527347826871},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-tags.scss","hash":"ff4e9e3f2eaeb7eb3071a666cdfa61eabad92e3c","modified":1527347826879},{"_id":"themes/archer/source/intro/index-bg3.jpg","hash":"97a510b00e0a61aa7920fa76f45221f1eaa2ba74","modified":1527902746524},{"_id":"themes/archer/source/intro/about-bg.jpg","hash":"2d491b373e62a8dcb694465886dc5d4ba5ce2606","modified":1527902745841},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar.scss","hash":"90617295ae34d29d69b0b336454963ac0adb30db","modified":1527347826880},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/supports-color/index.js","hash":"ed3ccfe90c1b541595bf1d105a86ae709e5b98f9","modified":1523937426000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/has-flag/readme.md","hash":"99207d2675befe9c32c412112fc038e9fe14d9cf","modified":1514920679000},{"_id":"themes/archer/.git/logs/refs/heads/master","hash":"660f2e170b0bf28d69a7bbd559234c04f2495983","modified":1527347826716},{"_id":"themes/archer/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1527347826702},{"_id":"source/_posts/2017-08-05-yangshuoyouji/6.JPG","hash":"b2c3dcd700b40c22fc141d4d62d9dfaa96d773f5","modified":1503105890406},{"_id":"source/_posts/2017-08-20-xiamen/15.JPG","hash":"5b3f18bf9f3cc5cc7d66357fd054c30ec1a1e975","modified":1503232557534},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/minimist/example/parse.js","hash":"7684d952ceaa32a8c9e3cd21ba26a62e7ee14387","modified":1438902274000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/minimist/test/all_bool.js","hash":"d5f1721995050d6d9de35c56222e578d6a2a8b5e","modified":1438902274000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/minimist/test/bool.js","hash":"a0ef26a085e4d5530ea59880049cf7aeeaf9bead","modified":1438902415000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/minimist/test/dotted.js","hash":"edbda6ea34cff9e7dc3fe1953b72eca2f955cda9","modified":1438902274000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/chalk/types/index.d.ts","hash":"0030b5543edf909cd27d406622f7b63717904c0f","modified":1508818015000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/minimist/test/kv_short.js","hash":"e87208f3f2695b7de0c27e234bc4810cd6d49b8e","modified":1440424577000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/minimist/test/default_bool.js","hash":"71da47b49e90b77c88caccb077c1bcfb555399f1","modified":1438902274000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/minimist/test/long.js","hash":"f0ccd5d55358f78efbc928753264e4a32f7724fc","modified":1438902274000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/minimist/test/dash.js","hash":"0fe20783b683b525cb3ff6872474ac6fd89a8b63","modified":1438902274000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/minimist/test/parse_modified.js","hash":"310215056f588e8c04e92f0cf6337ca28a8e0d78","modified":1438902274000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/minimist/test/parse.js","hash":"a9672d89e1623b05aed85a4b4afcfec7fbaa359c","modified":1438902274000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/minimist/test/num.js","hash":"6a52983a855113284f2aa9633876c1adf3710463","modified":1438902274000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/minimist/test/stop_early.js","hash":"dc728f383a53ce9e44c9c1c21360bb7ad71d6205","modified":1438902274000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/minimist/test/whitespace.js","hash":"ea3a87137fa34c00a7d84a4d0350770e8d85ed9c","modified":1438902274000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/minimist/test/unknown.js","hash":"b55d1e1d6ff269730e4578a108f4c340e70da262","modified":1438902274000},{"_id":"themes/archer/node_modules/image-optimizer-cli/node_modules/minimist/test/short.js","hash":"2ce00fdfe4906fc504286974c143c4ced6a11b12","modified":1438902274000},{"_id":"themes/archer/.git/logs/refs/remotes/origin/HEAD","hash":"660f2e170b0bf28d69a7bbd559234c04f2495983","modified":1527347826709},{"_id":"themes/archer/source/intro/index-bg2.jpg","hash":"e300f64b4fcba7b0c3398e9473c7c2c9e2b188ae","modified":1527902746406},{"_id":"source/apps/dear/Love-Music.mp3","hash":"631fbec49a4ab399c9fb6e8f1ed1ae59575a94ff","modified":1462294368381},{"_id":"themes/archer/.git/objects/pack/pack-0de2d99d83161293ccff94414bbf8129b2f0f8fa.pack","hash":"32495298fe902a512b1e4e7c3471fc081260a6d8","modified":1527347826483}],"Category":[{"name":"js原理","_id":"cjjoevoen00030gupnpliubud"},{"name":"基础知识","_id":"cjjoevof100070gup2582yfkk"},{"name":"CSS样式","_id":"cjjoevofw000l0gup5l2ggzew"},{"name":"闲暇游记","_id":"cjjoevoh1000u0guptmvt9ibd"},{"name":"实战应用","_id":"cjjoevohb00110gupxa8tngxv"}],"Data":[],"Page":[{"title":"about","date":"2018-05-27T01:02:36.000Z","_content":"\n> 浪荡一生，只爱一人\n\n主人公：小明&小艺\n\n年代：90后的初生代\n\n# 那些年我们的记忆：\n\n我们无法改变时间，却能让时间变得更有意义。岁月悠悠，天地辽阔，我们的旅行还在继续，此生我要做你的守护者和记录者~\n\n**下面节选精彩片段**\n\n2014.08.30  我们于千万人当中，相识了，就像：转角处，你就在那\n\n2015.09.12  我们一起去了长隆动物园，穿越了两次亚非大陆，看了大笨象、杂技表演\n\n2015.06.20  我们相约去了一趟3天的丹霞山，一个美丽、清新、难忘的地方\n\n2015.10.17  听说那里的时间很慢，我们直飞了两天厦门鼓浪屿\n\n2015.12.09  跟一个不知道自己什么时候过生日的么么哒过了第一次生日\n\n2016.01.31  去了广州海洋馆溜达溜达\n\n2016.03.20  我们一起搬进了小黑屋\n\n2016.03.12  植树节，海珠湖逛逛\n\n2016.04.02  惠州黑排角走了一圈\n\n2016.04.09  简蓬水乡找吃的\n\n2016.05.14  听说澳门有大牌坊、有美食，就过去了\n\n2016.07.07  珠海长隆企鹅酒店+海洋王国+大马戏\n\n2017.06.17  跟么么哒一家人二刷广州长隆动物园+马戏\n\n2017-08-05  桂林阳朔休闲两日游\n\n2017-10-01  么么哒呕心沥血，塞了一天肥到了我家\n\n2017.11.16  十分重要和敬业的一天，我们领证啦~然后去上班了\n\n2017.11.18  广州灯光节喵喵\n\n2017.12.02  幸福誉，下定了我们的小窝，期待着···\n\n2018.02.19  香港飞冲绳6天，小学生英语闯世界，难忘那美丽的海岛\n\n未完待续···\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-05-27 09:02:36\n---\n\n> 浪荡一生，只爱一人\n\n主人公：小明&小艺\n\n年代：90后的初生代\n\n# 那些年我们的记忆：\n\n我们无法改变时间，却能让时间变得更有意义。岁月悠悠，天地辽阔，我们的旅行还在继续，此生我要做你的守护者和记录者~\n\n**下面节选精彩片段**\n\n2014.08.30  我们于千万人当中，相识了，就像：转角处，你就在那\n\n2015.09.12  我们一起去了长隆动物园，穿越了两次亚非大陆，看了大笨象、杂技表演\n\n2015.06.20  我们相约去了一趟3天的丹霞山，一个美丽、清新、难忘的地方\n\n2015.10.17  听说那里的时间很慢，我们直飞了两天厦门鼓浪屿\n\n2015.12.09  跟一个不知道自己什么时候过生日的么么哒过了第一次生日\n\n2016.01.31  去了广州海洋馆溜达溜达\n\n2016.03.20  我们一起搬进了小黑屋\n\n2016.03.12  植树节，海珠湖逛逛\n\n2016.04.02  惠州黑排角走了一圈\n\n2016.04.09  简蓬水乡找吃的\n\n2016.05.14  听说澳门有大牌坊、有美食，就过去了\n\n2016.07.07  珠海长隆企鹅酒店+海洋王国+大马戏\n\n2017.06.17  跟么么哒一家人二刷广州长隆动物园+马戏\n\n2017-08-05  桂林阳朔休闲两日游\n\n2017-10-01  么么哒呕心沥血，塞了一天肥到了我家\n\n2017.11.16  十分重要和敬业的一天，我们领证啦~然后去上班了\n\n2017.11.18  广州灯光节喵喵\n\n2017.12.02  幸福誉，下定了我们的小窝，期待着···\n\n2018.02.19  香港飞冲绳6天，小学生英语闯世界，难忘那美丽的海岛\n\n未完待续···\n","updated":"2018-05-27T02:29:14.082Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjjoevoe400000gupfg3u4xn7","content":"<blockquote>\n<p>浪荡一生，只爱一人</p>\n</blockquote>\n<p>主人公：小明&amp;小艺</p>\n<p>年代：90后的初生代</p>\n<h1 id=\"那些年我们的记忆：\"><a href=\"#那些年我们的记忆：\" class=\"headerlink\" title=\"那些年我们的记忆：\"></a>那些年我们的记忆：</h1><p>我们无法改变时间，却能让时间变得更有意义。岁月悠悠，天地辽阔，我们的旅行还在继续，此生我要做你的守护者和记录者~</p>\n<p><strong>下面节选精彩片段</strong></p>\n<p>2014.08.30  我们于千万人当中，相识了，就像：转角处，你就在那</p>\n<p>2015.09.12  我们一起去了长隆动物园，穿越了两次亚非大陆，看了大笨象、杂技表演</p>\n<p>2015.06.20  我们相约去了一趟3天的丹霞山，一个美丽、清新、难忘的地方</p>\n<p>2015.10.17  听说那里的时间很慢，我们直飞了两天厦门鼓浪屿</p>\n<p>2015.12.09  跟一个不知道自己什么时候过生日的么么哒过了第一次生日</p>\n<p>2016.01.31  去了广州海洋馆溜达溜达</p>\n<p>2016.03.20  我们一起搬进了小黑屋</p>\n<p>2016.03.12  植树节，海珠湖逛逛</p>\n<p>2016.04.02  惠州黑排角走了一圈</p>\n<p>2016.04.09  简蓬水乡找吃的</p>\n<p>2016.05.14  听说澳门有大牌坊、有美食，就过去了</p>\n<p>2016.07.07  珠海长隆企鹅酒店+海洋王国+大马戏</p>\n<p>2017.06.17  跟么么哒一家人二刷广州长隆动物园+马戏</p>\n<p>2017-08-05  桂林阳朔休闲两日游</p>\n<p>2017-10-01  么么哒呕心沥血，塞了一天肥到了我家</p>\n<p>2017.11.16  十分重要和敬业的一天，我们领证啦~然后去上班了</p>\n<p>2017.11.18  广州灯光节喵喵</p>\n<p>2017.12.02  幸福誉，下定了我们的小窝，期待着···</p>\n<p>2018.02.19  香港飞冲绳6天，小学生英语闯世界，难忘那美丽的海岛</p>\n<p>未完待续···</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>浪荡一生，只爱一人</p>\n</blockquote>\n<p>主人公：小明&amp;小艺</p>\n<p>年代：90后的初生代</p>\n<h1 id=\"那些年我们的记忆：\"><a href=\"#那些年我们的记忆：\" class=\"headerlink\" title=\"那些年我们的记忆：\"></a>那些年我们的记忆：</h1><p>我们无法改变时间，却能让时间变得更有意义。岁月悠悠，天地辽阔，我们的旅行还在继续，此生我要做你的守护者和记录者~</p>\n<p><strong>下面节选精彩片段</strong></p>\n<p>2014.08.30  我们于千万人当中，相识了，就像：转角处，你就在那</p>\n<p>2015.09.12  我们一起去了长隆动物园，穿越了两次亚非大陆，看了大笨象、杂技表演</p>\n<p>2015.06.20  我们相约去了一趟3天的丹霞山，一个美丽、清新、难忘的地方</p>\n<p>2015.10.17  听说那里的时间很慢，我们直飞了两天厦门鼓浪屿</p>\n<p>2015.12.09  跟一个不知道自己什么时候过生日的么么哒过了第一次生日</p>\n<p>2016.01.31  去了广州海洋馆溜达溜达</p>\n<p>2016.03.20  我们一起搬进了小黑屋</p>\n<p>2016.03.12  植树节，海珠湖逛逛</p>\n<p>2016.04.02  惠州黑排角走了一圈</p>\n<p>2016.04.09  简蓬水乡找吃的</p>\n<p>2016.05.14  听说澳门有大牌坊、有美食，就过去了</p>\n<p>2016.07.07  珠海长隆企鹅酒店+海洋王国+大马戏</p>\n<p>2017.06.17  跟么么哒一家人二刷广州长隆动物园+马戏</p>\n<p>2017-08-05  桂林阳朔休闲两日游</p>\n<p>2017-10-01  么么哒呕心沥血，塞了一天肥到了我家</p>\n<p>2017.11.16  十分重要和敬业的一天，我们领证啦~然后去上班了</p>\n<p>2017.11.18  广州灯光节喵喵</p>\n<p>2017.12.02  幸福誉，下定了我们的小窝，期待着···</p>\n<p>2018.02.19  香港飞冲绳6天，小学生英语闯世界，难忘那美丽的海岛</p>\n<p>未完待续···</p>\n"}],"Post":[{"layout":"post","title":"javascript的继承","date":"2015-09-12T11:23:19.000Z","_content":"\n### 继承的基础\n\nBrendan Eich在设计js语言时，面向对象编程正值兴盛之期，而定位为简易脚本语言的js需不需要兼顾面向对象的功能呢？Brendan Eich的答案是肯定的。但是js里面，函数、Object、Array等一切都是对象，也没有Class的类概念。那得用什么机制让对象联系起来呢？Brendan Eich想到了构造函数，通过new直接接一个构造函数来生成一个实例，也就是把类的概念和function糅合在一起，但是简单的构造函数与类的区别是无法共享属性和方法，function内部的都是实例new出来的对象特有的属性或方法。考虑到这一点，Brendan Eich给每个函数添加了prototype的属性，作为new出来的实例的公共属性或者方法。于是乎，在new出来的实例里都会有一个引用指向其构造函数的prototype对象。\n\n```\nvar Man = function(name){\n    this.name = name;\n}\nMan.prototype.say = function(){\n    console.log(\"my name is \" + this.name);\n}\nvar manA = new Man(\"A\");\nvar manB = new Man(\"B\");\n```\n\n这里的say方法在内存中只有一份，manA和manB都引用了该方法。实际上，在new的时候执行了以下几步：\n\n1. 创建一个新的空对象，这个对象的类型是object；\n2. 设置对象的构造函数（prototype.construtor所指向的构造函数），以及一些基础属性；\n3. 执行构造函数，当this关键字被提及的时候，使用新创建的对象的属性；\n4. 返回新创建的对象；\n\n由于每个实例都保存了构造函数的prototype，而且prototype里有每个实例的公共方法或者属性，那如果构造函数里自定义了一些属性与prototype里的重名了（js里函数名是唯一的标识，形参不作为函数的标识），那怎么办？js里是以实例的属性优先，找不到的时候再去prototype里面查找，并会沿着prototype的链条查找；\n\n### 继承的方式\n\n继承是为了达到子承父业的效果，可以对一个对象拓展，得到一个功能更加强大的新对象。那js里可以如何实现这种效果呢？\n\n**方式一** \n\n在执行构造函数的时候，直接绑定子与父的关系，即通过call或者apply在子类的构造函数里，用子类的上下文执行以下父类的方法，从而把父类的属性绑定到子类，实现继承。\n```\nvar Man = function(name){\n    this.name = name;\n}\nvar ChildMan = function(name){\n    Man.apply(this, arguments);\n    this.age = 12;\n}\nvar manA = new ChildMan(\"A\");\n```\n\n这里的不足之处是：子类的实例里，每一个都拥有了一份独立的属性，并没有共享，只是形式上的继承，同源不同宗。\n\n**方式二** \n\n利用原型链的上溯特性实现继承，把父类的prototype赋值给子类的prototype。这里就可以灵活实现了\n- 如果不介意修改父类会影响子类，可以直接把ChildMan.prototype = Man.prototype；\n- 否则需要用把父对象的实例赋值给子类的prototype，即ChildMan.prototype = new Man()；\n- 再则，不想执行父类构造函数，可以先利用一个空的构造函数来实例化一个Man，如下\n```\nvar F = function(){};\nF.prototype = Man.prototype;\nChildMan.prototype = new F();\n```\n\n方式很多，原理都是拿到父类的prototype，但是上面的方法都需要注意子类的构造函数，修改了子类的prototype之后，其构造函数也会跟着改变，这时候还需要改回来，加上ChildMan.prototype.constructor = ChildMan；为什么一定要加上？因为当调用instanceOf的时候，会通过对象的构造函数来区分。\n\n\n> 继承的方式各种各样，没有最好的，只有最适合的。如果是一个单例模式的对象，根本就不用考虑是否会影响到父类；但是如果对象会有很多实例的，则完全不同。所以，选择最合适的，才是最好的。\n","source":"_posts/2015-09-12-js-base-extend.markdown","raw":"---\nlayout: post\ntitle:  \"javascript的继承\"\ndate:   2015-09-12 19:23:19\ncategories: \"js原理\"\n---\n\n### 继承的基础\n\nBrendan Eich在设计js语言时，面向对象编程正值兴盛之期，而定位为简易脚本语言的js需不需要兼顾面向对象的功能呢？Brendan Eich的答案是肯定的。但是js里面，函数、Object、Array等一切都是对象，也没有Class的类概念。那得用什么机制让对象联系起来呢？Brendan Eich想到了构造函数，通过new直接接一个构造函数来生成一个实例，也就是把类的概念和function糅合在一起，但是简单的构造函数与类的区别是无法共享属性和方法，function内部的都是实例new出来的对象特有的属性或方法。考虑到这一点，Brendan Eich给每个函数添加了prototype的属性，作为new出来的实例的公共属性或者方法。于是乎，在new出来的实例里都会有一个引用指向其构造函数的prototype对象。\n\n```\nvar Man = function(name){\n    this.name = name;\n}\nMan.prototype.say = function(){\n    console.log(\"my name is \" + this.name);\n}\nvar manA = new Man(\"A\");\nvar manB = new Man(\"B\");\n```\n\n这里的say方法在内存中只有一份，manA和manB都引用了该方法。实际上，在new的时候执行了以下几步：\n\n1. 创建一个新的空对象，这个对象的类型是object；\n2. 设置对象的构造函数（prototype.construtor所指向的构造函数），以及一些基础属性；\n3. 执行构造函数，当this关键字被提及的时候，使用新创建的对象的属性；\n4. 返回新创建的对象；\n\n由于每个实例都保存了构造函数的prototype，而且prototype里有每个实例的公共方法或者属性，那如果构造函数里自定义了一些属性与prototype里的重名了（js里函数名是唯一的标识，形参不作为函数的标识），那怎么办？js里是以实例的属性优先，找不到的时候再去prototype里面查找，并会沿着prototype的链条查找；\n\n### 继承的方式\n\n继承是为了达到子承父业的效果，可以对一个对象拓展，得到一个功能更加强大的新对象。那js里可以如何实现这种效果呢？\n\n**方式一** \n\n在执行构造函数的时候，直接绑定子与父的关系，即通过call或者apply在子类的构造函数里，用子类的上下文执行以下父类的方法，从而把父类的属性绑定到子类，实现继承。\n```\nvar Man = function(name){\n    this.name = name;\n}\nvar ChildMan = function(name){\n    Man.apply(this, arguments);\n    this.age = 12;\n}\nvar manA = new ChildMan(\"A\");\n```\n\n这里的不足之处是：子类的实例里，每一个都拥有了一份独立的属性，并没有共享，只是形式上的继承，同源不同宗。\n\n**方式二** \n\n利用原型链的上溯特性实现继承，把父类的prototype赋值给子类的prototype。这里就可以灵活实现了\n- 如果不介意修改父类会影响子类，可以直接把ChildMan.prototype = Man.prototype；\n- 否则需要用把父对象的实例赋值给子类的prototype，即ChildMan.prototype = new Man()；\n- 再则，不想执行父类构造函数，可以先利用一个空的构造函数来实例化一个Man，如下\n```\nvar F = function(){};\nF.prototype = Man.prototype;\nChildMan.prototype = new F();\n```\n\n方式很多，原理都是拿到父类的prototype，但是上面的方法都需要注意子类的构造函数，修改了子类的prototype之后，其构造函数也会跟着改变，这时候还需要改回来，加上ChildMan.prototype.constructor = ChildMan；为什么一定要加上？因为当调用instanceOf的时候，会通过对象的构造函数来区分。\n\n\n> 继承的方式各种各样，没有最好的，只有最适合的。如果是一个单例模式的对象，根本就不用考虑是否会影响到父类；但是如果对象会有很多实例的，则完全不同。所以，选择最合适的，才是最好的。\n","slug":"2015-09-12-js-base-extend","published":1,"updated":"2018-05-26T16:02:28.275Z","comments":1,"photos":[],"link":"","_id":"cjjoevoe800010gupy410wsqp","content":"<h3 id=\"继承的基础\"><a href=\"#继承的基础\" class=\"headerlink\" title=\"继承的基础\"></a>继承的基础</h3><p>Brendan Eich在设计js语言时，面向对象编程正值兴盛之期，而定位为简易脚本语言的js需不需要兼顾面向对象的功能呢？Brendan Eich的答案是肯定的。但是js里面，函数、Object、Array等一切都是对象，也没有Class的类概念。那得用什么机制让对象联系起来呢？Brendan Eich想到了构造函数，通过new直接接一个构造函数来生成一个实例，也就是把类的概念和function糅合在一起，但是简单的构造函数与类的区别是无法共享属性和方法，function内部的都是实例new出来的对象特有的属性或方法。考虑到这一点，Brendan Eich给每个函数添加了prototype的属性，作为new出来的实例的公共属性或者方法。于是乎，在new出来的实例里都会有一个引用指向其构造函数的prototype对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Man = function(name)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Man.prototype.say = function()&#123;</span><br><span class=\"line\">    console.log(&quot;my name is &quot; + this.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var manA = new Man(&quot;A&quot;);</span><br><span class=\"line\">var manB = new Man(&quot;B&quot;);</span><br></pre></td></tr></table></figure>\n<p>这里的say方法在内存中只有一份，manA和manB都引用了该方法。实际上，在new的时候执行了以下几步：</p>\n<ol>\n<li>创建一个新的空对象，这个对象的类型是object；</li>\n<li>设置对象的构造函数（prototype.construtor所指向的构造函数），以及一些基础属性；</li>\n<li>执行构造函数，当this关键字被提及的时候，使用新创建的对象的属性；</li>\n<li>返回新创建的对象；</li>\n</ol>\n<p>由于每个实例都保存了构造函数的prototype，而且prototype里有每个实例的公共方法或者属性，那如果构造函数里自定义了一些属性与prototype里的重名了（js里函数名是唯一的标识，形参不作为函数的标识），那怎么办？js里是以实例的属性优先，找不到的时候再去prototype里面查找，并会沿着prototype的链条查找；</p>\n<h3 id=\"继承的方式\"><a href=\"#继承的方式\" class=\"headerlink\" title=\"继承的方式\"></a>继承的方式</h3><p>继承是为了达到子承父业的效果，可以对一个对象拓展，得到一个功能更加强大的新对象。那js里可以如何实现这种效果呢？</p>\n<p><strong>方式一</strong> </p>\n<p>在执行构造函数的时候，直接绑定子与父的关系，即通过call或者apply在子类的构造函数里，用子类的上下文执行以下父类的方法，从而把父类的属性绑定到子类，实现继承。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Man = function(name)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var ChildMan = function(name)&#123;</span><br><span class=\"line\">    Man.apply(this, arguments);</span><br><span class=\"line\">    this.age = 12;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var manA = new ChildMan(&quot;A&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>这里的不足之处是：子类的实例里，每一个都拥有了一份独立的属性，并没有共享，只是形式上的继承，同源不同宗。</p>\n<p><strong>方式二</strong> </p>\n<p>利用原型链的上溯特性实现继承，把父类的prototype赋值给子类的prototype。这里就可以灵活实现了</p>\n<ul>\n<li>如果不介意修改父类会影响子类，可以直接把ChildMan.prototype = Man.prototype；</li>\n<li>否则需要用把父对象的实例赋值给子类的prototype，即ChildMan.prototype = new Man()；</li>\n<li>再则，不想执行父类构造函数，可以先利用一个空的构造函数来实例化一个Man，如下<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var F = function()&#123;&#125;;</span><br><span class=\"line\">F.prototype = Man.prototype;</span><br><span class=\"line\">ChildMan.prototype = new F();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>方式很多，原理都是拿到父类的prototype，但是上面的方法都需要注意子类的构造函数，修改了子类的prototype之后，其构造函数也会跟着改变，这时候还需要改回来，加上ChildMan.prototype.constructor = ChildMan；为什么一定要加上？因为当调用instanceOf的时候，会通过对象的构造函数来区分。</p>\n<blockquote>\n<p>继承的方式各种各样，没有最好的，只有最适合的。如果是一个单例模式的对象，根本就不用考虑是否会影响到父类；但是如果对象会有很多实例的，则完全不同。所以，选择最合适的，才是最好的。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"继承的基础\"><a href=\"#继承的基础\" class=\"headerlink\" title=\"继承的基础\"></a>继承的基础</h3><p>Brendan Eich在设计js语言时，面向对象编程正值兴盛之期，而定位为简易脚本语言的js需不需要兼顾面向对象的功能呢？Brendan Eich的答案是肯定的。但是js里面，函数、Object、Array等一切都是对象，也没有Class的类概念。那得用什么机制让对象联系起来呢？Brendan Eich想到了构造函数，通过new直接接一个构造函数来生成一个实例，也就是把类的概念和function糅合在一起，但是简单的构造函数与类的区别是无法共享属性和方法，function内部的都是实例new出来的对象特有的属性或方法。考虑到这一点，Brendan Eich给每个函数添加了prototype的属性，作为new出来的实例的公共属性或者方法。于是乎，在new出来的实例里都会有一个引用指向其构造函数的prototype对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Man = function(name)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Man.prototype.say = function()&#123;</span><br><span class=\"line\">    console.log(&quot;my name is &quot; + this.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var manA = new Man(&quot;A&quot;);</span><br><span class=\"line\">var manB = new Man(&quot;B&quot;);</span><br></pre></td></tr></table></figure>\n<p>这里的say方法在内存中只有一份，manA和manB都引用了该方法。实际上，在new的时候执行了以下几步：</p>\n<ol>\n<li>创建一个新的空对象，这个对象的类型是object；</li>\n<li>设置对象的构造函数（prototype.construtor所指向的构造函数），以及一些基础属性；</li>\n<li>执行构造函数，当this关键字被提及的时候，使用新创建的对象的属性；</li>\n<li>返回新创建的对象；</li>\n</ol>\n<p>由于每个实例都保存了构造函数的prototype，而且prototype里有每个实例的公共方法或者属性，那如果构造函数里自定义了一些属性与prototype里的重名了（js里函数名是唯一的标识，形参不作为函数的标识），那怎么办？js里是以实例的属性优先，找不到的时候再去prototype里面查找，并会沿着prototype的链条查找；</p>\n<h3 id=\"继承的方式\"><a href=\"#继承的方式\" class=\"headerlink\" title=\"继承的方式\"></a>继承的方式</h3><p>继承是为了达到子承父业的效果，可以对一个对象拓展，得到一个功能更加强大的新对象。那js里可以如何实现这种效果呢？</p>\n<p><strong>方式一</strong> </p>\n<p>在执行构造函数的时候，直接绑定子与父的关系，即通过call或者apply在子类的构造函数里，用子类的上下文执行以下父类的方法，从而把父类的属性绑定到子类，实现继承。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Man = function(name)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var ChildMan = function(name)&#123;</span><br><span class=\"line\">    Man.apply(this, arguments);</span><br><span class=\"line\">    this.age = 12;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var manA = new ChildMan(&quot;A&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>这里的不足之处是：子类的实例里，每一个都拥有了一份独立的属性，并没有共享，只是形式上的继承，同源不同宗。</p>\n<p><strong>方式二</strong> </p>\n<p>利用原型链的上溯特性实现继承，把父类的prototype赋值给子类的prototype。这里就可以灵活实现了</p>\n<ul>\n<li>如果不介意修改父类会影响子类，可以直接把ChildMan.prototype = Man.prototype；</li>\n<li>否则需要用把父对象的实例赋值给子类的prototype，即ChildMan.prototype = new Man()；</li>\n<li>再则，不想执行父类构造函数，可以先利用一个空的构造函数来实例化一个Man，如下<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var F = function()&#123;&#125;;</span><br><span class=\"line\">F.prototype = Man.prototype;</span><br><span class=\"line\">ChildMan.prototype = new F();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>方式很多，原理都是拿到父类的prototype，但是上面的方法都需要注意子类的构造函数，修改了子类的prototype之后，其构造函数也会跟着改变，这时候还需要改回来，加上ChildMan.prototype.constructor = ChildMan；为什么一定要加上？因为当调用instanceOf的时候，会通过对象的构造函数来区分。</p>\n<blockquote>\n<p>继承的方式各种各样，没有最好的，只有最适合的。如果是一个单例模式的对象，根本就不用考虑是否会影响到父类；但是如果对象会有很多实例的，则完全不同。所以，选择最合适的，才是最好的。</p>\n</blockquote>\n"},{"layout":"post","title":"Backbone总结","date":"2015-10-10T13:50:12.000Z","_content":"\n### 为什么选择Backbone\n\n项目之初，需要选择一个框架作为底层开发，当时想到的是angular、backbone、vue，其都是MV*的开发方式。而我考虑的几点是\n1. 学习成本低，可以快速上手\n2. 框架的利用率和总体体积\n3. 框架的更新周期\n4. 框架的讨论热度\n兼顾这几方面，选择了Backbone。Backbone的视图功能是比较单一和广泛的，可以随意使用，没有太多的条条框框。但是不足的是Collection和Model的功能跟View不匹配，View对于Collection和Model而言显得有点功能单薄。\n\n### Backbone\n\nBackbone的视图创建很简单，只是创建了几个公共的方法和提供一些事件监听和发布的发放，其自身不具备模板功能，和视图与Model的绑定功能，很多事情还是需要自己在程序里编写。\n\nBackbone的Router可以实现前端的路由，而且还具备了pushState实现无刷新跳转，不过这样子需要取消所有的跳转。Router的不足是不能创建多个子的Router配置，所有的配置都扔到一个地方，也是挺难维护的。另外Router还无法监听匹配不上的事件，后来在源码里发现它找不到匹配的路由时直接跳过了，什么都没有做，所以需要监听的话，可以重写它的loadurl方法。\n\n```\nBackbone.history.loadUrl = function(fragment) {\n    fragment = this.fragment = this.getFragment(fragment);\n    var result =  _.any(this.handlers, function(handler) {\n      if (handler.route.test(fragment)) {\n        handler.callback(fragment);\n        return true;\n      }\n    });\n    if(result == false){\n      Backbone.history.trigger(\"router:nomatch\", fragment);\n    }\n    return result;\n  }\n```\n\nBackbone的Model和Collection支持ResetApi，不过在项目中没怎么用，因为接口也不是resetApi风格的，基本都是自己写后端的数据请求。\n\nBackbone在使用的时候需要注意视图的划分，划分得太细需要写太多的代码，但是耦合太多，则后期可能不好维护，需要一些经验做基础，预测一下可变的部分。","source":"_posts/2015-10-10-backbone.markdown","raw":"---\nlayout: post\ntitle:  \"Backbone总结\"\ndate:   2015-10-10 21:50:12\ncategories: \"基础知识\"\n---\n\n### 为什么选择Backbone\n\n项目之初，需要选择一个框架作为底层开发，当时想到的是angular、backbone、vue，其都是MV*的开发方式。而我考虑的几点是\n1. 学习成本低，可以快速上手\n2. 框架的利用率和总体体积\n3. 框架的更新周期\n4. 框架的讨论热度\n兼顾这几方面，选择了Backbone。Backbone的视图功能是比较单一和广泛的，可以随意使用，没有太多的条条框框。但是不足的是Collection和Model的功能跟View不匹配，View对于Collection和Model而言显得有点功能单薄。\n\n### Backbone\n\nBackbone的视图创建很简单，只是创建了几个公共的方法和提供一些事件监听和发布的发放，其自身不具备模板功能，和视图与Model的绑定功能，很多事情还是需要自己在程序里编写。\n\nBackbone的Router可以实现前端的路由，而且还具备了pushState实现无刷新跳转，不过这样子需要取消所有的跳转。Router的不足是不能创建多个子的Router配置，所有的配置都扔到一个地方，也是挺难维护的。另外Router还无法监听匹配不上的事件，后来在源码里发现它找不到匹配的路由时直接跳过了，什么都没有做，所以需要监听的话，可以重写它的loadurl方法。\n\n```\nBackbone.history.loadUrl = function(fragment) {\n    fragment = this.fragment = this.getFragment(fragment);\n    var result =  _.any(this.handlers, function(handler) {\n      if (handler.route.test(fragment)) {\n        handler.callback(fragment);\n        return true;\n      }\n    });\n    if(result == false){\n      Backbone.history.trigger(\"router:nomatch\", fragment);\n    }\n    return result;\n  }\n```\n\nBackbone的Model和Collection支持ResetApi，不过在项目中没怎么用，因为接口也不是resetApi风格的，基本都是自己写后端的数据请求。\n\nBackbone在使用的时候需要注意视图的划分，划分得太细需要写太多的代码，但是耦合太多，则后期可能不好维护，需要一些经验做基础，预测一下可变的部分。","slug":"2015-10-10-backbone","published":1,"updated":"2018-05-26T16:02:28.400Z","comments":1,"photos":[],"link":"","_id":"cjjoevoei00020gupbz9jq4u9","content":"<h3 id=\"为什么选择Backbone\"><a href=\"#为什么选择Backbone\" class=\"headerlink\" title=\"为什么选择Backbone\"></a>为什么选择Backbone</h3><p>项目之初，需要选择一个框架作为底层开发，当时想到的是angular、backbone、vue，其都是MV*的开发方式。而我考虑的几点是</p>\n<ol>\n<li>学习成本低，可以快速上手</li>\n<li>框架的利用率和总体体积</li>\n<li>框架的更新周期</li>\n<li>框架的讨论热度<br>兼顾这几方面，选择了Backbone。Backbone的视图功能是比较单一和广泛的，可以随意使用，没有太多的条条框框。但是不足的是Collection和Model的功能跟View不匹配，View对于Collection和Model而言显得有点功能单薄。</li>\n</ol>\n<h3 id=\"Backbone\"><a href=\"#Backbone\" class=\"headerlink\" title=\"Backbone\"></a>Backbone</h3><p>Backbone的视图创建很简单，只是创建了几个公共的方法和提供一些事件监听和发布的发放，其自身不具备模板功能，和视图与Model的绑定功能，很多事情还是需要自己在程序里编写。</p>\n<p>Backbone的Router可以实现前端的路由，而且还具备了pushState实现无刷新跳转，不过这样子需要取消所有的跳转。Router的不足是不能创建多个子的Router配置，所有的配置都扔到一个地方，也是挺难维护的。另外Router还无法监听匹配不上的事件，后来在源码里发现它找不到匹配的路由时直接跳过了，什么都没有做，所以需要监听的话，可以重写它的loadurl方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Backbone.history.loadUrl = function(fragment) &#123;</span><br><span class=\"line\">    fragment = this.fragment = this.getFragment(fragment);</span><br><span class=\"line\">    var result =  _.any(this.handlers, function(handler) &#123;</span><br><span class=\"line\">      if (handler.route.test(fragment)) &#123;</span><br><span class=\"line\">        handler.callback(fragment);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    if(result == false)&#123;</span><br><span class=\"line\">      Backbone.history.trigger(&quot;router:nomatch&quot;, fragment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>Backbone的Model和Collection支持ResetApi，不过在项目中没怎么用，因为接口也不是resetApi风格的，基本都是自己写后端的数据请求。</p>\n<p>Backbone在使用的时候需要注意视图的划分，划分得太细需要写太多的代码，但是耦合太多，则后期可能不好维护，需要一些经验做基础，预测一下可变的部分。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"为什么选择Backbone\"><a href=\"#为什么选择Backbone\" class=\"headerlink\" title=\"为什么选择Backbone\"></a>为什么选择Backbone</h3><p>项目之初，需要选择一个框架作为底层开发，当时想到的是angular、backbone、vue，其都是MV*的开发方式。而我考虑的几点是</p>\n<ol>\n<li>学习成本低，可以快速上手</li>\n<li>框架的利用率和总体体积</li>\n<li>框架的更新周期</li>\n<li>框架的讨论热度<br>兼顾这几方面，选择了Backbone。Backbone的视图功能是比较单一和广泛的，可以随意使用，没有太多的条条框框。但是不足的是Collection和Model的功能跟View不匹配，View对于Collection和Model而言显得有点功能单薄。</li>\n</ol>\n<h3 id=\"Backbone\"><a href=\"#Backbone\" class=\"headerlink\" title=\"Backbone\"></a>Backbone</h3><p>Backbone的视图创建很简单，只是创建了几个公共的方法和提供一些事件监听和发布的发放，其自身不具备模板功能，和视图与Model的绑定功能，很多事情还是需要自己在程序里编写。</p>\n<p>Backbone的Router可以实现前端的路由，而且还具备了pushState实现无刷新跳转，不过这样子需要取消所有的跳转。Router的不足是不能创建多个子的Router配置，所有的配置都扔到一个地方，也是挺难维护的。另外Router还无法监听匹配不上的事件，后来在源码里发现它找不到匹配的路由时直接跳过了，什么都没有做，所以需要监听的话，可以重写它的loadurl方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Backbone.history.loadUrl = function(fragment) &#123;</span><br><span class=\"line\">    fragment = this.fragment = this.getFragment(fragment);</span><br><span class=\"line\">    var result =  _.any(this.handlers, function(handler) &#123;</span><br><span class=\"line\">      if (handler.route.test(fragment)) &#123;</span><br><span class=\"line\">        handler.callback(fragment);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    if(result == false)&#123;</span><br><span class=\"line\">      Backbone.history.trigger(&quot;router:nomatch&quot;, fragment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>Backbone的Model和Collection支持ResetApi，不过在项目中没怎么用，因为接口也不是resetApi风格的，基本都是自己写后端的数据请求。</p>\n<p>Backbone在使用的时候需要注意视图的划分，划分得太细需要写太多的代码，但是耦合太多，则后期可能不好维护，需要一些经验做基础，预测一下可变的部分。</p>\n"},{"layout":"post","title":"影子(shadow)DOM","date":"2015-09-20T07:23:12.000Z","_content":"\nshadow dom是一种把类的概念迁移到html上的实践，主要是解决一个文档中可能需要大量交互的多个dom树的建立以及其各自的功能边界问题。目前只有少量浏览器支持，下面一起来了解webkit中的shadow dom。\n\n在代码编写过程中，我们常常会定义一个组件，把只关乎自身的东西内聚。例如：react的自定义组件、或者其他MV*框架中的组件。但这其实只是逻辑上的独立，再HTML中，它并没有独立开来，所有的节点也都是交由最顶级的HTML管理。对DOM树的遍历或者样式的选择，都会当来潜在的弊端。如果我们可以实现DOM树的封装和独立，使不同的DOM树之间可以相互独立，又可以独自渲染；那势必会使得组件化更加彻底。W3C工作组于是提出了影子DOM的概念，其使得一些DOM在特定范围内可见，而在网页的DOM树中不可见，但是渲染的结果中却包含了该节点。\n\nHTML5新支持的特性，例如视频、音频等也都是影子DOM的思想，或许有人会疑惑，既然它不可见，那在事件传播中如何处理？W3C规定，其目标会变为包含该影子DOM的节点对象。那如何创建一个影子DOM呢？如下所示：\n\n```\n<div id=\"div\"></div>\n<script>\nvar div = document.getElementById(\"div\"),\n    root = div.webkitCreateShadowRoot(),\n    shdowImg = document.createElement(\"img\"),\n    txtP = document.createElement(\"p\");\n    \nshdowImg.src = \"http://miniwa.com.cn/img/favicon.png\";\ntxtp.innerHTML = \"this is a test\";\n\nroot.appendChild(shdowImg);\nroot.appendChild(txtp);\n    \n</script>\n```\n\n","source":"_posts/2015-09-25-shadow-dom.markdown","raw":"---\nlayout: post\ntitle:  \"影子(shadow)DOM\"\ndate:   2015-09-20 15:23:12\ncategories: \"基础知识\"\n---\n\nshadow dom是一种把类的概念迁移到html上的实践，主要是解决一个文档中可能需要大量交互的多个dom树的建立以及其各自的功能边界问题。目前只有少量浏览器支持，下面一起来了解webkit中的shadow dom。\n\n在代码编写过程中，我们常常会定义一个组件，把只关乎自身的东西内聚。例如：react的自定义组件、或者其他MV*框架中的组件。但这其实只是逻辑上的独立，再HTML中，它并没有独立开来，所有的节点也都是交由最顶级的HTML管理。对DOM树的遍历或者样式的选择，都会当来潜在的弊端。如果我们可以实现DOM树的封装和独立，使不同的DOM树之间可以相互独立，又可以独自渲染；那势必会使得组件化更加彻底。W3C工作组于是提出了影子DOM的概念，其使得一些DOM在特定范围内可见，而在网页的DOM树中不可见，但是渲染的结果中却包含了该节点。\n\nHTML5新支持的特性，例如视频、音频等也都是影子DOM的思想，或许有人会疑惑，既然它不可见，那在事件传播中如何处理？W3C规定，其目标会变为包含该影子DOM的节点对象。那如何创建一个影子DOM呢？如下所示：\n\n```\n<div id=\"div\"></div>\n<script>\nvar div = document.getElementById(\"div\"),\n    root = div.webkitCreateShadowRoot(),\n    shdowImg = document.createElement(\"img\"),\n    txtP = document.createElement(\"p\");\n    \nshdowImg.src = \"http://miniwa.com.cn/img/favicon.png\";\ntxtp.innerHTML = \"this is a test\";\n\nroot.appendChild(shdowImg);\nroot.appendChild(txtp);\n    \n</script>\n```\n\n","slug":"2015-09-25-shadow-dom","published":1,"updated":"2018-05-26T16:03:05.725Z","comments":1,"photos":[],"link":"","_id":"cjjoevoeq00040gup3aktzvvd","content":"<p>shadow dom是一种把类的概念迁移到html上的实践，主要是解决一个文档中可能需要大量交互的多个dom树的建立以及其各自的功能边界问题。目前只有少量浏览器支持，下面一起来了解webkit中的shadow dom。</p>\n<p>在代码编写过程中，我们常常会定义一个组件，把只关乎自身的东西内聚。例如：react的自定义组件、或者其他MV*框架中的组件。但这其实只是逻辑上的独立，再HTML中，它并没有独立开来，所有的节点也都是交由最顶级的HTML管理。对DOM树的遍历或者样式的选择，都会当来潜在的弊端。如果我们可以实现DOM树的封装和独立，使不同的DOM树之间可以相互独立，又可以独自渲染；那势必会使得组件化更加彻底。W3C工作组于是提出了影子DOM的概念，其使得一些DOM在特定范围内可见，而在网页的DOM树中不可见，但是渲染的结果中却包含了该节点。</p>\n<p>HTML5新支持的特性，例如视频、音频等也都是影子DOM的思想，或许有人会疑惑，既然它不可见，那在事件传播中如何处理？W3C规定，其目标会变为包含该影子DOM的节点对象。那如何创建一个影子DOM呢？如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;div&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var div = document.getElementById(&quot;div&quot;),</span><br><span class=\"line\">    root = div.webkitCreateShadowRoot(),</span><br><span class=\"line\">    shdowImg = document.createElement(&quot;img&quot;),</span><br><span class=\"line\">    txtP = document.createElement(&quot;p&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">shdowImg.src = &quot;http://miniwa.com.cn/img/favicon.png&quot;;</span><br><span class=\"line\">txtp.innerHTML = &quot;this is a test&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">root.appendChild(shdowImg);</span><br><span class=\"line\">root.appendChild(txtp);</span><br><span class=\"line\">    </span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>shadow dom是一种把类的概念迁移到html上的实践，主要是解决一个文档中可能需要大量交互的多个dom树的建立以及其各自的功能边界问题。目前只有少量浏览器支持，下面一起来了解webkit中的shadow dom。</p>\n<p>在代码编写过程中，我们常常会定义一个组件，把只关乎自身的东西内聚。例如：react的自定义组件、或者其他MV*框架中的组件。但这其实只是逻辑上的独立，再HTML中，它并没有独立开来，所有的节点也都是交由最顶级的HTML管理。对DOM树的遍历或者样式的选择，都会当来潜在的弊端。如果我们可以实现DOM树的封装和独立，使不同的DOM树之间可以相互独立，又可以独自渲染；那势必会使得组件化更加彻底。W3C工作组于是提出了影子DOM的概念，其使得一些DOM在特定范围内可见，而在网页的DOM树中不可见，但是渲染的结果中却包含了该节点。</p>\n<p>HTML5新支持的特性，例如视频、音频等也都是影子DOM的思想，或许有人会疑惑，既然它不可见，那在事件传播中如何处理？W3C规定，其目标会变为包含该影子DOM的节点对象。那如何创建一个影子DOM呢？如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;div&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var div = document.getElementById(&quot;div&quot;),</span><br><span class=\"line\">    root = div.webkitCreateShadowRoot(),</span><br><span class=\"line\">    shdowImg = document.createElement(&quot;img&quot;),</span><br><span class=\"line\">    txtP = document.createElement(&quot;p&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">shdowImg.src = &quot;http://miniwa.com.cn/img/favicon.png&quot;;</span><br><span class=\"line\">txtp.innerHTML = &quot;this is a test&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">root.appendChild(shdowImg);</span><br><span class=\"line\">root.appendChild(txtp);</span><br><span class=\"line\">    </span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"js的垃圾回收机制","date":"2015-11-06T03:50:12.000Z","_content":"\n### 简介\njs无法管理内存单元，内存的分配和回收都是自动进行的。但是自动并不意味着可以不用管。如果自动分配的内存，因为使用问题而无法释放，这就会造成内存泄露了。要了解js的垃圾回收，先得清楚内存的生命周期。不管什么语言，内存生命周期基本一致：分配所需空间 --> 读写分配的内存空间 --> 不需要的时候将其释放\\归还 。那垃圾回收则是跟第三步相关。那回收的关键就落在如何判断“不需要”了。全局变量不会被回收，局部变量才可以回收。\n\n要想完全将无用的内存释放掉，显然是无法通过某种算法做到的，垃圾回收只能近似地把无用的内存回收。而这种近似地算法有：引用计数和标记-清除。\n\n### 引用\n\n垃圾回收算法主要依赖于引用的概念。js地数据类型分为基本类型和引用类型，引用类型就是为了解决复杂数据结构的数据不要存储多份的问题。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它 原型 的引用（隐式引用）和对它属性的引用（显式引用）。\n\n### 引用计数法\n\n给每个分配的变量一个count记录引用的次数，当函数结束的时候，会扫描一下这个计算，如果变量的引用次数为零，则表明该变量没有引用指向它，则其可被回收。\n\n```\nvar o = { \n  a: {\n    b:2\n  }\n}; \n// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o\n// 很显然，没有一个可以被垃圾收集\nvar o2 = o; // o2变量是第二个对“这个对象”的引用\n\no = 1;      // 现在，“这个对象”的原始引用o被o2替换了\nvar oa = o2.a; // 引用“这个对象”的a属性\n// 现在，“这个对象”有两个引用了，一个是o2，一个是oa\n\no2 = \"yo\"; // 最初的对象现在已经是零引用了\n           // 他可以被垃圾回收了\n           // 然而它的属性a的对象还在被oa引用，所以还不能回收\noa = null; // a属性的那个对象现在也是零引用了\n           // 它可以被垃圾回收了\n```\n\n这个算法的不足是：如果一个对象引用另一个（形成了循环引用），他们可能“不再需要”了，但是他们不会被回收。\n所以才有了标记-清除算法。\n\n### 标记-清除算法\n\n在标记清除算法里改变了策略，不以引用为0作为标识，而是以是否可达，即是否可以有跟对象访问得到。即使存在循环引用，但是由根不可达的时候，也将其回收。这个算法中有两个角色：\n\n- collector：垃圾收集器\n- mutator：内存使用者，可以分配、读取、写入内存\n\ncollector可以回收不再使用的内存来供mutator进行NEW操作的使用。\n\n其有两个阶段：标记(mark)和清除(sweep)，\n- 标记阶段：collector从mutator根对象开始进行遍历，对从mutator根对象可以访问到的对象都打上一个标识，一般是在对象的header中，将其记录为可达对象。\n\n- 清除阶段：collector对堆内存(heap memory)从头到尾进行线性的遍历，如果发现某个对象没有标记为可达对象-通过读取对象的header信息，则就将其回收。\n\n### 垃圾回收机制的时机\n\n垃圾回收机制是由程序自动执行的，其会根据需要来执行回收程序。delete，并不会触发垃圾回收，与直接释放内存（只能通过解除引用来间接释放）没有关系。\n\n（Node与其他语言不同的一个地方，就是其限制了JavaScript所能使用的内存（64位为1.4GB，32位为0.7GB））\n\n","source":"_posts/2015-11-6-reback-js.markdown","raw":"---\nlayout: post\ntitle:  \"js的垃圾回收机制\"\ndate:   2015-11-06 11:50:12\ncategories: \"js原理\"\n---\n\n### 简介\njs无法管理内存单元，内存的分配和回收都是自动进行的。但是自动并不意味着可以不用管。如果自动分配的内存，因为使用问题而无法释放，这就会造成内存泄露了。要了解js的垃圾回收，先得清楚内存的生命周期。不管什么语言，内存生命周期基本一致：分配所需空间 --> 读写分配的内存空间 --> 不需要的时候将其释放\\归还 。那垃圾回收则是跟第三步相关。那回收的关键就落在如何判断“不需要”了。全局变量不会被回收，局部变量才可以回收。\n\n要想完全将无用的内存释放掉，显然是无法通过某种算法做到的，垃圾回收只能近似地把无用的内存回收。而这种近似地算法有：引用计数和标记-清除。\n\n### 引用\n\n垃圾回收算法主要依赖于引用的概念。js地数据类型分为基本类型和引用类型，引用类型就是为了解决复杂数据结构的数据不要存储多份的问题。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它 原型 的引用（隐式引用）和对它属性的引用（显式引用）。\n\n### 引用计数法\n\n给每个分配的变量一个count记录引用的次数，当函数结束的时候，会扫描一下这个计算，如果变量的引用次数为零，则表明该变量没有引用指向它，则其可被回收。\n\n```\nvar o = { \n  a: {\n    b:2\n  }\n}; \n// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o\n// 很显然，没有一个可以被垃圾收集\nvar o2 = o; // o2变量是第二个对“这个对象”的引用\n\no = 1;      // 现在，“这个对象”的原始引用o被o2替换了\nvar oa = o2.a; // 引用“这个对象”的a属性\n// 现在，“这个对象”有两个引用了，一个是o2，一个是oa\n\no2 = \"yo\"; // 最初的对象现在已经是零引用了\n           // 他可以被垃圾回收了\n           // 然而它的属性a的对象还在被oa引用，所以还不能回收\noa = null; // a属性的那个对象现在也是零引用了\n           // 它可以被垃圾回收了\n```\n\n这个算法的不足是：如果一个对象引用另一个（形成了循环引用），他们可能“不再需要”了，但是他们不会被回收。\n所以才有了标记-清除算法。\n\n### 标记-清除算法\n\n在标记清除算法里改变了策略，不以引用为0作为标识，而是以是否可达，即是否可以有跟对象访问得到。即使存在循环引用，但是由根不可达的时候，也将其回收。这个算法中有两个角色：\n\n- collector：垃圾收集器\n- mutator：内存使用者，可以分配、读取、写入内存\n\ncollector可以回收不再使用的内存来供mutator进行NEW操作的使用。\n\n其有两个阶段：标记(mark)和清除(sweep)，\n- 标记阶段：collector从mutator根对象开始进行遍历，对从mutator根对象可以访问到的对象都打上一个标识，一般是在对象的header中，将其记录为可达对象。\n\n- 清除阶段：collector对堆内存(heap memory)从头到尾进行线性的遍历，如果发现某个对象没有标记为可达对象-通过读取对象的header信息，则就将其回收。\n\n### 垃圾回收机制的时机\n\n垃圾回收机制是由程序自动执行的，其会根据需要来执行回收程序。delete，并不会触发垃圾回收，与直接释放内存（只能通过解除引用来间接释放）没有关系。\n\n（Node与其他语言不同的一个地方，就是其限制了JavaScript所能使用的内存（64位为1.4GB，32位为0.7GB））\n\n","slug":"2015-11-6-reback-js","published":1,"updated":"2018-05-26T16:02:28.462Z","comments":1,"photos":[],"link":"","_id":"cjjoevoew00050gupo75ru6wh","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>js无法管理内存单元，内存的分配和回收都是自动进行的。但是自动并不意味着可以不用管。如果自动分配的内存，因为使用问题而无法释放，这就会造成内存泄露了。要了解js的垃圾回收，先得清楚内存的生命周期。不管什么语言，内存生命周期基本一致：分配所需空间 –&gt; 读写分配的内存空间 –&gt; 不需要的时候将其释放\\归还 。那垃圾回收则是跟第三步相关。那回收的关键就落在如何判断“不需要”了。全局变量不会被回收，局部变量才可以回收。</p>\n<p>要想完全将无用的内存释放掉，显然是无法通过某种算法做到的，垃圾回收只能近似地把无用的内存回收。而这种近似地算法有：引用计数和标记-清除。</p>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>垃圾回收算法主要依赖于引用的概念。js地数据类型分为基本类型和引用类型，引用类型就是为了解决复杂数据结构的数据不要存储多份的问题。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它 原型 的引用（隐式引用）和对它属性的引用（显式引用）。</p>\n<h3 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h3><p>给每个分配的变量一个count记录引用的次数，当函数结束的时候，会扫描一下这个计算，如果变量的引用次数为零，则表明该变量没有引用指向它，则其可被回收。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o = &#123; </span><br><span class=\"line\">  a: &#123;</span><br><span class=\"line\">    b:2</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o</span><br><span class=\"line\">// 很显然，没有一个可以被垃圾收集</span><br><span class=\"line\">var o2 = o; // o2变量是第二个对“这个对象”的引用</span><br><span class=\"line\"></span><br><span class=\"line\">o = 1;      // 现在，“这个对象”的原始引用o被o2替换了</span><br><span class=\"line\">var oa = o2.a; // 引用“这个对象”的a属性</span><br><span class=\"line\">// 现在，“这个对象”有两个引用了，一个是o2，一个是oa</span><br><span class=\"line\"></span><br><span class=\"line\">o2 = &quot;yo&quot;; // 最初的对象现在已经是零引用了</span><br><span class=\"line\">           // 他可以被垃圾回收了</span><br><span class=\"line\">           // 然而它的属性a的对象还在被oa引用，所以还不能回收</span><br><span class=\"line\">oa = null; // a属性的那个对象现在也是零引用了</span><br><span class=\"line\">           // 它可以被垃圾回收了</span><br></pre></td></tr></table></figure>\n<p>这个算法的不足是：如果一个对象引用另一个（形成了循环引用），他们可能“不再需要”了，但是他们不会被回收。<br>所以才有了标记-清除算法。</p>\n<h3 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h3><p>在标记清除算法里改变了策略，不以引用为0作为标识，而是以是否可达，即是否可以有跟对象访问得到。即使存在循环引用，但是由根不可达的时候，也将其回收。这个算法中有两个角色：</p>\n<ul>\n<li>collector：垃圾收集器</li>\n<li>mutator：内存使用者，可以分配、读取、写入内存</li>\n</ul>\n<p>collector可以回收不再使用的内存来供mutator进行NEW操作的使用。</p>\n<p>其有两个阶段：标记(mark)和清除(sweep)，</p>\n<ul>\n<li><p>标记阶段：collector从mutator根对象开始进行遍历，对从mutator根对象可以访问到的对象都打上一个标识，一般是在对象的header中，将其记录为可达对象。</p>\n</li>\n<li><p>清除阶段：collector对堆内存(heap memory)从头到尾进行线性的遍历，如果发现某个对象没有标记为可达对象-通过读取对象的header信息，则就将其回收。</p>\n</li>\n</ul>\n<h3 id=\"垃圾回收机制的时机\"><a href=\"#垃圾回收机制的时机\" class=\"headerlink\" title=\"垃圾回收机制的时机\"></a>垃圾回收机制的时机</h3><p>垃圾回收机制是由程序自动执行的，其会根据需要来执行回收程序。delete，并不会触发垃圾回收，与直接释放内存（只能通过解除引用来间接释放）没有关系。</p>\n<p>（Node与其他语言不同的一个地方，就是其限制了JavaScript所能使用的内存（64位为1.4GB，32位为0.7GB））</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>js无法管理内存单元，内存的分配和回收都是自动进行的。但是自动并不意味着可以不用管。如果自动分配的内存，因为使用问题而无法释放，这就会造成内存泄露了。要了解js的垃圾回收，先得清楚内存的生命周期。不管什么语言，内存生命周期基本一致：分配所需空间 –&gt; 读写分配的内存空间 –&gt; 不需要的时候将其释放\\归还 。那垃圾回收则是跟第三步相关。那回收的关键就落在如何判断“不需要”了。全局变量不会被回收，局部变量才可以回收。</p>\n<p>要想完全将无用的内存释放掉，显然是无法通过某种算法做到的，垃圾回收只能近似地把无用的内存回收。而这种近似地算法有：引用计数和标记-清除。</p>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>垃圾回收算法主要依赖于引用的概念。js地数据类型分为基本类型和引用类型，引用类型就是为了解决复杂数据结构的数据不要存储多份的问题。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它 原型 的引用（隐式引用）和对它属性的引用（显式引用）。</p>\n<h3 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h3><p>给每个分配的变量一个count记录引用的次数，当函数结束的时候，会扫描一下这个计算，如果变量的引用次数为零，则表明该变量没有引用指向它，则其可被回收。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o = &#123; </span><br><span class=\"line\">  a: &#123;</span><br><span class=\"line\">    b:2</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o</span><br><span class=\"line\">// 很显然，没有一个可以被垃圾收集</span><br><span class=\"line\">var o2 = o; // o2变量是第二个对“这个对象”的引用</span><br><span class=\"line\"></span><br><span class=\"line\">o = 1;      // 现在，“这个对象”的原始引用o被o2替换了</span><br><span class=\"line\">var oa = o2.a; // 引用“这个对象”的a属性</span><br><span class=\"line\">// 现在，“这个对象”有两个引用了，一个是o2，一个是oa</span><br><span class=\"line\"></span><br><span class=\"line\">o2 = &quot;yo&quot;; // 最初的对象现在已经是零引用了</span><br><span class=\"line\">           // 他可以被垃圾回收了</span><br><span class=\"line\">           // 然而它的属性a的对象还在被oa引用，所以还不能回收</span><br><span class=\"line\">oa = null; // a属性的那个对象现在也是零引用了</span><br><span class=\"line\">           // 它可以被垃圾回收了</span><br></pre></td></tr></table></figure>\n<p>这个算法的不足是：如果一个对象引用另一个（形成了循环引用），他们可能“不再需要”了，但是他们不会被回收。<br>所以才有了标记-清除算法。</p>\n<h3 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h3><p>在标记清除算法里改变了策略，不以引用为0作为标识，而是以是否可达，即是否可以有跟对象访问得到。即使存在循环引用，但是由根不可达的时候，也将其回收。这个算法中有两个角色：</p>\n<ul>\n<li>collector：垃圾收集器</li>\n<li>mutator：内存使用者，可以分配、读取、写入内存</li>\n</ul>\n<p>collector可以回收不再使用的内存来供mutator进行NEW操作的使用。</p>\n<p>其有两个阶段：标记(mark)和清除(sweep)，</p>\n<ul>\n<li><p>标记阶段：collector从mutator根对象开始进行遍历，对从mutator根对象可以访问到的对象都打上一个标识，一般是在对象的header中，将其记录为可达对象。</p>\n</li>\n<li><p>清除阶段：collector对堆内存(heap memory)从头到尾进行线性的遍历，如果发现某个对象没有标记为可达对象-通过读取对象的header信息，则就将其回收。</p>\n</li>\n</ul>\n<h3 id=\"垃圾回收机制的时机\"><a href=\"#垃圾回收机制的时机\" class=\"headerlink\" title=\"垃圾回收机制的时机\"></a>垃圾回收机制的时机</h3><p>垃圾回收机制是由程序自动执行的，其会根据需要来执行回收程序。delete，并不会触发垃圾回收，与直接释放内存（只能通过解除引用来间接释放）没有关系。</p>\n<p>（Node与其他语言不同的一个地方，就是其限制了JavaScript所能使用的内存（64位为1.4GB，32位为0.7GB））</p>\n"},{"layout":"post","title":"node模块加载","date":"2016-04-10T03:50:12.000Z","_content":"\nnode的模块分为核心模块和文件模块，核心模块是node提供的内置模块，在node源码编译过程中，编译进了二进制执行文件，部分模块在node进程启动时就已经加载进内存中；而文件模块则是运行时动态加载。正如浏览器的缓存一样，node会对引入过的模块进行缓存，以减少二次引入的开销；不同的是node会缓存模块的结果对象而不只是文件。模块的加载包括三个步骤：\n\n1. 路径分析\n2. 文件定位\n3. 编译执行\n\n### 路径分析\nnode的require方法接受一个标识符作参数，实现模块加载，而该标识符主要有以下几类：\n- 核心模块，如http、fs、path等\n- .或者..开头的相对路径文件模块\n- 以/开始的绝对路径文件模块\n- 非路径形式的文件模块，如第三方插件\n\n### 文件定位\n**核心模块**\n\n核心模块是优先加载的，也因为这个，与核心模块同名的第三方模块将不会加载。\n\n**路径形式的文件模块**\n\n以.或者..或者/开始的标识符，都会当做文件模块处理，会先将其转化为真实的路径，并以真实的路径作为索引，缓存到内存中，以便第二次加载。\n\n**第三方模块**\n\n这类模块可能是一个文件也可能是一个包，加载比较耗时。其查找文件的方式如下：\n- 在当前文件目录下的node_modules目录\n- 父目录下的node_modules目录\n- 父目录的父目录的node_modules目录\n···\n- 直到根目录的node_modules目录\n\n对于不包含后缀名的标识，node会按.js、.json、.node的次序尝试查找文件，在尝试过程中是同步的，所以写的时候如果带上后缀会速度快一点。\n\n如果node找到一个和标识符一样的文件夹，node会当一个包来处理，查找目录下的package.json文件，通过JSON.parse解析文件的内容，从中找出main属性指定的文件名进行定位，如果仍没有文件则会找默认的index.js、index.json、index.node。\n\n### 编译执行\n在node中，每个文件模块都是一个对象它的定义如下：\n```\nfunction Module(id, parent){\n    this.id = id;\n    this.exports = {};\n    this.parent = parent;\n    if(parent && parent.children){\n        parent.children.push(this);\n    }\n\n    this.filename = null;\n    this.loaded = false;\n    this.children = [];\n}\n```\n在编译和执行的时候，node会按上面构建一个对象，再把找到的模块文件载入到对象中。对于不同的文件扩展名，node会用不同的方式载入：\n- .js文件。通过fs模块读取后编译执行\n- .node文件。是用c或者c++编写的扩展文件，通过dlopen()方法加载后编译生成的文件\n- .json文件。通过fs读取后用JSON.parse()解释返回结果\n- 其余扩展名文件。被当成.js文件载入\n\n每次模块载入之后，都会将其文件路径作为索引缓存到Module._cache对象上，以提高二次引入性能。_\n\n\n在载入模块文件过程中，为了避免局部变量污染，会对js文件进行头尾包装，在头部添加(function (exports, require, module, __filename, __dirname) ；在尾部添加)。这样每个文件之间就进行了作用域隔离，包装后的文件会通过vm原生模块的runInThisContext（类似eval，只是具有具体的上下文，不会污染全局）返回一个function，而其exports会返回给调用方。\n\n**需要注意的是：模块里既然有exports可以导出接口，为何需要module.exports呢**\n```\nfunction test(module, exports){\n    module.exports = 100;\n    exports = 100;\n}\nvar module = {exports: 10}, exports = 10;\nconsole.log(\"before->module.exports:\", module.exports);\nconsole.log(\"before->exports:\", exports);\ntest(module, exports);\nconsole.log(\"after->module.exports:\", module.exports);\nconsole.log(\"after->exports:\", exports);\n//输出如下\n//before->module.exports: 10\n//before->exports: 10\n//after->module.exports: 100\n//after->exports: 10\n```\n\n以上的原因是：基础数据类型（number、string、boolean）的形参修改不会影响实参的值，而数组、对象的形参修改会反映到实参上。这里涉及到的是按值传递和按共享传递。\n\n- 按值传递：函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。\n- 按共享传递：对象是可变的，调用者和被调用者共享同一个对象，两者的修改都会互相可见。\n","source":"_posts/2016-04-12-node-npm.markdown","raw":"---\nlayout: post\ntitle:  \"node模块加载\"\ndate:   2016-04-10 11:50:12\ncategories: \"基础知识\"\n---\n\nnode的模块分为核心模块和文件模块，核心模块是node提供的内置模块，在node源码编译过程中，编译进了二进制执行文件，部分模块在node进程启动时就已经加载进内存中；而文件模块则是运行时动态加载。正如浏览器的缓存一样，node会对引入过的模块进行缓存，以减少二次引入的开销；不同的是node会缓存模块的结果对象而不只是文件。模块的加载包括三个步骤：\n\n1. 路径分析\n2. 文件定位\n3. 编译执行\n\n### 路径分析\nnode的require方法接受一个标识符作参数，实现模块加载，而该标识符主要有以下几类：\n- 核心模块，如http、fs、path等\n- .或者..开头的相对路径文件模块\n- 以/开始的绝对路径文件模块\n- 非路径形式的文件模块，如第三方插件\n\n### 文件定位\n**核心模块**\n\n核心模块是优先加载的，也因为这个，与核心模块同名的第三方模块将不会加载。\n\n**路径形式的文件模块**\n\n以.或者..或者/开始的标识符，都会当做文件模块处理，会先将其转化为真实的路径，并以真实的路径作为索引，缓存到内存中，以便第二次加载。\n\n**第三方模块**\n\n这类模块可能是一个文件也可能是一个包，加载比较耗时。其查找文件的方式如下：\n- 在当前文件目录下的node_modules目录\n- 父目录下的node_modules目录\n- 父目录的父目录的node_modules目录\n···\n- 直到根目录的node_modules目录\n\n对于不包含后缀名的标识，node会按.js、.json、.node的次序尝试查找文件，在尝试过程中是同步的，所以写的时候如果带上后缀会速度快一点。\n\n如果node找到一个和标识符一样的文件夹，node会当一个包来处理，查找目录下的package.json文件，通过JSON.parse解析文件的内容，从中找出main属性指定的文件名进行定位，如果仍没有文件则会找默认的index.js、index.json、index.node。\n\n### 编译执行\n在node中，每个文件模块都是一个对象它的定义如下：\n```\nfunction Module(id, parent){\n    this.id = id;\n    this.exports = {};\n    this.parent = parent;\n    if(parent && parent.children){\n        parent.children.push(this);\n    }\n\n    this.filename = null;\n    this.loaded = false;\n    this.children = [];\n}\n```\n在编译和执行的时候，node会按上面构建一个对象，再把找到的模块文件载入到对象中。对于不同的文件扩展名，node会用不同的方式载入：\n- .js文件。通过fs模块读取后编译执行\n- .node文件。是用c或者c++编写的扩展文件，通过dlopen()方法加载后编译生成的文件\n- .json文件。通过fs读取后用JSON.parse()解释返回结果\n- 其余扩展名文件。被当成.js文件载入\n\n每次模块载入之后，都会将其文件路径作为索引缓存到Module._cache对象上，以提高二次引入性能。_\n\n\n在载入模块文件过程中，为了避免局部变量污染，会对js文件进行头尾包装，在头部添加(function (exports, require, module, __filename, __dirname) ；在尾部添加)。这样每个文件之间就进行了作用域隔离，包装后的文件会通过vm原生模块的runInThisContext（类似eval，只是具有具体的上下文，不会污染全局）返回一个function，而其exports会返回给调用方。\n\n**需要注意的是：模块里既然有exports可以导出接口，为何需要module.exports呢**\n```\nfunction test(module, exports){\n    module.exports = 100;\n    exports = 100;\n}\nvar module = {exports: 10}, exports = 10;\nconsole.log(\"before->module.exports:\", module.exports);\nconsole.log(\"before->exports:\", exports);\ntest(module, exports);\nconsole.log(\"after->module.exports:\", module.exports);\nconsole.log(\"after->exports:\", exports);\n//输出如下\n//before->module.exports: 10\n//before->exports: 10\n//after->module.exports: 100\n//after->exports: 10\n```\n\n以上的原因是：基础数据类型（number、string、boolean）的形参修改不会影响实参的值，而数组、对象的形参修改会反映到实参上。这里涉及到的是按值传递和按共享传递。\n\n- 按值传递：函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。\n- 按共享传递：对象是可变的，调用者和被调用者共享同一个对象，两者的修改都会互相可见。\n","slug":"2016-04-12-node-npm","published":1,"updated":"2018-05-26T16:02:28.556Z","comments":1,"photos":[],"link":"","_id":"cjjoevof000060gupsrh6stee","content":"<p>node的模块分为核心模块和文件模块，核心模块是node提供的内置模块，在node源码编译过程中，编译进了二进制执行文件，部分模块在node进程启动时就已经加载进内存中；而文件模块则是运行时动态加载。正如浏览器的缓存一样，node会对引入过的模块进行缓存，以减少二次引入的开销；不同的是node会缓存模块的结果对象而不只是文件。模块的加载包括三个步骤：</p>\n<ol>\n<li>路径分析</li>\n<li>文件定位</li>\n<li>编译执行</li>\n</ol>\n<h3 id=\"路径分析\"><a href=\"#路径分析\" class=\"headerlink\" title=\"路径分析\"></a>路径分析</h3><p>node的require方法接受一个标识符作参数，实现模块加载，而该标识符主要有以下几类：</p>\n<ul>\n<li>核心模块，如http、fs、path等</li>\n<li>.或者..开头的相对路径文件模块</li>\n<li>以/开始的绝对路径文件模块</li>\n<li>非路径形式的文件模块，如第三方插件</li>\n</ul>\n<h3 id=\"文件定位\"><a href=\"#文件定位\" class=\"headerlink\" title=\"文件定位\"></a>文件定位</h3><p><strong>核心模块</strong></p>\n<p>核心模块是优先加载的，也因为这个，与核心模块同名的第三方模块将不会加载。</p>\n<p><strong>路径形式的文件模块</strong></p>\n<p>以.或者..或者/开始的标识符，都会当做文件模块处理，会先将其转化为真实的路径，并以真实的路径作为索引，缓存到内存中，以便第二次加载。</p>\n<p><strong>第三方模块</strong></p>\n<p>这类模块可能是一个文件也可能是一个包，加载比较耗时。其查找文件的方式如下：</p>\n<ul>\n<li>在当前文件目录下的node_modules目录</li>\n<li>父目录下的node_modules目录</li>\n<li>父目录的父目录的node_modules目录<br>···</li>\n<li>直到根目录的node_modules目录</li>\n</ul>\n<p>对于不包含后缀名的标识，node会按.js、.json、.node的次序尝试查找文件，在尝试过程中是同步的，所以写的时候如果带上后缀会速度快一点。</p>\n<p>如果node找到一个和标识符一样的文件夹，node会当一个包来处理，查找目录下的package.json文件，通过JSON.parse解析文件的内容，从中找出main属性指定的文件名进行定位，如果仍没有文件则会找默认的index.js、index.json、index.node。</p>\n<h3 id=\"编译执行\"><a href=\"#编译执行\" class=\"headerlink\" title=\"编译执行\"></a>编译执行</h3><p>在node中，每个文件模块都是一个对象它的定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Module(id, parent)&#123;</span><br><span class=\"line\">    this.id = id;</span><br><span class=\"line\">    this.exports = &#123;&#125;;</span><br><span class=\"line\">    this.parent = parent;</span><br><span class=\"line\">    if(parent &amp;&amp; parent.children)&#123;</span><br><span class=\"line\">        parent.children.push(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    this.filename = null;</span><br><span class=\"line\">    this.loaded = false;</span><br><span class=\"line\">    this.children = [];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在编译和执行的时候，node会按上面构建一个对象，再把找到的模块文件载入到对象中。对于不同的文件扩展名，node会用不同的方式载入：</p>\n<ul>\n<li>.js文件。通过fs模块读取后编译执行</li>\n<li>.node文件。是用c或者c++编写的扩展文件，通过dlopen()方法加载后编译生成的文件</li>\n<li>.json文件。通过fs读取后用JSON.parse()解释返回结果</li>\n<li>其余扩展名文件。被当成.js文件载入</li>\n</ul>\n<p>每次模块载入之后，都会将其文件路径作为索引缓存到Module.<em>cache对象上，以提高二次引入性能。</em></p>\n<p>在载入模块文件过程中，为了避免局部变量污染，会对js文件进行头尾包装，在头部添加(function (exports, require, module, <strong>filename, </strong>dirname) ；在尾部添加)。这样每个文件之间就进行了作用域隔离，包装后的文件会通过vm原生模块的runInThisContext（类似eval，只是具有具体的上下文，不会污染全局）返回一个function，而其exports会返回给调用方。</p>\n<p><strong>需要注意的是：模块里既然有exports可以导出接口，为何需要module.exports呢</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test(module, exports)&#123;</span><br><span class=\"line\">    module.exports = 100;</span><br><span class=\"line\">    exports = 100;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var module = &#123;exports: 10&#125;, exports = 10;</span><br><span class=\"line\">console.log(&quot;before-&gt;module.exports:&quot;, module.exports);</span><br><span class=\"line\">console.log(&quot;before-&gt;exports:&quot;, exports);</span><br><span class=\"line\">test(module, exports);</span><br><span class=\"line\">console.log(&quot;after-&gt;module.exports:&quot;, module.exports);</span><br><span class=\"line\">console.log(&quot;after-&gt;exports:&quot;, exports);</span><br><span class=\"line\">//输出如下</span><br><span class=\"line\">//before-&gt;module.exports: 10</span><br><span class=\"line\">//before-&gt;exports: 10</span><br><span class=\"line\">//after-&gt;module.exports: 100</span><br><span class=\"line\">//after-&gt;exports: 10</span><br></pre></td></tr></table></figure></p>\n<p>以上的原因是：基础数据类型（number、string、boolean）的形参修改不会影响实参的值，而数组、对象的形参修改会反映到实参上。这里涉及到的是按值传递和按共享传递。</p>\n<ul>\n<li>按值传递：函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。</li>\n<li>按共享传递：对象是可变的，调用者和被调用者共享同一个对象，两者的修改都会互相可见。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>node的模块分为核心模块和文件模块，核心模块是node提供的内置模块，在node源码编译过程中，编译进了二进制执行文件，部分模块在node进程启动时就已经加载进内存中；而文件模块则是运行时动态加载。正如浏览器的缓存一样，node会对引入过的模块进行缓存，以减少二次引入的开销；不同的是node会缓存模块的结果对象而不只是文件。模块的加载包括三个步骤：</p>\n<ol>\n<li>路径分析</li>\n<li>文件定位</li>\n<li>编译执行</li>\n</ol>\n<h3 id=\"路径分析\"><a href=\"#路径分析\" class=\"headerlink\" title=\"路径分析\"></a>路径分析</h3><p>node的require方法接受一个标识符作参数，实现模块加载，而该标识符主要有以下几类：</p>\n<ul>\n<li>核心模块，如http、fs、path等</li>\n<li>.或者..开头的相对路径文件模块</li>\n<li>以/开始的绝对路径文件模块</li>\n<li>非路径形式的文件模块，如第三方插件</li>\n</ul>\n<h3 id=\"文件定位\"><a href=\"#文件定位\" class=\"headerlink\" title=\"文件定位\"></a>文件定位</h3><p><strong>核心模块</strong></p>\n<p>核心模块是优先加载的，也因为这个，与核心模块同名的第三方模块将不会加载。</p>\n<p><strong>路径形式的文件模块</strong></p>\n<p>以.或者..或者/开始的标识符，都会当做文件模块处理，会先将其转化为真实的路径，并以真实的路径作为索引，缓存到内存中，以便第二次加载。</p>\n<p><strong>第三方模块</strong></p>\n<p>这类模块可能是一个文件也可能是一个包，加载比较耗时。其查找文件的方式如下：</p>\n<ul>\n<li>在当前文件目录下的node_modules目录</li>\n<li>父目录下的node_modules目录</li>\n<li>父目录的父目录的node_modules目录<br>···</li>\n<li>直到根目录的node_modules目录</li>\n</ul>\n<p>对于不包含后缀名的标识，node会按.js、.json、.node的次序尝试查找文件，在尝试过程中是同步的，所以写的时候如果带上后缀会速度快一点。</p>\n<p>如果node找到一个和标识符一样的文件夹，node会当一个包来处理，查找目录下的package.json文件，通过JSON.parse解析文件的内容，从中找出main属性指定的文件名进行定位，如果仍没有文件则会找默认的index.js、index.json、index.node。</p>\n<h3 id=\"编译执行\"><a href=\"#编译执行\" class=\"headerlink\" title=\"编译执行\"></a>编译执行</h3><p>在node中，每个文件模块都是一个对象它的定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Module(id, parent)&#123;</span><br><span class=\"line\">    this.id = id;</span><br><span class=\"line\">    this.exports = &#123;&#125;;</span><br><span class=\"line\">    this.parent = parent;</span><br><span class=\"line\">    if(parent &amp;&amp; parent.children)&#123;</span><br><span class=\"line\">        parent.children.push(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    this.filename = null;</span><br><span class=\"line\">    this.loaded = false;</span><br><span class=\"line\">    this.children = [];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在编译和执行的时候，node会按上面构建一个对象，再把找到的模块文件载入到对象中。对于不同的文件扩展名，node会用不同的方式载入：</p>\n<ul>\n<li>.js文件。通过fs模块读取后编译执行</li>\n<li>.node文件。是用c或者c++编写的扩展文件，通过dlopen()方法加载后编译生成的文件</li>\n<li>.json文件。通过fs读取后用JSON.parse()解释返回结果</li>\n<li>其余扩展名文件。被当成.js文件载入</li>\n</ul>\n<p>每次模块载入之后，都会将其文件路径作为索引缓存到Module.<em>cache对象上，以提高二次引入性能。</em></p>\n<p>在载入模块文件过程中，为了避免局部变量污染，会对js文件进行头尾包装，在头部添加(function (exports, require, module, <strong>filename, </strong>dirname) ；在尾部添加)。这样每个文件之间就进行了作用域隔离，包装后的文件会通过vm原生模块的runInThisContext（类似eval，只是具有具体的上下文，不会污染全局）返回一个function，而其exports会返回给调用方。</p>\n<p><strong>需要注意的是：模块里既然有exports可以导出接口，为何需要module.exports呢</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test(module, exports)&#123;</span><br><span class=\"line\">    module.exports = 100;</span><br><span class=\"line\">    exports = 100;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var module = &#123;exports: 10&#125;, exports = 10;</span><br><span class=\"line\">console.log(&quot;before-&gt;module.exports:&quot;, module.exports);</span><br><span class=\"line\">console.log(&quot;before-&gt;exports:&quot;, exports);</span><br><span class=\"line\">test(module, exports);</span><br><span class=\"line\">console.log(&quot;after-&gt;module.exports:&quot;, module.exports);</span><br><span class=\"line\">console.log(&quot;after-&gt;exports:&quot;, exports);</span><br><span class=\"line\">//输出如下</span><br><span class=\"line\">//before-&gt;module.exports: 10</span><br><span class=\"line\">//before-&gt;exports: 10</span><br><span class=\"line\">//after-&gt;module.exports: 100</span><br><span class=\"line\">//after-&gt;exports: 10</span><br></pre></td></tr></table></figure></p>\n<p>以上的原因是：基础数据类型（number、string、boolean）的形参修改不会影响实参的值，而数组、对象的形参修改会反映到实参上。这里涉及到的是按值传递和按共享传递。</p>\n<ul>\n<li>按值传递：函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。</li>\n<li>按共享传递：对象是可变的，调用者和被调用者共享同一个对象，两者的修改都会互相可见。</li>\n</ul>\n"},{"layout":"post","title":"reactjs总结","date":"2016-04-10T03:50:12.000Z","_content":"\n在项目中使用了reactjs框架，其对组件更加彻底，编写起来也更加方便。对外暴露的接口、api也不多。在这里想总结一下：\n\nReactElement：拥有四个属性type，props，key，ref，不携带方法，原型上什么都没有\n\nReactNode：可以是ReactElement、string、number、ReactNode实例数组（ReactFragment）\n\nReactComponent：组件，一个简单的js类，构造函数\n\n\n\n- React.unmountComponentAtNode只可以移除有React.render方法渲染的组件，而对其内部的子组件无效，会返回false\n- React.componentWillReceiveProps接口的this.props是旧的props，新的props需要在形参里获取；初次渲染时，不会触发\n- this.forceUpdate在界面的数据不只是包含state还有别的时候调用\n- 特殊的DOM属性key，在差异检查的时候会确保组件是否保留，在diff的时候，如果前后key一样，则改组件还保留在dom中只会更新数据，不一样的时候，才会移除重新生成\n- this.props.children返回的不是自己的子组件，而是父组件传递给你的子组件\n- JSX并不会返回组件的引用，而是一个ReactElement，一个描述组件结构的对象，通过Render.render函数返回的才是组件的实例\n- JSX只是函数调用和对象创建的语法糖，只能用表达式不能使用if else for等\n- 同一个组件调用React.render获取到的实例是同一个对象，不会生成多个；如需重新生成一个新的饿，需先移除旧的\n\n","source":"_posts/2016-04-10-react-resume.markdown","raw":"---\nlayout: post\ntitle:  \"reactjs总结\"\ndate:   2016-04-10 11:50:12\ncategories: \"基础知识\"\n---\n\n在项目中使用了reactjs框架，其对组件更加彻底，编写起来也更加方便。对外暴露的接口、api也不多。在这里想总结一下：\n\nReactElement：拥有四个属性type，props，key，ref，不携带方法，原型上什么都没有\n\nReactNode：可以是ReactElement、string、number、ReactNode实例数组（ReactFragment）\n\nReactComponent：组件，一个简单的js类，构造函数\n\n\n\n- React.unmountComponentAtNode只可以移除有React.render方法渲染的组件，而对其内部的子组件无效，会返回false\n- React.componentWillReceiveProps接口的this.props是旧的props，新的props需要在形参里获取；初次渲染时，不会触发\n- this.forceUpdate在界面的数据不只是包含state还有别的时候调用\n- 特殊的DOM属性key，在差异检查的时候会确保组件是否保留，在diff的时候，如果前后key一样，则改组件还保留在dom中只会更新数据，不一样的时候，才会移除重新生成\n- this.props.children返回的不是自己的子组件，而是父组件传递给你的子组件\n- JSX并不会返回组件的引用，而是一个ReactElement，一个描述组件结构的对象，通过Render.render函数返回的才是组件的实例\n- JSX只是函数调用和对象创建的语法糖，只能用表达式不能使用if else for等\n- 同一个组件调用React.render获取到的实例是同一个对象，不会生成多个；如需重新生成一个新的饿，需先移除旧的\n\n","slug":"2016-04-10-react-resume","published":1,"updated":"2016-05-20T12:05:19.584Z","comments":1,"photos":[],"link":"","_id":"cjjoevof700080gupq5nhp5pn","content":"<p>在项目中使用了reactjs框架，其对组件更加彻底，编写起来也更加方便。对外暴露的接口、api也不多。在这里想总结一下：</p>\n<p>ReactElement：拥有四个属性type，props，key，ref，不携带方法，原型上什么都没有</p>\n<p>ReactNode：可以是ReactElement、string、number、ReactNode实例数组（ReactFragment）</p>\n<p>ReactComponent：组件，一个简单的js类，构造函数</p>\n<ul>\n<li>React.unmountComponentAtNode只可以移除有React.render方法渲染的组件，而对其内部的子组件无效，会返回false</li>\n<li>React.componentWillReceiveProps接口的this.props是旧的props，新的props需要在形参里获取；初次渲染时，不会触发</li>\n<li>this.forceUpdate在界面的数据不只是包含state还有别的时候调用</li>\n<li>特殊的DOM属性key，在差异检查的时候会确保组件是否保留，在diff的时候，如果前后key一样，则改组件还保留在dom中只会更新数据，不一样的时候，才会移除重新生成</li>\n<li>this.props.children返回的不是自己的子组件，而是父组件传递给你的子组件</li>\n<li>JSX并不会返回组件的引用，而是一个ReactElement，一个描述组件结构的对象，通过Render.render函数返回的才是组件的实例</li>\n<li>JSX只是函数调用和对象创建的语法糖，只能用表达式不能使用if else for等</li>\n<li>同一个组件调用React.render获取到的实例是同一个对象，不会生成多个；如需重新生成一个新的饿，需先移除旧的</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>在项目中使用了reactjs框架，其对组件更加彻底，编写起来也更加方便。对外暴露的接口、api也不多。在这里想总结一下：</p>\n<p>ReactElement：拥有四个属性type，props，key，ref，不携带方法，原型上什么都没有</p>\n<p>ReactNode：可以是ReactElement、string、number、ReactNode实例数组（ReactFragment）</p>\n<p>ReactComponent：组件，一个简单的js类，构造函数</p>\n<ul>\n<li>React.unmountComponentAtNode只可以移除有React.render方法渲染的组件，而对其内部的子组件无效，会返回false</li>\n<li>React.componentWillReceiveProps接口的this.props是旧的props，新的props需要在形参里获取；初次渲染时，不会触发</li>\n<li>this.forceUpdate在界面的数据不只是包含state还有别的时候调用</li>\n<li>特殊的DOM属性key，在差异检查的时候会确保组件是否保留，在diff的时候，如果前后key一样，则改组件还保留在dom中只会更新数据，不一样的时候，才会移除重新生成</li>\n<li>this.props.children返回的不是自己的子组件，而是父组件传递给你的子组件</li>\n<li>JSX并不会返回组件的引用，而是一个ReactElement，一个描述组件结构的对象，通过Render.render函数返回的才是组件的实例</li>\n<li>JSX只是函数调用和对象创建的语法糖，只能用表达式不能使用if else for等</li>\n<li>同一个组件调用React.render获取到的实例是同一个对象，不会生成多个；如需重新生成一个新的饿，需先移除旧的</li>\n</ul>\n"},{"layout":"post","title":"css居中显示","date":"2016-04-10T03:50:12.000Z","_content":"\n在页面中居中可以分为水平居中和垂直居中。对水平居中常用的是margin: 0 auto，浏览器会自动计算左右的margin，那同时要实现垂直居中呢？可以如下：\n```\n.absolute-center {\n  margin: auto;\n  position: absolute;\n  overflow: auto;\n  top: 0; left: 0; bottom: 0; right: 0;\n  width: 50%;\n  height: 50%;\n}\n```\n\n这种做法可以兼容ie8-ie10，但是必须要有宽高。\n\n除此之外，也可以通过left和top设置为50%，再加上margin-left和margin-right分别设为负的宽高的50%\n\n","source":"_posts/2015-12-05-css-center.markdown","raw":"---\nlayout: post\ntitle:  \"css居中显示\"\ndate:   2016-04-10 11:50:12\ncategories: \"CSS样式\"\n---\n\n在页面中居中可以分为水平居中和垂直居中。对水平居中常用的是margin: 0 auto，浏览器会自动计算左右的margin，那同时要实现垂直居中呢？可以如下：\n```\n.absolute-center {\n  margin: auto;\n  position: absolute;\n  overflow: auto;\n  top: 0; left: 0; bottom: 0; right: 0;\n  width: 50%;\n  height: 50%;\n}\n```\n\n这种做法可以兼容ie8-ie10，但是必须要有宽高。\n\n除此之外，也可以通过left和top设置为50%，再加上margin-left和margin-right分别设为负的宽高的50%\n\n","slug":"2015-12-05-css-center","published":1,"updated":"2018-05-26T16:02:28.525Z","comments":1,"photos":[],"link":"","_id":"cjjoevofc000a0gupzozkzavy","content":"<p>在页面中居中可以分为水平居中和垂直居中。对水平居中常用的是margin: 0 auto，浏览器会自动计算左右的margin，那同时要实现垂直居中呢？可以如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.absolute-center &#123;</span><br><span class=\"line\">  margin: auto;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  overflow: auto;</span><br><span class=\"line\">  top: 0; left: 0; bottom: 0; right: 0;</span><br><span class=\"line\">  width: 50%;</span><br><span class=\"line\">  height: 50%;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这种做法可以兼容ie8-ie10，但是必须要有宽高。</p>\n<p>除此之外，也可以通过left和top设置为50%，再加上margin-left和margin-right分别设为负的宽高的50%</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在页面中居中可以分为水平居中和垂直居中。对水平居中常用的是margin: 0 auto，浏览器会自动计算左右的margin，那同时要实现垂直居中呢？可以如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.absolute-center &#123;</span><br><span class=\"line\">  margin: auto;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  overflow: auto;</span><br><span class=\"line\">  top: 0; left: 0; bottom: 0; right: 0;</span><br><span class=\"line\">  width: 50%;</span><br><span class=\"line\">  height: 50%;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这种做法可以兼容ie8-ie10，但是必须要有宽高。</p>\n<p>除此之外，也可以通过left和top设置为50%，再加上margin-left和margin-right分别设为负的宽高的50%</p>\n"},{"layout":"post","title":"浅析模块化和seajs","date":"2015-09-20T07:23:12.000Z","_content":"\n### 模块化带来的问题\n\n前端交互的复杂和更新的频繁，对程序的可维护性和健壮性提出了更大的要求。基于本地文件的后端模块化，给了前端模块化很大的启示。模块化开发给维\n护和开发带来了很大的好处，每个功能按模块区分，不同功能通过接口沟通，各司其职，各行其道。那么模块化就要求一个功能一个模块，但是js语言本并没有模块化的功能，也无法声明模块的依赖，而且一个模块一个请求，这在分秒必争的浏览器显然是一个逆发展。总的来说，模块化需要解决以下问题：\n\n- 模块的声明定义和接口的导出\n- 模块的依赖机制\n- 资源的优化整合\n\n解决了以上问题，才能让模块化成为可能。\n\n### 如何模块化\n\n**模块的声明定义和接口的导出**\n\njs语言里本身不具备模块的功能，没关系，硬的没有，可以来软的。通过模拟实现模块的功能，以seajs为例，seajs的模块定义如下：\n```\ndefine(\"ModuleA\", function(require, exports){\n  var moduleB = require(\"ModuleB\");\n  return {\n    test: function(){\n      console.log(\"test\");\n    }\n  }\n})\n```\nseajs通过define函数实现模块定义功能，该函数实际上是定义了一个模块名称为ModuleA的模块，模块的内容为Factory函数，即回调函数。导出的接口导出是return的值，或者可以通过exports变量实现导出。\n\n**模块的依赖机制**\n\n模块的依赖指的是模块里面引用了别的模块，所依赖的模块与自身模块的关系维护。加载过的模块第二次再次require的时候怎么办？Factory会运行两次？答案是否定的，同一个模块不该运行两次。js里如何发现依赖？在seajs里是通过正则表达式解决的，seajs会将factory函数tostring一下，拿到函数体，再进行正则匹配拿到依赖的模块，然后去加载依赖的模块，如果发现依赖的模块也有依赖，则再起加载~递归地加载。上面的ModuleA加载的时候发现ModuleB需要先加载，则会发起一个ModuleB的加载，在浏览器里seajs是通过生产script标签进行js加载的，监听其onload事件来执行模块注册，每次加载过的模块都会保存一份到seajs.cache里，每次加载都会先判断cache里有没有，没则发起http去获取模块代码，有则看看模块是否已经运行过factory函数，如没有则运行并返回结果，有则直接返回结果。seajs3.0里做了一个优化，每次用script加载完后，都会删除该dom节点以减轻dom树的内存压力。（ps：seajs里是允许循环依赖的，不过并没有解决循环依赖，不过循环依赖这种逻辑上有问题的组织方式本就不该存在。）\n\n模块既然是一个文件，那seajs里是如何标识一个模块的呢？也就是它的模块唯一标识的管理。seajs由于是以网络文件为基础的，它在请求每个模块的时候都会生给模块分配一个id，对与define定义的模块，会加上网络域名的前缀，如果模块本身没有id，则以模块的路径为基础如文件/static/modules/init/init.js的文件，若define的时候没有指定id，直接define(factory)，则它会以http://xxx.com:xx/static/modules/init/init.js作为模块的唯一id。值得一提的是，seajs的默认当前工作空间为sea.js文件的当前目录。也就是说require(\"jquery\")的时候，如果jquery不是iyige别名，则它会去sea.js的当前目录里去找jquery文件。\n\n**资源的优化整合**\n\n模块化增加了文件的数量，而且由于seajs以网络文件为基础，本地找不到模块的时候，就回去加载网络上的模块，所以这也给打包带来很大的挑战。把多个模块合并成一个大文件，这也就放弃了模块当个加载的机会。那一个文件有多个模块的时候，怎么去区分一个模块呢？这就只能通过模块的id了，也就是说构建的时候需要动态生成模块的id。所以合并之前要做一个模块id提取和依赖提取的操作。\n\n\n### seajs的误区\n\nseajs里有几个地方很容易让人引起误解。\n1. seajs是异步加载文件，但默认不是按需加载，模块只要require了，就会被加载。所以我们会看到network里有一些模块我们并没有用到，但是它第一次的时候已经加载了。要让其不加载，做到按需加载，只能调用require.async了。\n2. require函数并不会发起模块文件的请求，模块文件的请求时在入口函数时，通过对factory进行正则匹配的时候发起的；require只是会触发factory的执行和获取接口。\n\n\n> 模块化是大势所趋，但seajs的模块化方案只是js的模块化，并不是完全彻底的前端模块化。相比而言react的模块化更加彻底和完整。但是seajs的模块化可以借助构建工具完善。\n\n\n\n","source":"_posts/2015-09-20-seajs-source.markdown","raw":"---\nlayout: post\ntitle:  \"浅析模块化和seajs\"\ndate:   2015-09-20 15:23:12\ncategories: \"基础知识\"\n---\n\n### 模块化带来的问题\n\n前端交互的复杂和更新的频繁，对程序的可维护性和健壮性提出了更大的要求。基于本地文件的后端模块化，给了前端模块化很大的启示。模块化开发给维\n护和开发带来了很大的好处，每个功能按模块区分，不同功能通过接口沟通，各司其职，各行其道。那么模块化就要求一个功能一个模块，但是js语言本并没有模块化的功能，也无法声明模块的依赖，而且一个模块一个请求，这在分秒必争的浏览器显然是一个逆发展。总的来说，模块化需要解决以下问题：\n\n- 模块的声明定义和接口的导出\n- 模块的依赖机制\n- 资源的优化整合\n\n解决了以上问题，才能让模块化成为可能。\n\n### 如何模块化\n\n**模块的声明定义和接口的导出**\n\njs语言里本身不具备模块的功能，没关系，硬的没有，可以来软的。通过模拟实现模块的功能，以seajs为例，seajs的模块定义如下：\n```\ndefine(\"ModuleA\", function(require, exports){\n  var moduleB = require(\"ModuleB\");\n  return {\n    test: function(){\n      console.log(\"test\");\n    }\n  }\n})\n```\nseajs通过define函数实现模块定义功能，该函数实际上是定义了一个模块名称为ModuleA的模块，模块的内容为Factory函数，即回调函数。导出的接口导出是return的值，或者可以通过exports变量实现导出。\n\n**模块的依赖机制**\n\n模块的依赖指的是模块里面引用了别的模块，所依赖的模块与自身模块的关系维护。加载过的模块第二次再次require的时候怎么办？Factory会运行两次？答案是否定的，同一个模块不该运行两次。js里如何发现依赖？在seajs里是通过正则表达式解决的，seajs会将factory函数tostring一下，拿到函数体，再进行正则匹配拿到依赖的模块，然后去加载依赖的模块，如果发现依赖的模块也有依赖，则再起加载~递归地加载。上面的ModuleA加载的时候发现ModuleB需要先加载，则会发起一个ModuleB的加载，在浏览器里seajs是通过生产script标签进行js加载的，监听其onload事件来执行模块注册，每次加载过的模块都会保存一份到seajs.cache里，每次加载都会先判断cache里有没有，没则发起http去获取模块代码，有则看看模块是否已经运行过factory函数，如没有则运行并返回结果，有则直接返回结果。seajs3.0里做了一个优化，每次用script加载完后，都会删除该dom节点以减轻dom树的内存压力。（ps：seajs里是允许循环依赖的，不过并没有解决循环依赖，不过循环依赖这种逻辑上有问题的组织方式本就不该存在。）\n\n模块既然是一个文件，那seajs里是如何标识一个模块的呢？也就是它的模块唯一标识的管理。seajs由于是以网络文件为基础的，它在请求每个模块的时候都会生给模块分配一个id，对与define定义的模块，会加上网络域名的前缀，如果模块本身没有id，则以模块的路径为基础如文件/static/modules/init/init.js的文件，若define的时候没有指定id，直接define(factory)，则它会以http://xxx.com:xx/static/modules/init/init.js作为模块的唯一id。值得一提的是，seajs的默认当前工作空间为sea.js文件的当前目录。也就是说require(\"jquery\")的时候，如果jquery不是iyige别名，则它会去sea.js的当前目录里去找jquery文件。\n\n**资源的优化整合**\n\n模块化增加了文件的数量，而且由于seajs以网络文件为基础，本地找不到模块的时候，就回去加载网络上的模块，所以这也给打包带来很大的挑战。把多个模块合并成一个大文件，这也就放弃了模块当个加载的机会。那一个文件有多个模块的时候，怎么去区分一个模块呢？这就只能通过模块的id了，也就是说构建的时候需要动态生成模块的id。所以合并之前要做一个模块id提取和依赖提取的操作。\n\n\n### seajs的误区\n\nseajs里有几个地方很容易让人引起误解。\n1. seajs是异步加载文件，但默认不是按需加载，模块只要require了，就会被加载。所以我们会看到network里有一些模块我们并没有用到，但是它第一次的时候已经加载了。要让其不加载，做到按需加载，只能调用require.async了。\n2. require函数并不会发起模块文件的请求，模块文件的请求时在入口函数时，通过对factory进行正则匹配的时候发起的；require只是会触发factory的执行和获取接口。\n\n\n> 模块化是大势所趋，但seajs的模块化方案只是js的模块化，并不是完全彻底的前端模块化。相比而言react的模块化更加彻底和完整。但是seajs的模块化可以借助构建工具完善。\n\n\n\n","slug":"2015-09-20-seajs-source","published":1,"updated":"2018-05-26T16:02:28.321Z","comments":1,"photos":[],"link":"","_id":"cjjoevofm000d0gupfa8e27z6","content":"<h3 id=\"模块化带来的问题\"><a href=\"#模块化带来的问题\" class=\"headerlink\" title=\"模块化带来的问题\"></a>模块化带来的问题</h3><p>前端交互的复杂和更新的频繁，对程序的可维护性和健壮性提出了更大的要求。基于本地文件的后端模块化，给了前端模块化很大的启示。模块化开发给维<br>护和开发带来了很大的好处，每个功能按模块区分，不同功能通过接口沟通，各司其职，各行其道。那么模块化就要求一个功能一个模块，但是js语言本并没有模块化的功能，也无法声明模块的依赖，而且一个模块一个请求，这在分秒必争的浏览器显然是一个逆发展。总的来说，模块化需要解决以下问题：</p>\n<ul>\n<li>模块的声明定义和接口的导出</li>\n<li>模块的依赖机制</li>\n<li>资源的优化整合</li>\n</ul>\n<p>解决了以上问题，才能让模块化成为可能。</p>\n<h3 id=\"如何模块化\"><a href=\"#如何模块化\" class=\"headerlink\" title=\"如何模块化\"></a>如何模块化</h3><p><strong>模块的声明定义和接口的导出</strong></p>\n<p>js语言里本身不具备模块的功能，没关系，硬的没有，可以来软的。通过模拟实现模块的功能，以seajs为例，seajs的模块定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(&quot;ModuleA&quot;, function(require, exports)&#123;</span><br><span class=\"line\">  var moduleB = require(&quot;ModuleB&quot;);</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    test: function()&#123;</span><br><span class=\"line\">      console.log(&quot;test&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>seajs通过define函数实现模块定义功能，该函数实际上是定义了一个模块名称为ModuleA的模块，模块的内容为Factory函数，即回调函数。导出的接口导出是return的值，或者可以通过exports变量实现导出。</p>\n<p><strong>模块的依赖机制</strong></p>\n<p>模块的依赖指的是模块里面引用了别的模块，所依赖的模块与自身模块的关系维护。加载过的模块第二次再次require的时候怎么办？Factory会运行两次？答案是否定的，同一个模块不该运行两次。js里如何发现依赖？在seajs里是通过正则表达式解决的，seajs会将factory函数tostring一下，拿到函数体，再进行正则匹配拿到依赖的模块，然后去加载依赖的模块，如果发现依赖的模块也有依赖，则再起加载~递归地加载。上面的ModuleA加载的时候发现ModuleB需要先加载，则会发起一个ModuleB的加载，在浏览器里seajs是通过生产script标签进行js加载的，监听其onload事件来执行模块注册，每次加载过的模块都会保存一份到seajs.cache里，每次加载都会先判断cache里有没有，没则发起http去获取模块代码，有则看看模块是否已经运行过factory函数，如没有则运行并返回结果，有则直接返回结果。seajs3.0里做了一个优化，每次用script加载完后，都会删除该dom节点以减轻dom树的内存压力。（ps：seajs里是允许循环依赖的，不过并没有解决循环依赖，不过循环依赖这种逻辑上有问题的组织方式本就不该存在。）</p>\n<p>模块既然是一个文件，那seajs里是如何标识一个模块的呢？也就是它的模块唯一标识的管理。seajs由于是以网络文件为基础的，它在请求每个模块的时候都会生给模块分配一个id，对与define定义的模块，会加上网络域名的前缀，如果模块本身没有id，则以模块的路径为基础如文件/static/modules/init/init.js的文件，若define的时候没有指定id，直接define(factory)，则它会以<a href=\"http://xxx.com:xx/static/modules/init/init.js作为模块的唯一id。值得一提的是，seajs的默认当前工作空间为sea.js文件的当前目录。也就是说require(&quot;jquery&quot;)的时候，如果jquery不是iyige别名，则它会去sea.js的当前目录里去找jquery文件。\" target=\"_blank\" rel=\"external\">http://xxx.com:xx/static/modules/init/init.js作为模块的唯一id。值得一提的是，seajs的默认当前工作空间为sea.js文件的当前目录。也就是说require(&quot;jquery&quot;)的时候，如果jquery不是iyige别名，则它会去sea.js的当前目录里去找jquery文件。</a></p>\n<p><strong>资源的优化整合</strong></p>\n<p>模块化增加了文件的数量，而且由于seajs以网络文件为基础，本地找不到模块的时候，就回去加载网络上的模块，所以这也给打包带来很大的挑战。把多个模块合并成一个大文件，这也就放弃了模块当个加载的机会。那一个文件有多个模块的时候，怎么去区分一个模块呢？这就只能通过模块的id了，也就是说构建的时候需要动态生成模块的id。所以合并之前要做一个模块id提取和依赖提取的操作。</p>\n<h3 id=\"seajs的误区\"><a href=\"#seajs的误区\" class=\"headerlink\" title=\"seajs的误区\"></a>seajs的误区</h3><p>seajs里有几个地方很容易让人引起误解。</p>\n<ol>\n<li>seajs是异步加载文件，但默认不是按需加载，模块只要require了，就会被加载。所以我们会看到network里有一些模块我们并没有用到，但是它第一次的时候已经加载了。要让其不加载，做到按需加载，只能调用require.async了。</li>\n<li>require函数并不会发起模块文件的请求，模块文件的请求时在入口函数时，通过对factory进行正则匹配的时候发起的；require只是会触发factory的执行和获取接口。</li>\n</ol>\n<blockquote>\n<p>模块化是大势所趋，但seajs的模块化方案只是js的模块化，并不是完全彻底的前端模块化。相比而言react的模块化更加彻底和完整。但是seajs的模块化可以借助构建工具完善。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"模块化带来的问题\"><a href=\"#模块化带来的问题\" class=\"headerlink\" title=\"模块化带来的问题\"></a>模块化带来的问题</h3><p>前端交互的复杂和更新的频繁，对程序的可维护性和健壮性提出了更大的要求。基于本地文件的后端模块化，给了前端模块化很大的启示。模块化开发给维<br>护和开发带来了很大的好处，每个功能按模块区分，不同功能通过接口沟通，各司其职，各行其道。那么模块化就要求一个功能一个模块，但是js语言本并没有模块化的功能，也无法声明模块的依赖，而且一个模块一个请求，这在分秒必争的浏览器显然是一个逆发展。总的来说，模块化需要解决以下问题：</p>\n<ul>\n<li>模块的声明定义和接口的导出</li>\n<li>模块的依赖机制</li>\n<li>资源的优化整合</li>\n</ul>\n<p>解决了以上问题，才能让模块化成为可能。</p>\n<h3 id=\"如何模块化\"><a href=\"#如何模块化\" class=\"headerlink\" title=\"如何模块化\"></a>如何模块化</h3><p><strong>模块的声明定义和接口的导出</strong></p>\n<p>js语言里本身不具备模块的功能，没关系，硬的没有，可以来软的。通过模拟实现模块的功能，以seajs为例，seajs的模块定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(&quot;ModuleA&quot;, function(require, exports)&#123;</span><br><span class=\"line\">  var moduleB = require(&quot;ModuleB&quot;);</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    test: function()&#123;</span><br><span class=\"line\">      console.log(&quot;test&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>seajs通过define函数实现模块定义功能，该函数实际上是定义了一个模块名称为ModuleA的模块，模块的内容为Factory函数，即回调函数。导出的接口导出是return的值，或者可以通过exports变量实现导出。</p>\n<p><strong>模块的依赖机制</strong></p>\n<p>模块的依赖指的是模块里面引用了别的模块，所依赖的模块与自身模块的关系维护。加载过的模块第二次再次require的时候怎么办？Factory会运行两次？答案是否定的，同一个模块不该运行两次。js里如何发现依赖？在seajs里是通过正则表达式解决的，seajs会将factory函数tostring一下，拿到函数体，再进行正则匹配拿到依赖的模块，然后去加载依赖的模块，如果发现依赖的模块也有依赖，则再起加载~递归地加载。上面的ModuleA加载的时候发现ModuleB需要先加载，则会发起一个ModuleB的加载，在浏览器里seajs是通过生产script标签进行js加载的，监听其onload事件来执行模块注册，每次加载过的模块都会保存一份到seajs.cache里，每次加载都会先判断cache里有没有，没则发起http去获取模块代码，有则看看模块是否已经运行过factory函数，如没有则运行并返回结果，有则直接返回结果。seajs3.0里做了一个优化，每次用script加载完后，都会删除该dom节点以减轻dom树的内存压力。（ps：seajs里是允许循环依赖的，不过并没有解决循环依赖，不过循环依赖这种逻辑上有问题的组织方式本就不该存在。）</p>\n<p>模块既然是一个文件，那seajs里是如何标识一个模块的呢？也就是它的模块唯一标识的管理。seajs由于是以网络文件为基础的，它在请求每个模块的时候都会生给模块分配一个id，对与define定义的模块，会加上网络域名的前缀，如果模块本身没有id，则以模块的路径为基础如文件/static/modules/init/init.js的文件，若define的时候没有指定id，直接define(factory)，则它会以<a href=\"http://xxx.com:xx/static/modules/init/init.js作为模块的唯一id。值得一提的是，seajs的默认当前工作空间为sea.js文件的当前目录。也就是说require(&quot;jquery&quot;)的时候，如果jquery不是iyige别名，则它会去sea.js的当前目录里去找jquery文件。\">http://xxx.com:xx/static/modules/init/init.js作为模块的唯一id。值得一提的是，seajs的默认当前工作空间为sea.js文件的当前目录。也就是说require(&quot;jquery&quot;)的时候，如果jquery不是iyige别名，则它会去sea.js的当前目录里去找jquery文件。</a></p>\n<p><strong>资源的优化整合</strong></p>\n<p>模块化增加了文件的数量，而且由于seajs以网络文件为基础，本地找不到模块的时候，就回去加载网络上的模块，所以这也给打包带来很大的挑战。把多个模块合并成一个大文件，这也就放弃了模块当个加载的机会。那一个文件有多个模块的时候，怎么去区分一个模块呢？这就只能通过模块的id了，也就是说构建的时候需要动态生成模块的id。所以合并之前要做一个模块id提取和依赖提取的操作。</p>\n<h3 id=\"seajs的误区\"><a href=\"#seajs的误区\" class=\"headerlink\" title=\"seajs的误区\"></a>seajs的误区</h3><p>seajs里有几个地方很容易让人引起误解。</p>\n<ol>\n<li>seajs是异步加载文件，但默认不是按需加载，模块只要require了，就会被加载。所以我们会看到network里有一些模块我们并没有用到，但是它第一次的时候已经加载了。要让其不加载，做到按需加载，只能调用require.async了。</li>\n<li>require函数并不会发起模块文件的请求，模块文件的请求时在入口函数时，通过对factory进行正则匹配的时候发起的；require只是会触发factory的执行和获取接口。</li>\n</ol>\n<blockquote>\n<p>模块化是大势所趋，但seajs的模块化方案只是js的模块化，并不是完全彻底的前端模块化。相比而言react的模块化更加彻底和完整。但是seajs的模块化可以借助构建工具完善。</p>\n</blockquote>\n"},{"layout":"post","title":"javascript模板","date":"2016-06-08T11:23:19.000Z","_content":"\n\n最早使用的js模板是这样子的\n\n```\nString.prototype.template = function(e, t) {\n  return this.replace(t || /\\${([^{}]*)}/g, function(t, r) {\n      return e[r] !== undefined && e[r] !== null  && e[r].toString() || \"\"\n    }\n  )\n}\n```\n\n主要是通过正则来匹配，替换数据，不足之处是不能嵌入js的语句，对于一些需要遍历输出的就略显蛋疼了！想起underscore的template和ejs的模板，于是去看了一下它们的实现，主要原理还是：把不需要js的当作字符串，把需要js执行的直接用js执行，通过动态创建函数，执行模板。具体实现如下：\n\n```\n<script type=\"text/template\" id=\"tplStr\">\n  <ul>\n       <% for(var i=0; i <users.length; i++) { %>\n\t    <li><a href=\"<%=users[i].url%>\"><%=users[i].name%></a></li>\n\t<% } %>\n   </ul>\n</script>\nfunction template(tplStr){\n   var result = \"var _ary =[]; with(data){_ary.push('\" + tplStr\n\t.replace(/[\\r|\\s|\\t]/ig, ' ')\n\t.replace(/<%=(.*?)%>/g, \"');_ary.push($1);_ary.push('\")\n\t.replace(/<%/g, \"');\")\n\t.replace(/%>/g, \";_ary.push('\")\n\t+ \"');}return _ary.join('')\";\n\n   var fun = new Function(\"data\", result);\n        return {\n\t\t  render: function(data){\n\t\t\tconsole.log(\"by function: \", fun.apply(data, arguments));\n\t\t   }\n\t\t}\n\t}\n```\n\n步骤如下：\n\n1. 前面加上 var _ary =[]; with(data){_ary.push('\n\n2. <%=users[i].url%>  替换成');_ary.push(users[i].url);_ary.push('\n\n3. <%  替换成  ');\n\n4. %>  替换成  ;_ary.push('\n\n5. 尾部加上');}return _ary.join('')\n\n\n\n这里需要用with来暂时改变作用域链，以避免数据对象未知引起的错误，通过with可以忽略顶级的数据变量。最后通过apply来执行函数，可以使this指向当前的数据。\n\n总的来说，难点在于如何把不变的当成字符串，需要就是执行的，让其直接执行。\n","source":"_posts/2016-06-08-javascript-template.markdown","raw":"---\nlayout: post\ntitle:  \"javascript模板\"\ndate:   2016-06-08 19:23:19\ncategories: \"基础知识\"\n---\n\n\n最早使用的js模板是这样子的\n\n```\nString.prototype.template = function(e, t) {\n  return this.replace(t || /\\${([^{}]*)}/g, function(t, r) {\n      return e[r] !== undefined && e[r] !== null  && e[r].toString() || \"\"\n    }\n  )\n}\n```\n\n主要是通过正则来匹配，替换数据，不足之处是不能嵌入js的语句，对于一些需要遍历输出的就略显蛋疼了！想起underscore的template和ejs的模板，于是去看了一下它们的实现，主要原理还是：把不需要js的当作字符串，把需要js执行的直接用js执行，通过动态创建函数，执行模板。具体实现如下：\n\n```\n<script type=\"text/template\" id=\"tplStr\">\n  <ul>\n       <% for(var i=0; i <users.length; i++) { %>\n\t    <li><a href=\"<%=users[i].url%>\"><%=users[i].name%></a></li>\n\t<% } %>\n   </ul>\n</script>\nfunction template(tplStr){\n   var result = \"var _ary =[]; with(data){_ary.push('\" + tplStr\n\t.replace(/[\\r|\\s|\\t]/ig, ' ')\n\t.replace(/<%=(.*?)%>/g, \"');_ary.push($1);_ary.push('\")\n\t.replace(/<%/g, \"');\")\n\t.replace(/%>/g, \";_ary.push('\")\n\t+ \"');}return _ary.join('')\";\n\n   var fun = new Function(\"data\", result);\n        return {\n\t\t  render: function(data){\n\t\t\tconsole.log(\"by function: \", fun.apply(data, arguments));\n\t\t   }\n\t\t}\n\t}\n```\n\n步骤如下：\n\n1. 前面加上 var _ary =[]; with(data){_ary.push('\n\n2. <%=users[i].url%>  替换成');_ary.push(users[i].url);_ary.push('\n\n3. <%  替换成  ');\n\n4. %>  替换成  ;_ary.push('\n\n5. 尾部加上');}return _ary.join('')\n\n\n\n这里需要用with来暂时改变作用域链，以避免数据对象未知引起的错误，通过with可以忽略顶级的数据变量。最后通过apply来执行函数，可以使this指向当前的数据。\n\n总的来说，难点在于如何把不变的当成字符串，需要就是执行的，让其直接执行。\n","slug":"2016-06-08-javascript-template","published":1,"updated":"2018-05-26T16:02:28.603Z","comments":1,"photos":[],"link":"","_id":"cjjoevofo000f0guplg2v78pi","content":"<p>最早使用的js模板是这样子的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String.prototype.template = function(e, t) &#123;</span><br><span class=\"line\">  return this.replace(t || /\\$&#123;([^&#123;&#125;]*)&#125;/g, function(t, r) &#123;</span><br><span class=\"line\">      return e[r] !== undefined &amp;&amp; e[r] !== null  &amp;&amp; e[r].toString() || &quot;&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主要是通过正则来匹配，替换数据，不足之处是不能嵌入js的语句，对于一些需要遍历输出的就略显蛋疼了！想起underscore的template和ejs的模板，于是去看了一下它们的实现，主要原理还是：把不需要js的当作字符串，把需要js执行的直接用js执行，通过动态创建函数，执行模板。具体实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/template&quot; id=&quot;tplStr&quot;&gt;</span><br><span class=\"line\">  &lt;ul&gt;</span><br><span class=\"line\">       &lt;% for(var i=0; i &lt;users.length; i++) &#123; %&gt;</span><br><span class=\"line\">\t    &lt;li&gt;&lt;a href=&quot;&lt;%=users[i].url%&gt;&quot;&gt;&lt;%=users[i].name%&gt;&lt;/a&gt;&lt;/li&gt;</span><br><span class=\"line\">\t&lt;% &#125; %&gt;</span><br><span class=\"line\">   &lt;/ul&gt;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">function template(tplStr)&#123;</span><br><span class=\"line\">   var result = &quot;var _ary =[]; with(data)&#123;_ary.push(&apos;&quot; + tplStr</span><br><span class=\"line\">\t.replace(/[\\r|\\s|\\t]/ig, &apos; &apos;)</span><br><span class=\"line\">\t.replace(/&lt;%=(.*?)%&gt;/g, &quot;&apos;);_ary.push($1);_ary.push(&apos;&quot;)</span><br><span class=\"line\">\t.replace(/&lt;%/g, &quot;&apos;);&quot;)</span><br><span class=\"line\">\t.replace(/%&gt;/g, &quot;;_ary.push(&apos;&quot;)</span><br><span class=\"line\">\t+ &quot;&apos;);&#125;return _ary.join(&apos;&apos;)&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">   var fun = new Function(&quot;data&quot;, result);</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">\t\t  render: function(data)&#123;</span><br><span class=\"line\">\t\t\tconsole.log(&quot;by function: &quot;, fun.apply(data, arguments));</span><br><span class=\"line\">\t\t   &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>步骤如下：</p>\n<ol>\n<li><p>前面加上 var _ary =[]; with(data){_ary.push(‘</p>\n</li>\n<li><p>&lt;%=users[i].url%&gt;  替换成’);_ary.push(users[i].url);_ary.push(‘</p>\n</li>\n<li><p>&lt;%  替换成  ‘);</p>\n</li>\n<li><p>%&gt;  替换成  ;_ary.push(‘</p>\n</li>\n<li><p>尾部加上’);}return _ary.join(‘’)</p>\n</li>\n</ol>\n<p>这里需要用with来暂时改变作用域链，以避免数据对象未知引起的错误，通过with可以忽略顶级的数据变量。最后通过apply来执行函数，可以使this指向当前的数据。</p>\n<p>总的来说，难点在于如何把不变的当成字符串，需要就是执行的，让其直接执行。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最早使用的js模板是这样子的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String.prototype.template = function(e, t) &#123;</span><br><span class=\"line\">  return this.replace(t || /\\$&#123;([^&#123;&#125;]*)&#125;/g, function(t, r) &#123;</span><br><span class=\"line\">      return e[r] !== undefined &amp;&amp; e[r] !== null  &amp;&amp; e[r].toString() || &quot;&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主要是通过正则来匹配，替换数据，不足之处是不能嵌入js的语句，对于一些需要遍历输出的就略显蛋疼了！想起underscore的template和ejs的模板，于是去看了一下它们的实现，主要原理还是：把不需要js的当作字符串，把需要js执行的直接用js执行，通过动态创建函数，执行模板。具体实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/template&quot; id=&quot;tplStr&quot;&gt;</span><br><span class=\"line\">  &lt;ul&gt;</span><br><span class=\"line\">       &lt;% for(var i=0; i &lt;users.length; i++) &#123; %&gt;</span><br><span class=\"line\">\t    &lt;li&gt;&lt;a href=&quot;&lt;%=users[i].url%&gt;&quot;&gt;&lt;%=users[i].name%&gt;&lt;/a&gt;&lt;/li&gt;</span><br><span class=\"line\">\t&lt;% &#125; %&gt;</span><br><span class=\"line\">   &lt;/ul&gt;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">function template(tplStr)&#123;</span><br><span class=\"line\">   var result = &quot;var _ary =[]; with(data)&#123;_ary.push(&apos;&quot; + tplStr</span><br><span class=\"line\">\t.replace(/[\\r|\\s|\\t]/ig, &apos; &apos;)</span><br><span class=\"line\">\t.replace(/&lt;%=(.*?)%&gt;/g, &quot;&apos;);_ary.push($1);_ary.push(&apos;&quot;)</span><br><span class=\"line\">\t.replace(/&lt;%/g, &quot;&apos;);&quot;)</span><br><span class=\"line\">\t.replace(/%&gt;/g, &quot;;_ary.push(&apos;&quot;)</span><br><span class=\"line\">\t+ &quot;&apos;);&#125;return _ary.join(&apos;&apos;)&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">   var fun = new Function(&quot;data&quot;, result);</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">\t\t  render: function(data)&#123;</span><br><span class=\"line\">\t\t\tconsole.log(&quot;by function: &quot;, fun.apply(data, arguments));</span><br><span class=\"line\">\t\t   &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>步骤如下：</p>\n<ol>\n<li><p>前面加上 var _ary =[]; with(data){_ary.push(‘</p>\n</li>\n<li><p>&lt;%=users[i].url%&gt;  替换成’);_ary.push(users[i].url);_ary.push(‘</p>\n</li>\n<li><p>&lt;%  替换成  ‘);</p>\n</li>\n<li><p>%&gt;  替换成  ;_ary.push(‘</p>\n</li>\n<li><p>尾部加上’);}return _ary.join(‘’)</p>\n</li>\n</ol>\n<p>这里需要用with来暂时改变作用域链，以避免数据对象未知引起的错误，通过with可以忽略顶级的数据变量。最后通过apply来执行函数，可以使this指向当前的数据。</p>\n<p>总的来说，难点在于如何把不变的当成字符串，需要就是执行的，让其直接执行。</p>\n"},{"layout":"post","title":"环形统计图","date":"2017-02-16T11:23:19.000Z","_content":"\n#环形图的生成\n\n最近遇到一个环形图的需求，图形的线是圆角的，最开始想用highchart，无奈不支持圆角，于是乎，另辟蹊径。经历了css3-->canvas-->graphics的历程。\n## graphics\n是一款js的svg库，里面的接口比canvas的友好。而且svg的兼容性还不赖。最开始想着椭圆的进度如何画，后来发现直接用弧线比较直接快捷。代码如下：\n\ndemo [http://miniwa.com.cn/apps/pie/index.html]\n\n```\n\nvar stage = acgraph.create('container');\n    var bigCircle = stage.circle(180, 180, 180);//最外面的大圆\n\n    bigCircle.fill('#ddd').stroke('#ddd');\n\n    stage.path()\n        //为了实现圆角用弧线变宽最为进度\n        .circularArc(180, 180, 160, 160, -90, 90)\n        .stroke({\n            color: '#129090',       //颜色\n            thickness: 40,          //宽度\n            lineCap: \"ROUND\"        //圆角\n        })\n\n\n    var smallCircle = stage.circle(180, 180, 140);//里面的小圆\n    smallCircle.fill('#fff').stroke('#ddd'); \n    \n```\n","source":"_posts/2016-06-08-pie.markdown","raw":"---\nlayout: post\ntitle:  \"环形统计图\"\ndate:   2017-02-16 19:23:19\ncategories: \"基础知识\"\n---\n\n#环形图的生成\n\n最近遇到一个环形图的需求，图形的线是圆角的，最开始想用highchart，无奈不支持圆角，于是乎，另辟蹊径。经历了css3-->canvas-->graphics的历程。\n## graphics\n是一款js的svg库，里面的接口比canvas的友好。而且svg的兼容性还不赖。最开始想着椭圆的进度如何画，后来发现直接用弧线比较直接快捷。代码如下：\n\ndemo [http://miniwa.com.cn/apps/pie/index.html]\n\n```\n\nvar stage = acgraph.create('container');\n    var bigCircle = stage.circle(180, 180, 180);//最外面的大圆\n\n    bigCircle.fill('#ddd').stroke('#ddd');\n\n    stage.path()\n        //为了实现圆角用弧线变宽最为进度\n        .circularArc(180, 180, 160, 160, -90, 90)\n        .stroke({\n            color: '#129090',       //颜色\n            thickness: 40,          //宽度\n            lineCap: \"ROUND\"        //圆角\n        })\n\n\n    var smallCircle = stage.circle(180, 180, 140);//里面的小圆\n    smallCircle.fill('#fff').stroke('#ddd'); \n    \n```\n","slug":"2016-06-08-pie","published":1,"updated":"2018-05-26T16:02:28.618Z","comments":1,"photos":[],"link":"","_id":"cjjoevofr000i0gupls0xgpol","content":"<p>#环形图的生成</p>\n<p>最近遇到一个环形图的需求，图形的线是圆角的，最开始想用highchart，无奈不支持圆角，于是乎，另辟蹊径。经历了css3–&gt;canvas–&gt;graphics的历程。</p>\n<h2 id=\"graphics\"><a href=\"#graphics\" class=\"headerlink\" title=\"graphics\"></a>graphics</h2><p>是一款js的svg库，里面的接口比canvas的友好。而且svg的兼容性还不赖。最开始想着椭圆的进度如何画，后来发现直接用弧线比较直接快捷。代码如下：</p>\n<p>demo [<a href=\"http://miniwa.com.cn/apps/pie/index.html]\">http://miniwa.com.cn/apps/pie/index.html]</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var stage = acgraph.create(&apos;container&apos;);</span><br><span class=\"line\">    var bigCircle = stage.circle(180, 180, 180);//最外面的大圆</span><br><span class=\"line\"></span><br><span class=\"line\">    bigCircle.fill(&apos;#ddd&apos;).stroke(&apos;#ddd&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    stage.path()</span><br><span class=\"line\">        //为了实现圆角用弧线变宽最为进度</span><br><span class=\"line\">        .circularArc(180, 180, 160, 160, -90, 90)</span><br><span class=\"line\">        .stroke(&#123;</span><br><span class=\"line\">            color: &apos;#129090&apos;,       //颜色</span><br><span class=\"line\">            thickness: 40,          //宽度</span><br><span class=\"line\">            lineCap: &quot;ROUND&quot;        //圆角</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    var smallCircle = stage.circle(180, 180, 140);//里面的小圆</span><br><span class=\"line\">    smallCircle.fill(&apos;#fff&apos;).stroke(&apos;#ddd&apos;);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>#环形图的生成</p>\n<p>最近遇到一个环形图的需求，图形的线是圆角的，最开始想用highchart，无奈不支持圆角，于是乎，另辟蹊径。经历了css3–&gt;canvas–&gt;graphics的历程。</p>\n<h2 id=\"graphics\"><a href=\"#graphics\" class=\"headerlink\" title=\"graphics\"></a>graphics</h2><p>是一款js的svg库，里面的接口比canvas的友好。而且svg的兼容性还不赖。最开始想着椭圆的进度如何画，后来发现直接用弧线比较直接快捷。代码如下：</p>\n<p>demo [<a href=\"http://miniwa.com.cn/apps/pie/index.html]\">http://miniwa.com.cn/apps/pie/index.html]</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var stage = acgraph.create(&apos;container&apos;);</span><br><span class=\"line\">    var bigCircle = stage.circle(180, 180, 180);//最外面的大圆</span><br><span class=\"line\"></span><br><span class=\"line\">    bigCircle.fill(&apos;#ddd&apos;).stroke(&apos;#ddd&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    stage.path()</span><br><span class=\"line\">        //为了实现圆角用弧线变宽最为进度</span><br><span class=\"line\">        .circularArc(180, 180, 160, 160, -90, 90)</span><br><span class=\"line\">        .stroke(&#123;</span><br><span class=\"line\">            color: &apos;#129090&apos;,       //颜色</span><br><span class=\"line\">            thickness: 40,          //宽度</span><br><span class=\"line\">            lineCap: &quot;ROUND&quot;        //圆角</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    var smallCircle = stage.circle(180, 180, 140);//里面的小圆</span><br><span class=\"line\">    smallCircle.fill(&apos;#fff&apos;).stroke(&apos;#ddd&apos;);</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"vue-router的使用","date":"2017-08-18T12:23:19.000Z","_content":"\nvue-router作为一个官方的路由组件，是应用开发的必备神器。比较突出的有以下几点：\n- 提供了视图渲染的详尽钩子、和路由的携带信息meta\n- 可以方便地切换history模式和hash模式\n- 在视图组件里可以方便地使用路由信息和路由对象\n- 支持路由嵌套，可以拿到路由的匹配路径方便显示激活菜单\n- 组件化的调用方式route-link和route-view，并自动关联\n- 提供了常用方法的封装如：back, go, redirect\n\n如此优秀的组件，下面我们来看看怎么使用。第一步，肯定是初始化了：\n\n```\n// 注入组件\nVue.use(Router)\nexport default new Router({\n    mode: 'history',  // history模式，看着像活生生的后端渲染\n    routes: [\n        {\n            path: '/view/index',    //路径\n            name: 'index',  // 别名，通过别名跳转可以避免url变更需要修改多处地方\n            component: Index    // 对应的视图组件\n        }\n    ]\n})\n```\n\n想成为一个优秀的组件，这样人性化的初始方式是必不可少的了，而它更强大的地方在于，可以支持redirect配置，如果你想把一个路由重定向到另外一个地方，可以这样子\n\n```\nexport default new Router({\n    mode: 'history',  // history模式，看着像活生生的后端渲染\n    routes: [\n        {\n            path: '/view/index',\n            name: 'index',\n            redirect: {name: 'xxxxx'}\n        }\n    ]\n})\n```\n\n路由的嵌套如下所示：\n\n```\nexport default new Router({\n    mode: 'history',  // history模式，看着像活生生的后端渲染\n    routes: [\n        {\n            path: '/view/index',\n            name: 'index',\n            component： Index,\n            children: [\n                path: 'test',\n                component： Test\n            ]\n        }\n    ]\n})\n```\n\n路由嵌套需要注意的地方有两个：\n- 上面栗子中children的path实际为 /view/index/test，如果children的path以斜杠开头，则表示为绝对路径，不收父的path影响\n- 嵌套路由是一个新的视图，不会替换掉父视图；Index里必须包含一个route-view组件，否则不会渲染Test\n\n需要注意的是如果path有相应的route-link，那视图激活的时候也会在该route-link下自动增加active的class，可以利用这个显示激活的菜单。\n如果这个不能满足，也可以根据route的matched属性，该属性会记录当前所有已匹配的路由。如上面这个例子的/view/index/test，matched属性会有两个路由信息'/view/index'和'/view/index/test'，\n根据这个可以把一级和二级的菜单也激活起来\n\n\n在视图的component里，可以通过this.$route访问当前路由的数据信息，this.$router访问路由封装的方法。这两个对象可以很方便地操作页面的跳转和获取页面的参数\n\nthis.$route常用的参数如下：\n- params 记录路径参数\n- query 记录search参数\n- meta 记录路由自定义的元信息\n- name 当前路由的别名\n- path 当前路由的路径\n\nthis.$router常用方法：\n- push 路由跳转，并压入历史的堆栈\n- replace 路由替换，不会压入历史堆栈，也就是说back的时候，会忽略掉\n- back 返回\n- redirect 重定向\n\n上面的push和replace，redirect都可以写到name，params，query等参数\n\n\n\n总的来说，vue router是一个用起来十分顺手和顺心的组件。唯一遇到坑的是在微信浏览器里，微信浏览器对history支持不友好，可以切换路由哦，但是不会改变url。其实这也不能怪vue router，它也是有心无力。\n","source":"_posts/2017-08-18-vue-router.markdown","raw":"---\nlayout: post\ntitle:  \"vue-router的使用\"\ndate:   2017-08-18 20:23:19\ncategories: \"基础知识\"\n---\n\nvue-router作为一个官方的路由组件，是应用开发的必备神器。比较突出的有以下几点：\n- 提供了视图渲染的详尽钩子、和路由的携带信息meta\n- 可以方便地切换history模式和hash模式\n- 在视图组件里可以方便地使用路由信息和路由对象\n- 支持路由嵌套，可以拿到路由的匹配路径方便显示激活菜单\n- 组件化的调用方式route-link和route-view，并自动关联\n- 提供了常用方法的封装如：back, go, redirect\n\n如此优秀的组件，下面我们来看看怎么使用。第一步，肯定是初始化了：\n\n```\n// 注入组件\nVue.use(Router)\nexport default new Router({\n    mode: 'history',  // history模式，看着像活生生的后端渲染\n    routes: [\n        {\n            path: '/view/index',    //路径\n            name: 'index',  // 别名，通过别名跳转可以避免url变更需要修改多处地方\n            component: Index    // 对应的视图组件\n        }\n    ]\n})\n```\n\n想成为一个优秀的组件，这样人性化的初始方式是必不可少的了，而它更强大的地方在于，可以支持redirect配置，如果你想把一个路由重定向到另外一个地方，可以这样子\n\n```\nexport default new Router({\n    mode: 'history',  // history模式，看着像活生生的后端渲染\n    routes: [\n        {\n            path: '/view/index',\n            name: 'index',\n            redirect: {name: 'xxxxx'}\n        }\n    ]\n})\n```\n\n路由的嵌套如下所示：\n\n```\nexport default new Router({\n    mode: 'history',  // history模式，看着像活生生的后端渲染\n    routes: [\n        {\n            path: '/view/index',\n            name: 'index',\n            component： Index,\n            children: [\n                path: 'test',\n                component： Test\n            ]\n        }\n    ]\n})\n```\n\n路由嵌套需要注意的地方有两个：\n- 上面栗子中children的path实际为 /view/index/test，如果children的path以斜杠开头，则表示为绝对路径，不收父的path影响\n- 嵌套路由是一个新的视图，不会替换掉父视图；Index里必须包含一个route-view组件，否则不会渲染Test\n\n需要注意的是如果path有相应的route-link，那视图激活的时候也会在该route-link下自动增加active的class，可以利用这个显示激活的菜单。\n如果这个不能满足，也可以根据route的matched属性，该属性会记录当前所有已匹配的路由。如上面这个例子的/view/index/test，matched属性会有两个路由信息'/view/index'和'/view/index/test'，\n根据这个可以把一级和二级的菜单也激活起来\n\n\n在视图的component里，可以通过this.$route访问当前路由的数据信息，this.$router访问路由封装的方法。这两个对象可以很方便地操作页面的跳转和获取页面的参数\n\nthis.$route常用的参数如下：\n- params 记录路径参数\n- query 记录search参数\n- meta 记录路由自定义的元信息\n- name 当前路由的别名\n- path 当前路由的路径\n\nthis.$router常用方法：\n- push 路由跳转，并压入历史的堆栈\n- replace 路由替换，不会压入历史堆栈，也就是说back的时候，会忽略掉\n- back 返回\n- redirect 重定向\n\n上面的push和replace，redirect都可以写到name，params，query等参数\n\n\n\n总的来说，vue router是一个用起来十分顺手和顺心的组件。唯一遇到坑的是在微信浏览器里，微信浏览器对history支持不友好，可以切换路由哦，但是不会改变url。其实这也不能怪vue router，它也是有心无力。\n","slug":"2017-08-18-vue-router","published":1,"updated":"2018-05-26T16:02:28.650Z","comments":1,"photos":[],"link":"","_id":"cjjoevofu000k0gupxlkwppip","content":"<p>vue-router作为一个官方的路由组件，是应用开发的必备神器。比较突出的有以下几点：</p>\n<ul>\n<li>提供了视图渲染的详尽钩子、和路由的携带信息meta</li>\n<li>可以方便地切换history模式和hash模式</li>\n<li>在视图组件里可以方便地使用路由信息和路由对象</li>\n<li>支持路由嵌套，可以拿到路由的匹配路径方便显示激活菜单</li>\n<li>组件化的调用方式route-link和route-view，并自动关联</li>\n<li>提供了常用方法的封装如：back, go, redirect</li>\n</ul>\n<p>如此优秀的组件，下面我们来看看怎么使用。第一步，肯定是初始化了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 注入组件</span><br><span class=\"line\">Vue.use(Router)</span><br><span class=\"line\">export default new Router(&#123;</span><br><span class=\"line\">    mode: &apos;history&apos;,  // history模式，看着像活生生的后端渲染</span><br><span class=\"line\">    routes: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            path: &apos;/view/index&apos;,    //路径</span><br><span class=\"line\">            name: &apos;index&apos;,  // 别名，通过别名跳转可以避免url变更需要修改多处地方</span><br><span class=\"line\">            component: Index    // 对应的视图组件</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>想成为一个优秀的组件，这样人性化的初始方式是必不可少的了，而它更强大的地方在于，可以支持redirect配置，如果你想把一个路由重定向到另外一个地方，可以这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default new Router(&#123;</span><br><span class=\"line\">    mode: &apos;history&apos;,  // history模式，看着像活生生的后端渲染</span><br><span class=\"line\">    routes: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            path: &apos;/view/index&apos;,</span><br><span class=\"line\">            name: &apos;index&apos;,</span><br><span class=\"line\">            redirect: &#123;name: &apos;xxxxx&apos;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>路由的嵌套如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default new Router(&#123;</span><br><span class=\"line\">    mode: &apos;history&apos;,  // history模式，看着像活生生的后端渲染</span><br><span class=\"line\">    routes: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            path: &apos;/view/index&apos;,</span><br><span class=\"line\">            name: &apos;index&apos;,</span><br><span class=\"line\">            component： Index,</span><br><span class=\"line\">            children: [</span><br><span class=\"line\">                path: &apos;test&apos;,</span><br><span class=\"line\">                component： Test</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>路由嵌套需要注意的地方有两个：</p>\n<ul>\n<li>上面栗子中children的path实际为 /view/index/test，如果children的path以斜杠开头，则表示为绝对路径，不收父的path影响</li>\n<li>嵌套路由是一个新的视图，不会替换掉父视图；Index里必须包含一个route-view组件，否则不会渲染Test</li>\n</ul>\n<p>需要注意的是如果path有相应的route-link，那视图激活的时候也会在该route-link下自动增加active的class，可以利用这个显示激活的菜单。<br>如果这个不能满足，也可以根据route的matched属性，该属性会记录当前所有已匹配的路由。如上面这个例子的/view/index/test，matched属性会有两个路由信息’/view/index’和’/view/index/test’，<br>根据这个可以把一级和二级的菜单也激活起来</p>\n<p>在视图的component里，可以通过this.$route访问当前路由的数据信息，this.$router访问路由封装的方法。这两个对象可以很方便地操作页面的跳转和获取页面的参数</p>\n<p>this.$route常用的参数如下：</p>\n<ul>\n<li>params 记录路径参数</li>\n<li>query 记录search参数</li>\n<li>meta 记录路由自定义的元信息</li>\n<li>name 当前路由的别名</li>\n<li>path 当前路由的路径</li>\n</ul>\n<p>this.$router常用方法：</p>\n<ul>\n<li>push 路由跳转，并压入历史的堆栈</li>\n<li>replace 路由替换，不会压入历史堆栈，也就是说back的时候，会忽略掉</li>\n<li>back 返回</li>\n<li>redirect 重定向</li>\n</ul>\n<p>上面的push和replace，redirect都可以写到name，params，query等参数</p>\n<p>总的来说，vue router是一个用起来十分顺手和顺心的组件。唯一遇到坑的是在微信浏览器里，微信浏览器对history支持不友好，可以切换路由哦，但是不会改变url。其实这也不能怪vue router，它也是有心无力。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>vue-router作为一个官方的路由组件，是应用开发的必备神器。比较突出的有以下几点：</p>\n<ul>\n<li>提供了视图渲染的详尽钩子、和路由的携带信息meta</li>\n<li>可以方便地切换history模式和hash模式</li>\n<li>在视图组件里可以方便地使用路由信息和路由对象</li>\n<li>支持路由嵌套，可以拿到路由的匹配路径方便显示激活菜单</li>\n<li>组件化的调用方式route-link和route-view，并自动关联</li>\n<li>提供了常用方法的封装如：back, go, redirect</li>\n</ul>\n<p>如此优秀的组件，下面我们来看看怎么使用。第一步，肯定是初始化了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 注入组件</span><br><span class=\"line\">Vue.use(Router)</span><br><span class=\"line\">export default new Router(&#123;</span><br><span class=\"line\">    mode: &apos;history&apos;,  // history模式，看着像活生生的后端渲染</span><br><span class=\"line\">    routes: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            path: &apos;/view/index&apos;,    //路径</span><br><span class=\"line\">            name: &apos;index&apos;,  // 别名，通过别名跳转可以避免url变更需要修改多处地方</span><br><span class=\"line\">            component: Index    // 对应的视图组件</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>想成为一个优秀的组件，这样人性化的初始方式是必不可少的了，而它更强大的地方在于，可以支持redirect配置，如果你想把一个路由重定向到另外一个地方，可以这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default new Router(&#123;</span><br><span class=\"line\">    mode: &apos;history&apos;,  // history模式，看着像活生生的后端渲染</span><br><span class=\"line\">    routes: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            path: &apos;/view/index&apos;,</span><br><span class=\"line\">            name: &apos;index&apos;,</span><br><span class=\"line\">            redirect: &#123;name: &apos;xxxxx&apos;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>路由的嵌套如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default new Router(&#123;</span><br><span class=\"line\">    mode: &apos;history&apos;,  // history模式，看着像活生生的后端渲染</span><br><span class=\"line\">    routes: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            path: &apos;/view/index&apos;,</span><br><span class=\"line\">            name: &apos;index&apos;,</span><br><span class=\"line\">            component： Index,</span><br><span class=\"line\">            children: [</span><br><span class=\"line\">                path: &apos;test&apos;,</span><br><span class=\"line\">                component： Test</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>路由嵌套需要注意的地方有两个：</p>\n<ul>\n<li>上面栗子中children的path实际为 /view/index/test，如果children的path以斜杠开头，则表示为绝对路径，不收父的path影响</li>\n<li>嵌套路由是一个新的视图，不会替换掉父视图；Index里必须包含一个route-view组件，否则不会渲染Test</li>\n</ul>\n<p>需要注意的是如果path有相应的route-link，那视图激活的时候也会在该route-link下自动增加active的class，可以利用这个显示激活的菜单。<br>如果这个不能满足，也可以根据route的matched属性，该属性会记录当前所有已匹配的路由。如上面这个例子的/view/index/test，matched属性会有两个路由信息’/view/index’和’/view/index/test’，<br>根据这个可以把一级和二级的菜单也激活起来</p>\n<p>在视图的component里，可以通过this.$route访问当前路由的数据信息，this.$router访问路由封装的方法。这两个对象可以很方便地操作页面的跳转和获取页面的参数</p>\n<p>this.$route常用的参数如下：</p>\n<ul>\n<li>params 记录路径参数</li>\n<li>query 记录search参数</li>\n<li>meta 记录路由自定义的元信息</li>\n<li>name 当前路由的别名</li>\n<li>path 当前路由的路径</li>\n</ul>\n<p>this.$router常用方法：</p>\n<ul>\n<li>push 路由跳转，并压入历史的堆栈</li>\n<li>replace 路由替换，不会压入历史堆栈，也就是说back的时候，会忽略掉</li>\n<li>back 返回</li>\n<li>redirect 重定向</li>\n</ul>\n<p>上面的push和replace，redirect都可以写到name，params，query等参数</p>\n<p>总的来说，vue router是一个用起来十分顺手和顺心的组件。唯一遇到坑的是在微信浏览器里，微信浏览器对history支持不友好，可以切换路由哦，但是不会改变url。其实这也不能怪vue router，它也是有心无力。</p>\n"},{"layout":"post","title":"vuex知识总结","date":"2017-09-01T14:20:12.000Z","_content":"\n### 状态管理\n\n一个状态管理的库，会涉及到这三部分：state、view、actions。可以知道的是：\n\n- state会影响view\n- view会影响action\n\n但会影响state的是什么呢？action，action可能是单一的或者是来自于多个视图的。\n\nvuex的特点是把数据单独隔离，形成一棵树状图。单独隔离就意味着它有自己的生态系统。输入和输出，其中action作为数据的输入，state作为数据的输出。如下图：\n\n![image](https://vuex.vuejs.org/zh-cn/images/vuex.png)\n\n图中有一个奇怪的地方，多了一个mutations，而且与state相连的是mutations而不是actions。\n\nvuex里有这么一个规则：\n\n> 只能在mutaions里修改state，actions不能直接修改state\n\nmutations即变化，修改state的数据，而且只能是同步的，不能存在异步的操作。如果需要异步怎么办呢？把异步操作放在actions里，拿到数据再通过mutations同步处理。\n\nvuex做的其实是把职权明确了，责任细分了。所以它文档里也说，小系统可以不用。状态数据少，没有细分的必要。\n\n### 使用方法\n\n- Action 通过 store.dispatch 方法触发\n- Mutations 通过 store.commit 方法触发\n\n\n```\n// 触发动作\nactions: {\n  incrementAsync ({ commit }) {\n    setTimeout(() => {\n      commit('increment')\n    }, 1000)\n  }\n}\nstore.dispatch('increment')\n// 触发变化\nmutations: {\n  increment (state, n) {\n    state.count += n\n  }\n}\nstore.commit('increment', 10)\n```\n\n为了更方便地读取state里面的数据，其还提高了一些维护的方法：\n\n- getters 就像计算属性一样，getters的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算\n- mapGetters 将 store 中的 getters 映射到局部计算属性\n- mapMutations 将组件中的 methods 映射为 store.commit 调用\n- mapActions 将组件的 methods 映射为 store.dispatch 调用\n\n\n\n```\nmethods: {\n    ...mapMutations([\n      'increment' // 映射 this.increment() 为 this.$store.commit('increment')\n    ]),\n    ...mapMutations({\n      add: 'increment' // 映射 this.add() 为 this.$store.commit('increment')\n    })\n    ...mapActions([\n      'increment' // 映射 this.increment() 为 this.$store.dispatch('increment')\n    ]),\n    ...mapActions({\n      add: 'increment' // 映射 this.add() 为 this.$store.dispatch('increment')\n    })\n}\n```\n\n\ngetter 既然是会缓存的，那怎么带参数呢？github里有人建议这样写：\n\n```\ngetters: {\n    getListByVal: (state) => (val) => {\n        return state.list.find(item => item.value = val)\n    }\n}\n```\n\n### 模块划分\n\n当状态比较多的时候，vuex支持模块划分，可以通过模块划分，让store树简化一下。每个模块拥有自己的 state、mutation、action、getter。\n- 对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象\n- getter 根节点状态会作为第三个参数暴露出来\n- 内部的 action，局部状态通过 context.state 暴露出来， 根节点状态则为 context.rootState\n\n\n```\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n","source":"_posts/2017-09-01-vuex-base.markdown","raw":"---\nlayout: post\ntitle:  \"vuex知识总结\"\ndate:   2017-09-01 22:20:12\ncategories: \"基础知识\"\n---\n\n### 状态管理\n\n一个状态管理的库，会涉及到这三部分：state、view、actions。可以知道的是：\n\n- state会影响view\n- view会影响action\n\n但会影响state的是什么呢？action，action可能是单一的或者是来自于多个视图的。\n\nvuex的特点是把数据单独隔离，形成一棵树状图。单独隔离就意味着它有自己的生态系统。输入和输出，其中action作为数据的输入，state作为数据的输出。如下图：\n\n![image](https://vuex.vuejs.org/zh-cn/images/vuex.png)\n\n图中有一个奇怪的地方，多了一个mutations，而且与state相连的是mutations而不是actions。\n\nvuex里有这么一个规则：\n\n> 只能在mutaions里修改state，actions不能直接修改state\n\nmutations即变化，修改state的数据，而且只能是同步的，不能存在异步的操作。如果需要异步怎么办呢？把异步操作放在actions里，拿到数据再通过mutations同步处理。\n\nvuex做的其实是把职权明确了，责任细分了。所以它文档里也说，小系统可以不用。状态数据少，没有细分的必要。\n\n### 使用方法\n\n- Action 通过 store.dispatch 方法触发\n- Mutations 通过 store.commit 方法触发\n\n\n```\n// 触发动作\nactions: {\n  incrementAsync ({ commit }) {\n    setTimeout(() => {\n      commit('increment')\n    }, 1000)\n  }\n}\nstore.dispatch('increment')\n// 触发变化\nmutations: {\n  increment (state, n) {\n    state.count += n\n  }\n}\nstore.commit('increment', 10)\n```\n\n为了更方便地读取state里面的数据，其还提高了一些维护的方法：\n\n- getters 就像计算属性一样，getters的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算\n- mapGetters 将 store 中的 getters 映射到局部计算属性\n- mapMutations 将组件中的 methods 映射为 store.commit 调用\n- mapActions 将组件的 methods 映射为 store.dispatch 调用\n\n\n\n```\nmethods: {\n    ...mapMutations([\n      'increment' // 映射 this.increment() 为 this.$store.commit('increment')\n    ]),\n    ...mapMutations({\n      add: 'increment' // 映射 this.add() 为 this.$store.commit('increment')\n    })\n    ...mapActions([\n      'increment' // 映射 this.increment() 为 this.$store.dispatch('increment')\n    ]),\n    ...mapActions({\n      add: 'increment' // 映射 this.add() 为 this.$store.dispatch('increment')\n    })\n}\n```\n\n\ngetter 既然是会缓存的，那怎么带参数呢？github里有人建议这样写：\n\n```\ngetters: {\n    getListByVal: (state) => (val) => {\n        return state.list.find(item => item.value = val)\n    }\n}\n```\n\n### 模块划分\n\n当状态比较多的时候，vuex支持模块划分，可以通过模块划分，让store树简化一下。每个模块拥有自己的 state、mutation、action、getter。\n- 对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象\n- getter 根节点状态会作为第三个参数暴露出来\n- 内部的 action，局部状态通过 context.state 暴露出来， 根节点状态则为 context.rootState\n\n\n```\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n","slug":"2017-09-01-vuex-base","published":1,"updated":"2018-05-26T16:02:28.696Z","comments":1,"photos":[],"link":"","_id":"cjjoevog3000n0gup691l42dx","content":"<h3 id=\"状态管理\"><a href=\"#状态管理\" class=\"headerlink\" title=\"状态管理\"></a>状态管理</h3><p>一个状态管理的库，会涉及到这三部分：state、view、actions。可以知道的是：</p>\n<ul>\n<li>state会影响view</li>\n<li>view会影响action</li>\n</ul>\n<p>但会影响state的是什么呢？action，action可能是单一的或者是来自于多个视图的。</p>\n<p>vuex的特点是把数据单独隔离，形成一棵树状图。单独隔离就意味着它有自己的生态系统。输入和输出，其中action作为数据的输入，state作为数据的输出。如下图：</p>\n<p><img src=\"https://vuex.vuejs.org/zh-cn/images/vuex.png\" alt=\"image\"></p>\n<p>图中有一个奇怪的地方，多了一个mutations，而且与state相连的是mutations而不是actions。</p>\n<p>vuex里有这么一个规则：</p>\n<blockquote>\n<p>只能在mutaions里修改state，actions不能直接修改state</p>\n</blockquote>\n<p>mutations即变化，修改state的数据，而且只能是同步的，不能存在异步的操作。如果需要异步怎么办呢？把异步操作放在actions里，拿到数据再通过mutations同步处理。</p>\n<p>vuex做的其实是把职权明确了，责任细分了。所以它文档里也说，小系统可以不用。状态数据少，没有细分的必要。</p>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><ul>\n<li>Action 通过 store.dispatch 方法触发</li>\n<li>Mutations 通过 store.commit 方法触发</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 触发动作</span><br><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      commit(&apos;increment&apos;)</span><br><span class=\"line\">    &#125;, 1000)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">store.dispatch(&apos;increment&apos;)</span><br><span class=\"line\">// 触发变化</span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">  increment (state, n) &#123;</span><br><span class=\"line\">    state.count += n</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">store.commit(&apos;increment&apos;, 10)</span><br></pre></td></tr></table></figure>\n<p>为了更方便地读取state里面的数据，其还提高了一些维护的方法：</p>\n<ul>\n<li>getters 就像计算属性一样，getters的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算</li>\n<li>mapGetters 将 store 中的 getters 映射到局部计算属性</li>\n<li>mapMutations 将组件中的 methods 映射为 store.commit 调用</li>\n<li>mapActions 将组件的 methods 映射为 store.dispatch 调用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">    ...mapMutations([</span><br><span class=\"line\">      &apos;increment&apos; // 映射 this.increment() 为 this.$store.commit(&apos;increment&apos;)</span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    ...mapMutations(&#123;</span><br><span class=\"line\">      add: &apos;increment&apos; // 映射 this.add() 为 this.$store.commit(&apos;increment&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    ...mapActions([</span><br><span class=\"line\">      &apos;increment&apos; // 映射 this.increment() 为 this.$store.dispatch(&apos;increment&apos;)</span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    ...mapActions(&#123;</span><br><span class=\"line\">      add: &apos;increment&apos; // 映射 this.add() 为 this.$store.dispatch(&apos;increment&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>getter 既然是会缓存的，那怎么带参数呢？github里有人建议这样写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getters: &#123;</span><br><span class=\"line\">    getListByVal: (state) =&gt; (val) =&gt; &#123;</span><br><span class=\"line\">        return state.list.find(item =&gt; item.value = val)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"模块划分\"><a href=\"#模块划分\" class=\"headerlink\" title=\"模块划分\"></a>模块划分</h3><p>当状态比较多的时候，vuex支持模块划分，可以通过模块划分，让store树简化一下。每个模块拥有自己的 state、mutation、action、getter。</p>\n<ul>\n<li>对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象</li>\n<li>getter 根节点状态会作为第三个参数暴露出来</li>\n<li>内部的 action，局部状态通过 context.state 暴露出来， 根节点状态则为 context.rootState</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const moduleA = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;,</span><br><span class=\"line\">  getters: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const moduleB = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    a: moduleA,</span><br><span class=\"line\">    b: moduleB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">store.state.a // -&gt; moduleA 的状态</span><br><span class=\"line\">store.state.b // -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"状态管理\"><a href=\"#状态管理\" class=\"headerlink\" title=\"状态管理\"></a>状态管理</h3><p>一个状态管理的库，会涉及到这三部分：state、view、actions。可以知道的是：</p>\n<ul>\n<li>state会影响view</li>\n<li>view会影响action</li>\n</ul>\n<p>但会影响state的是什么呢？action，action可能是单一的或者是来自于多个视图的。</p>\n<p>vuex的特点是把数据单独隔离，形成一棵树状图。单独隔离就意味着它有自己的生态系统。输入和输出，其中action作为数据的输入，state作为数据的输出。如下图：</p>\n<p><img src=\"https://vuex.vuejs.org/zh-cn/images/vuex.png\" alt=\"image\"></p>\n<p>图中有一个奇怪的地方，多了一个mutations，而且与state相连的是mutations而不是actions。</p>\n<p>vuex里有这么一个规则：</p>\n<blockquote>\n<p>只能在mutaions里修改state，actions不能直接修改state</p>\n</blockquote>\n<p>mutations即变化，修改state的数据，而且只能是同步的，不能存在异步的操作。如果需要异步怎么办呢？把异步操作放在actions里，拿到数据再通过mutations同步处理。</p>\n<p>vuex做的其实是把职权明确了，责任细分了。所以它文档里也说，小系统可以不用。状态数据少，没有细分的必要。</p>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><ul>\n<li>Action 通过 store.dispatch 方法触发</li>\n<li>Mutations 通过 store.commit 方法触发</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 触发动作</span><br><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      commit(&apos;increment&apos;)</span><br><span class=\"line\">    &#125;, 1000)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">store.dispatch(&apos;increment&apos;)</span><br><span class=\"line\">// 触发变化</span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">  increment (state, n) &#123;</span><br><span class=\"line\">    state.count += n</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">store.commit(&apos;increment&apos;, 10)</span><br></pre></td></tr></table></figure>\n<p>为了更方便地读取state里面的数据，其还提高了一些维护的方法：</p>\n<ul>\n<li>getters 就像计算属性一样，getters的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算</li>\n<li>mapGetters 将 store 中的 getters 映射到局部计算属性</li>\n<li>mapMutations 将组件中的 methods 映射为 store.commit 调用</li>\n<li>mapActions 将组件的 methods 映射为 store.dispatch 调用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">    ...mapMutations([</span><br><span class=\"line\">      &apos;increment&apos; // 映射 this.increment() 为 this.$store.commit(&apos;increment&apos;)</span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    ...mapMutations(&#123;</span><br><span class=\"line\">      add: &apos;increment&apos; // 映射 this.add() 为 this.$store.commit(&apos;increment&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    ...mapActions([</span><br><span class=\"line\">      &apos;increment&apos; // 映射 this.increment() 为 this.$store.dispatch(&apos;increment&apos;)</span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    ...mapActions(&#123;</span><br><span class=\"line\">      add: &apos;increment&apos; // 映射 this.add() 为 this.$store.dispatch(&apos;increment&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>getter 既然是会缓存的，那怎么带参数呢？github里有人建议这样写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getters: &#123;</span><br><span class=\"line\">    getListByVal: (state) =&gt; (val) =&gt; &#123;</span><br><span class=\"line\">        return state.list.find(item =&gt; item.value = val)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"模块划分\"><a href=\"#模块划分\" class=\"headerlink\" title=\"模块划分\"></a>模块划分</h3><p>当状态比较多的时候，vuex支持模块划分，可以通过模块划分，让store树简化一下。每个模块拥有自己的 state、mutation、action、getter。</p>\n<ul>\n<li>对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象</li>\n<li>getter 根节点状态会作为第三个参数暴露出来</li>\n<li>内部的 action，局部状态通过 context.state 暴露出来， 根节点状态则为 context.rootState</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const moduleA = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;,</span><br><span class=\"line\">  getters: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const moduleB = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    a: moduleA,</span><br><span class=\"line\">    b: moduleB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">store.state.a // -&gt; moduleA 的状态</span><br><span class=\"line\">store.state.b // -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"关于ES6的这些你知道吗","date":"2017-09-09T01:23:11.000Z","_content":"\n\n\n使用vue开发的时候经常使用es6的语法，下面是一些自己工作中的一些笔记。希望多多补充：\n\n![](./about-es6.jpg)\n\n\n### 1、箭头函数\n\n> 箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域\n\n编译时通过bind外围的this来绑定对象\n\n### 2、在for in 和for of循环中let和const每一次迭代都会创建一个新的绑定\n\n\n```\nfor(let i = 0; i < 10; i++){\n\tsetTimeout(function(){console.log(i)})\n}\n```\n\n\n```\nfor(var i = 0; i < 10; i++){\n\tsetTimeout(function(){console.log(i)})\n}\n```\n\n\n- string的三个查找字符串的方法 includes、startsWith、endsWith\n\n- string重复的方法repeat\n\n- 剩余参数-由三个点和一个紧跟着的具名参数指定，它会是包含传递给函数的其余参数的一个数组\n\n\n```\nfunction pick(object, ...keys){\n    let result = Object.create(null);\n    for(let i = 0; i < keys.length; i++){\n        result[keys[i]] = object[keys[i]]\n    }\n    return result;\n}\n```\n\n\n### 3、特殊操作符 '...'\n\n> 可作为扩展运算符或者剩余操作符，扩展指把属性展开；而剩余指把多个元素变为一个元素（塞到数组里）\n\n相当于Function.prototype.apply，把数组展开，可用于一下几个方向\n\n- 把数组变成多个形参，进行函数调用\n- 把两个数组合并成一个\n- 数组解构（提取的结果是一个数组对象）\n- 将类数组对象转换成数组\n\n具体如下：\n\n```\nvar students = ['Abby','Andy'];\nvar otherStudents = ['Jane','Tom'];\nstudents.push(...otherStudents);\n\n/*********************/\n\nvar parts = ['shoulders', 'knees'];\nvar lyrics = ['head', ...parts, 'and', 'toes'];\n\n/*********************/\n\nvar students = ['Abby', 'Andy', 'Jane', 'Tom'];\nvar somestudents, otherStudents;\n[somestudents, ...otherStudents] = students ;\n\n/*********************/\n\nvar nodeList = document.querySelectorAll('div');\nvar array = [...nodeList];\n```\n\n### 4、Object.assign对象属性混合\n\n> 针对深度拷贝，需要使用其他方法，因为 Object.assign() 拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。\n\nObject.getOwnPropertyDescriptor()返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）\n\n- Object.assign 会跳过那些值为 null 或 undefined 的源对象\n- 继承属性（原型链上）和不可枚举属性是不能拷贝的\n- 原始类型会被包装为 object，只有字符串的包装对象才可能有自身可枚举属性\n- 拷贝过程中可能会产生异常，已经拷贝成功的属性不会受到影响，还未拷贝的属性将不会再被拷贝\n","source":"_posts/2017-09-09-about-es6.markdown","raw":"---\nlayout: post\ntitle: \"关于ES6的这些你知道吗\"\ndate: 2017-09-09 09:23:11\ncategories: \"基础知识\"\n---\n\n\n\n使用vue开发的时候经常使用es6的语法，下面是一些自己工作中的一些笔记。希望多多补充：\n\n![](./about-es6.jpg)\n\n\n### 1、箭头函数\n\n> 箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域\n\n编译时通过bind外围的this来绑定对象\n\n### 2、在for in 和for of循环中let和const每一次迭代都会创建一个新的绑定\n\n\n```\nfor(let i = 0; i < 10; i++){\n\tsetTimeout(function(){console.log(i)})\n}\n```\n\n\n```\nfor(var i = 0; i < 10; i++){\n\tsetTimeout(function(){console.log(i)})\n}\n```\n\n\n- string的三个查找字符串的方法 includes、startsWith、endsWith\n\n- string重复的方法repeat\n\n- 剩余参数-由三个点和一个紧跟着的具名参数指定，它会是包含传递给函数的其余参数的一个数组\n\n\n```\nfunction pick(object, ...keys){\n    let result = Object.create(null);\n    for(let i = 0; i < keys.length; i++){\n        result[keys[i]] = object[keys[i]]\n    }\n    return result;\n}\n```\n\n\n### 3、特殊操作符 '...'\n\n> 可作为扩展运算符或者剩余操作符，扩展指把属性展开；而剩余指把多个元素变为一个元素（塞到数组里）\n\n相当于Function.prototype.apply，把数组展开，可用于一下几个方向\n\n- 把数组变成多个形参，进行函数调用\n- 把两个数组合并成一个\n- 数组解构（提取的结果是一个数组对象）\n- 将类数组对象转换成数组\n\n具体如下：\n\n```\nvar students = ['Abby','Andy'];\nvar otherStudents = ['Jane','Tom'];\nstudents.push(...otherStudents);\n\n/*********************/\n\nvar parts = ['shoulders', 'knees'];\nvar lyrics = ['head', ...parts, 'and', 'toes'];\n\n/*********************/\n\nvar students = ['Abby', 'Andy', 'Jane', 'Tom'];\nvar somestudents, otherStudents;\n[somestudents, ...otherStudents] = students ;\n\n/*********************/\n\nvar nodeList = document.querySelectorAll('div');\nvar array = [...nodeList];\n```\n\n### 4、Object.assign对象属性混合\n\n> 针对深度拷贝，需要使用其他方法，因为 Object.assign() 拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。\n\nObject.getOwnPropertyDescriptor()返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）\n\n- Object.assign 会跳过那些值为 null 或 undefined 的源对象\n- 继承属性（原型链上）和不可枚举属性是不能拷贝的\n- 原始类型会被包装为 object，只有字符串的包装对象才可能有自身可枚举属性\n- 拷贝过程中可能会产生异常，已经拷贝成功的属性不会受到影响，还未拷贝的属性将不会再被拷贝\n","slug":"2017-09-09-about-es6","published":1,"updated":"2018-05-27T02:37:00.088Z","comments":1,"photos":[],"link":"","_id":"cjjoevogd000p0gupfmv5nvoc","content":"<p>使用vue开发的时候经常使用es6的语法，下面是一些自己工作中的一些笔记。希望多多补充：</p>\n<p><img src=\"/2017/09/09/2017-09-09-about-es6/./about-es6.jpg\" alt=\"\"></p>\n<h3 id=\"1、箭头函数\"><a href=\"#1、箭头函数\" class=\"headerlink\" title=\"1、箭头函数\"></a>1、箭头函数</h3><blockquote>\n<p>箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域</p>\n</blockquote>\n<p>编译时通过bind外围的this来绑定对象</p>\n<h3 id=\"2、在for-in-和for-of循环中let和const每一次迭代都会创建一个新的绑定\"><a href=\"#2、在for-in-和for-of循环中let和const每一次迭代都会创建一个新的绑定\" class=\"headerlink\" title=\"2、在for in 和for of循环中let和const每一次迭代都会创建一个新的绑定\"></a>2、在for in 和for of循环中let和const每一次迭代都会创建一个新的绑定</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(let i = 0; i &lt; 10; i++)&#123;</span><br><span class=\"line\">\tsetTimeout(function()&#123;console.log(i)&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(var i = 0; i &lt; 10; i++)&#123;</span><br><span class=\"line\">\tsetTimeout(function()&#123;console.log(i)&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>string的三个查找字符串的方法 includes、startsWith、endsWith</p>\n</li>\n<li><p>string重复的方法repeat</p>\n</li>\n<li><p>剩余参数-由三个点和一个紧跟着的具名参数指定，它会是包含传递给函数的其余参数的一个数组</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function pick(object, ...keys)&#123;</span><br><span class=\"line\">    let result = Object.create(null);</span><br><span class=\"line\">    for(let i = 0; i &lt; keys.length; i++)&#123;</span><br><span class=\"line\">        result[keys[i]] = object[keys[i]]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3、特殊操作符-‘…’\"><a href=\"#3、特殊操作符-‘…’\" class=\"headerlink\" title=\"3、特殊操作符 ‘…’\"></a>3、特殊操作符 ‘…’</h3><blockquote>\n<p>可作为扩展运算符或者剩余操作符，扩展指把属性展开；而剩余指把多个元素变为一个元素（塞到数组里）</p>\n</blockquote>\n<p>相当于Function.prototype.apply，把数组展开，可用于一下几个方向</p>\n<ul>\n<li>把数组变成多个形参，进行函数调用</li>\n<li>把两个数组合并成一个</li>\n<li>数组解构（提取的结果是一个数组对象）</li>\n<li>将类数组对象转换成数组</li>\n</ul>\n<p>具体如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var students = [&apos;Abby&apos;,&apos;Andy&apos;];</span><br><span class=\"line\">var otherStudents = [&apos;Jane&apos;,&apos;Tom&apos;];</span><br><span class=\"line\">students.push(...otherStudents);</span><br><span class=\"line\"></span><br><span class=\"line\">/*********************/</span><br><span class=\"line\"></span><br><span class=\"line\">var parts = [&apos;shoulders&apos;, &apos;knees&apos;];</span><br><span class=\"line\">var lyrics = [&apos;head&apos;, ...parts, &apos;and&apos;, &apos;toes&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">/*********************/</span><br><span class=\"line\"></span><br><span class=\"line\">var students = [&apos;Abby&apos;, &apos;Andy&apos;, &apos;Jane&apos;, &apos;Tom&apos;];</span><br><span class=\"line\">var somestudents, otherStudents;</span><br><span class=\"line\">[somestudents, ...otherStudents] = students ;</span><br><span class=\"line\"></span><br><span class=\"line\">/*********************/</span><br><span class=\"line\"></span><br><span class=\"line\">var nodeList = document.querySelectorAll(&apos;div&apos;);</span><br><span class=\"line\">var array = [...nodeList];</span><br></pre></td></tr></table></figure>\n<h3 id=\"4、Object-assign对象属性混合\"><a href=\"#4、Object-assign对象属性混合\" class=\"headerlink\" title=\"4、Object.assign对象属性混合\"></a>4、Object.assign对象属性混合</h3><blockquote>\n<p>针对深度拷贝，需要使用其他方法，因为 Object.assign() 拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。</p>\n</blockquote>\n<p>Object.getOwnPropertyDescriptor()返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）</p>\n<ul>\n<li>Object.assign 会跳过那些值为 null 或 undefined 的源对象</li>\n<li>继承属性（原型链上）和不可枚举属性是不能拷贝的</li>\n<li>原始类型会被包装为 object，只有字符串的包装对象才可能有自身可枚举属性</li>\n<li>拷贝过程中可能会产生异常，已经拷贝成功的属性不会受到影响，还未拷贝的属性将不会再被拷贝</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>使用vue开发的时候经常使用es6的语法，下面是一些自己工作中的一些笔记。希望多多补充：</p>\n<p><img src=\"/2017/09/09/2017-09-09-about-es6/./about-es6.jpg\" alt=\"\"></p>\n<h3 id=\"1、箭头函数\"><a href=\"#1、箭头函数\" class=\"headerlink\" title=\"1、箭头函数\"></a>1、箭头函数</h3><blockquote>\n<p>箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域</p>\n</blockquote>\n<p>编译时通过bind外围的this来绑定对象</p>\n<h3 id=\"2、在for-in-和for-of循环中let和const每一次迭代都会创建一个新的绑定\"><a href=\"#2、在for-in-和for-of循环中let和const每一次迭代都会创建一个新的绑定\" class=\"headerlink\" title=\"2、在for in 和for of循环中let和const每一次迭代都会创建一个新的绑定\"></a>2、在for in 和for of循环中let和const每一次迭代都会创建一个新的绑定</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(let i = 0; i &lt; 10; i++)&#123;</span><br><span class=\"line\">\tsetTimeout(function()&#123;console.log(i)&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(var i = 0; i &lt; 10; i++)&#123;</span><br><span class=\"line\">\tsetTimeout(function()&#123;console.log(i)&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>string的三个查找字符串的方法 includes、startsWith、endsWith</p>\n</li>\n<li><p>string重复的方法repeat</p>\n</li>\n<li><p>剩余参数-由三个点和一个紧跟着的具名参数指定，它会是包含传递给函数的其余参数的一个数组</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function pick(object, ...keys)&#123;</span><br><span class=\"line\">    let result = Object.create(null);</span><br><span class=\"line\">    for(let i = 0; i &lt; keys.length; i++)&#123;</span><br><span class=\"line\">        result[keys[i]] = object[keys[i]]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3、特殊操作符-‘…’\"><a href=\"#3、特殊操作符-‘…’\" class=\"headerlink\" title=\"3、特殊操作符 ‘…’\"></a>3、特殊操作符 ‘…’</h3><blockquote>\n<p>可作为扩展运算符或者剩余操作符，扩展指把属性展开；而剩余指把多个元素变为一个元素（塞到数组里）</p>\n</blockquote>\n<p>相当于Function.prototype.apply，把数组展开，可用于一下几个方向</p>\n<ul>\n<li>把数组变成多个形参，进行函数调用</li>\n<li>把两个数组合并成一个</li>\n<li>数组解构（提取的结果是一个数组对象）</li>\n<li>将类数组对象转换成数组</li>\n</ul>\n<p>具体如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var students = [&apos;Abby&apos;,&apos;Andy&apos;];</span><br><span class=\"line\">var otherStudents = [&apos;Jane&apos;,&apos;Tom&apos;];</span><br><span class=\"line\">students.push(...otherStudents);</span><br><span class=\"line\"></span><br><span class=\"line\">/*********************/</span><br><span class=\"line\"></span><br><span class=\"line\">var parts = [&apos;shoulders&apos;, &apos;knees&apos;];</span><br><span class=\"line\">var lyrics = [&apos;head&apos;, ...parts, &apos;and&apos;, &apos;toes&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">/*********************/</span><br><span class=\"line\"></span><br><span class=\"line\">var students = [&apos;Abby&apos;, &apos;Andy&apos;, &apos;Jane&apos;, &apos;Tom&apos;];</span><br><span class=\"line\">var somestudents, otherStudents;</span><br><span class=\"line\">[somestudents, ...otherStudents] = students ;</span><br><span class=\"line\"></span><br><span class=\"line\">/*********************/</span><br><span class=\"line\"></span><br><span class=\"line\">var nodeList = document.querySelectorAll(&apos;div&apos;);</span><br><span class=\"line\">var array = [...nodeList];</span><br></pre></td></tr></table></figure>\n<h3 id=\"4、Object-assign对象属性混合\"><a href=\"#4、Object-assign对象属性混合\" class=\"headerlink\" title=\"4、Object.assign对象属性混合\"></a>4、Object.assign对象属性混合</h3><blockquote>\n<p>针对深度拷贝，需要使用其他方法，因为 Object.assign() 拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。</p>\n</blockquote>\n<p>Object.getOwnPropertyDescriptor()返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）</p>\n<ul>\n<li>Object.assign 会跳过那些值为 null 或 undefined 的源对象</li>\n<li>继承属性（原型链上）和不可枚举属性是不能拷贝的</li>\n<li>原始类型会被包装为 object，只有字符串的包装对象才可能有自身可枚举属性</li>\n<li>拷贝过程中可能会产生异常，已经拷贝成功的属性不会受到影响，还未拷贝的属性将不会再被拷贝</li>\n</ul>\n"},{"layout":"post","title":"我和小艺的广州阳朔两日闲游","date":"2017-08-19T02:38:19.000Z","header_image":"https://dimg02.c-ctrip.com/images/100u0l000000dat7w409F_C_1600_1200_Mtg_7.jpg","_content":"\n广西阳朔，山水秀丽，价美物廉，向来是大学生毕业游的首选之地，我们也不例外。三年前，是五个小时的大巴；三年后，两个小时的动车。时代发展变化很快，时间的缩短也让我们有了再去一次走走的念头。于是乎网上订票，可也奇怪\n广州南到阳朔的车票十分抢手，两周后的票都没了。实属无奈，然而抢票这事，念念不忘，必有回响。经过抢票神器一天的忙碌，票票在手。东风已备，周五晚上随便准备了一些粮草和下饭神剧，以及十分纠结的在飞猪上定了个不记得叫什么名字的\n酒店。第二天一大早就赶往广州南站，顺利坐上了火车。这匆忙的行程，想必也不会如此顺心。果然，在车上的时候方知酒店未落实，催促之下，飞猪商家告知没房了。无奈为了落地在决定了。\n\n两个小时的车程，终于抵达了阳朔，出了高铁站便有接驳的官方大巴前往阳朔镇上（价格20），大概五十分钟的行程，在阳朔高铁车站（专门往来高铁站和阳朔的车站）那边下车。然后找了当地的一间维也纳酒店入住，一共两间西街店和印象店，\n西街店比较靠近车站和西街，价格也贵一点；印象店在印象刘三姐那边，远一点，便宜一点，窗户也大个十倍吧！一天一夜价格350左右。\n\n![](./1.JPG)\n\n在酒店休息了一会，下午叫了个滴滴，去了十里画廊那边。一路上出了车，就是车轮、车镜子、车喇叭~~~尽是车。现在骑自行车的人少了，骑电动车、小车的人多了。真是与时俱进啊。不知是现代的车融不进美景还是多了几份喧嚣，十里画廊\n让人有点名不副实的感觉。我们在大榕树那边下的车，然后就去看了看大榕树，路遇神棍，缘起一炷香，神明非贪财之辈，又岂会怪我少捐这一点功德钱呢？以后景点的庙还是远观不可近拜。\n\n![](./2.JPG)\n\n大榕树还真是大，粗如枝干的气根直插大地，仿佛在大地的花屁股上打了好几针。出了大榕树便租了一台电动车，也不贵，不记时，天明到天黑。\n\n![](./3.JPG)\n\n于是我们就骑着车往回走，顺便回到镇上。一路吹着热风、看着景色，也是另一番滋味。\n\n![](./4.JPG)\n\n在西街那边打电话，叫他们的人来取车，然后退了我们押金。我们就去西街逛了一下。当地人说，白天游客都被带到景点去了，人比较少，有的都是一些散客。阳朔的西街集合了小车、手信、酒吧、饮食等众多的小店。阳朔最出名的两\n道菜是啤酒鱼和酿大田螺，其中啤酒鱼当地人说哪里味道都差不多，景区的里面贵一点。我们逛累了就找了一家静吧歇息了一下~\n\n![](./7.JPG)\n\n酒吧的驻场歌手都是几个场来回跑的，可能下午人比较少，歌手也是偶尔唱唱\n\n![](./6.JPG)\n\n按照电视情节，看到这情景，通常男主都会主动上去献唱一首，博得群众演员的青睐。不过，我这嘹亮的歌声就不嫌丑了，毕竟导演也不在这。逛完一圈，我们就去江边走走了。\n![](./9.JPG)\n\n![](./10.JPG)\n\n![](./11.JPG)\n\n阳朔主要是两条江，漓江和遇龙河，图上是西街后面的漓江，景色还是挺美丽的，还有市民在那游泳，小屁孩在玩耍。漓江和遇龙河都可以漂流，漓江是有浆的，遇龙河是手动竹筏。有人说漓江是大家闺秀，遇龙河是小家碧玉，两者各有\n千秋。不过我们这次都没去！哈哈！别问为什么，热辣辣的天，只想在空调底下看蓝天白云。\n\n![](./12.JPG)\n\n这鲜豆腐挺好吃的\n\n![](./13.JPG)\n\n朦朦胧胧的大片既视感\n\n第二天，早上在酒店吃了简单的自助早餐，真的是吃过的最简单的自动早餐。中午退了房，又去西街吃了个饭，然后再逛了一下\n\n![](./5.JPG)\n\n![](./8.JPG)\n\n![](./14.JPG)\n\n![](./17.JPG)\n\n![](./15.JPG)\n\n![](./16.JPG)\n\n小女朋友最喜欢的还是这地道的螺蛳粉，小店，绝对称得上物美价廉。\n\n下午四点多便去车站坐车去动车站了。\n\n![](./18.JPG)\n\n简短的两天时间，没去什么大景点，毕竟只是想来这睡睡觉，呼吸一下新鲜空气，放松一下自己\n\n![](./19.JPG)\n\n![](./20.JPG)\n\n大自然的恩宠，阳朔的景色还是挺美丽的。\n\n","source":"_posts/2017-08-05-yangshuoyouji.markdown","raw":"---\nlayout: post\ntitle:  \"我和小艺的广州阳朔两日闲游\"\ndate:   2017-08-19 10:38:19\ncategories: \"闲暇游记\"\nheader_image: 'https://dimg02.c-ctrip.com/images/100u0l000000dat7w409F_C_1600_1200_Mtg_7.jpg'\n---\n\n广西阳朔，山水秀丽，价美物廉，向来是大学生毕业游的首选之地，我们也不例外。三年前，是五个小时的大巴；三年后，两个小时的动车。时代发展变化很快，时间的缩短也让我们有了再去一次走走的念头。于是乎网上订票，可也奇怪\n广州南到阳朔的车票十分抢手，两周后的票都没了。实属无奈，然而抢票这事，念念不忘，必有回响。经过抢票神器一天的忙碌，票票在手。东风已备，周五晚上随便准备了一些粮草和下饭神剧，以及十分纠结的在飞猪上定了个不记得叫什么名字的\n酒店。第二天一大早就赶往广州南站，顺利坐上了火车。这匆忙的行程，想必也不会如此顺心。果然，在车上的时候方知酒店未落实，催促之下，飞猪商家告知没房了。无奈为了落地在决定了。\n\n两个小时的车程，终于抵达了阳朔，出了高铁站便有接驳的官方大巴前往阳朔镇上（价格20），大概五十分钟的行程，在阳朔高铁车站（专门往来高铁站和阳朔的车站）那边下车。然后找了当地的一间维也纳酒店入住，一共两间西街店和印象店，\n西街店比较靠近车站和西街，价格也贵一点；印象店在印象刘三姐那边，远一点，便宜一点，窗户也大个十倍吧！一天一夜价格350左右。\n\n![](./1.JPG)\n\n在酒店休息了一会，下午叫了个滴滴，去了十里画廊那边。一路上出了车，就是车轮、车镜子、车喇叭~~~尽是车。现在骑自行车的人少了，骑电动车、小车的人多了。真是与时俱进啊。不知是现代的车融不进美景还是多了几份喧嚣，十里画廊\n让人有点名不副实的感觉。我们在大榕树那边下的车，然后就去看了看大榕树，路遇神棍，缘起一炷香，神明非贪财之辈，又岂会怪我少捐这一点功德钱呢？以后景点的庙还是远观不可近拜。\n\n![](./2.JPG)\n\n大榕树还真是大，粗如枝干的气根直插大地，仿佛在大地的花屁股上打了好几针。出了大榕树便租了一台电动车，也不贵，不记时，天明到天黑。\n\n![](./3.JPG)\n\n于是我们就骑着车往回走，顺便回到镇上。一路吹着热风、看着景色，也是另一番滋味。\n\n![](./4.JPG)\n\n在西街那边打电话，叫他们的人来取车，然后退了我们押金。我们就去西街逛了一下。当地人说，白天游客都被带到景点去了，人比较少，有的都是一些散客。阳朔的西街集合了小车、手信、酒吧、饮食等众多的小店。阳朔最出名的两\n道菜是啤酒鱼和酿大田螺，其中啤酒鱼当地人说哪里味道都差不多，景区的里面贵一点。我们逛累了就找了一家静吧歇息了一下~\n\n![](./7.JPG)\n\n酒吧的驻场歌手都是几个场来回跑的，可能下午人比较少，歌手也是偶尔唱唱\n\n![](./6.JPG)\n\n按照电视情节，看到这情景，通常男主都会主动上去献唱一首，博得群众演员的青睐。不过，我这嘹亮的歌声就不嫌丑了，毕竟导演也不在这。逛完一圈，我们就去江边走走了。\n![](./9.JPG)\n\n![](./10.JPG)\n\n![](./11.JPG)\n\n阳朔主要是两条江，漓江和遇龙河，图上是西街后面的漓江，景色还是挺美丽的，还有市民在那游泳，小屁孩在玩耍。漓江和遇龙河都可以漂流，漓江是有浆的，遇龙河是手动竹筏。有人说漓江是大家闺秀，遇龙河是小家碧玉，两者各有\n千秋。不过我们这次都没去！哈哈！别问为什么，热辣辣的天，只想在空调底下看蓝天白云。\n\n![](./12.JPG)\n\n这鲜豆腐挺好吃的\n\n![](./13.JPG)\n\n朦朦胧胧的大片既视感\n\n第二天，早上在酒店吃了简单的自助早餐，真的是吃过的最简单的自动早餐。中午退了房，又去西街吃了个饭，然后再逛了一下\n\n![](./5.JPG)\n\n![](./8.JPG)\n\n![](./14.JPG)\n\n![](./17.JPG)\n\n![](./15.JPG)\n\n![](./16.JPG)\n\n小女朋友最喜欢的还是这地道的螺蛳粉，小店，绝对称得上物美价廉。\n\n下午四点多便去车站坐车去动车站了。\n\n![](./18.JPG)\n\n简短的两天时间，没去什么大景点，毕竟只是想来这睡睡觉，呼吸一下新鲜空气，放松一下自己\n\n![](./19.JPG)\n\n![](./20.JPG)\n\n大自然的恩宠，阳朔的景色还是挺美丽的。\n\n","slug":"2017-08-05-yangshuoyouji","published":1,"updated":"2018-06-02T03:22:52.665Z","comments":1,"photos":[],"link":"","_id":"cjjoevogl000r0gupo0u2pckk","content":"<p>广西阳朔，山水秀丽，价美物廉，向来是大学生毕业游的首选之地，我们也不例外。三年前，是五个小时的大巴；三年后，两个小时的动车。时代发展变化很快，时间的缩短也让我们有了再去一次走走的念头。于是乎网上订票，可也奇怪<br>广州南到阳朔的车票十分抢手，两周后的票都没了。实属无奈，然而抢票这事，念念不忘，必有回响。经过抢票神器一天的忙碌，票票在手。东风已备，周五晚上随便准备了一些粮草和下饭神剧，以及十分纠结的在飞猪上定了个不记得叫什么名字的<br>酒店。第二天一大早就赶往广州南站，顺利坐上了火车。这匆忙的行程，想必也不会如此顺心。果然，在车上的时候方知酒店未落实，催促之下，飞猪商家告知没房了。无奈为了落地在决定了。</p>\n<p>两个小时的车程，终于抵达了阳朔，出了高铁站便有接驳的官方大巴前往阳朔镇上（价格20），大概五十分钟的行程，在阳朔高铁车站（专门往来高铁站和阳朔的车站）那边下车。然后找了当地的一间维也纳酒店入住，一共两间西街店和印象店，<br>西街店比较靠近车站和西街，价格也贵一点；印象店在印象刘三姐那边，远一点，便宜一点，窗户也大个十倍吧！一天一夜价格350左右。</p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./1.JPG\" alt=\"\"></p>\n<p>在酒店休息了一会，下午叫了个滴滴，去了十里画廊那边。一路上出了车，就是车轮、车镜子、车喇叭~~~尽是车。现在骑自行车的人少了，骑电动车、小车的人多了。真是与时俱进啊。不知是现代的车融不进美景还是多了几份喧嚣，十里画廊<br>让人有点名不副实的感觉。我们在大榕树那边下的车，然后就去看了看大榕树，路遇神棍，缘起一炷香，神明非贪财之辈，又岂会怪我少捐这一点功德钱呢？以后景点的庙还是远观不可近拜。</p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./2.JPG\" alt=\"\"></p>\n<p>大榕树还真是大，粗如枝干的气根直插大地，仿佛在大地的花屁股上打了好几针。出了大榕树便租了一台电动车，也不贵，不记时，天明到天黑。</p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./3.JPG\" alt=\"\"></p>\n<p>于是我们就骑着车往回走，顺便回到镇上。一路吹着热风、看着景色，也是另一番滋味。</p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./4.JPG\" alt=\"\"></p>\n<p>在西街那边打电话，叫他们的人来取车，然后退了我们押金。我们就去西街逛了一下。当地人说，白天游客都被带到景点去了，人比较少，有的都是一些散客。阳朔的西街集合了小车、手信、酒吧、饮食等众多的小店。阳朔最出名的两<br>道菜是啤酒鱼和酿大田螺，其中啤酒鱼当地人说哪里味道都差不多，景区的里面贵一点。我们逛累了就找了一家静吧歇息了一下~</p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./7.JPG\" alt=\"\"></p>\n<p>酒吧的驻场歌手都是几个场来回跑的，可能下午人比较少，歌手也是偶尔唱唱</p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./6.JPG\" alt=\"\"></p>\n<p>按照电视情节，看到这情景，通常男主都会主动上去献唱一首，博得群众演员的青睐。不过，我这嘹亮的歌声就不嫌丑了，毕竟导演也不在这。逛完一圈，我们就去江边走走了。<br><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./9.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./10.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./11.JPG\" alt=\"\"></p>\n<p>阳朔主要是两条江，漓江和遇龙河，图上是西街后面的漓江，景色还是挺美丽的，还有市民在那游泳，小屁孩在玩耍。漓江和遇龙河都可以漂流，漓江是有浆的，遇龙河是手动竹筏。有人说漓江是大家闺秀，遇龙河是小家碧玉，两者各有<br>千秋。不过我们这次都没去！哈哈！别问为什么，热辣辣的天，只想在空调底下看蓝天白云。</p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./12.JPG\" alt=\"\"></p>\n<p>这鲜豆腐挺好吃的</p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./13.JPG\" alt=\"\"></p>\n<p>朦朦胧胧的大片既视感</p>\n<p>第二天，早上在酒店吃了简单的自助早餐，真的是吃过的最简单的自动早餐。中午退了房，又去西街吃了个饭，然后再逛了一下</p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./5.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./8.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./14.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./17.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./15.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./16.JPG\" alt=\"\"></p>\n<p>小女朋友最喜欢的还是这地道的螺蛳粉，小店，绝对称得上物美价廉。</p>\n<p>下午四点多便去车站坐车去动车站了。</p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./18.JPG\" alt=\"\"></p>\n<p>简短的两天时间，没去什么大景点，毕竟只是想来这睡睡觉，呼吸一下新鲜空气，放松一下自己</p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./19.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./20.JPG\" alt=\"\"></p>\n<p>大自然的恩宠，阳朔的景色还是挺美丽的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>广西阳朔，山水秀丽，价美物廉，向来是大学生毕业游的首选之地，我们也不例外。三年前，是五个小时的大巴；三年后，两个小时的动车。时代发展变化很快，时间的缩短也让我们有了再去一次走走的念头。于是乎网上订票，可也奇怪<br>广州南到阳朔的车票十分抢手，两周后的票都没了。实属无奈，然而抢票这事，念念不忘，必有回响。经过抢票神器一天的忙碌，票票在手。东风已备，周五晚上随便准备了一些粮草和下饭神剧，以及十分纠结的在飞猪上定了个不记得叫什么名字的<br>酒店。第二天一大早就赶往广州南站，顺利坐上了火车。这匆忙的行程，想必也不会如此顺心。果然，在车上的时候方知酒店未落实，催促之下，飞猪商家告知没房了。无奈为了落地在决定了。</p>\n<p>两个小时的车程，终于抵达了阳朔，出了高铁站便有接驳的官方大巴前往阳朔镇上（价格20），大概五十分钟的行程，在阳朔高铁车站（专门往来高铁站和阳朔的车站）那边下车。然后找了当地的一间维也纳酒店入住，一共两间西街店和印象店，<br>西街店比较靠近车站和西街，价格也贵一点；印象店在印象刘三姐那边，远一点，便宜一点，窗户也大个十倍吧！一天一夜价格350左右。</p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./1.JPG\" alt=\"\"></p>\n<p>在酒店休息了一会，下午叫了个滴滴，去了十里画廊那边。一路上出了车，就是车轮、车镜子、车喇叭~~~尽是车。现在骑自行车的人少了，骑电动车、小车的人多了。真是与时俱进啊。不知是现代的车融不进美景还是多了几份喧嚣，十里画廊<br>让人有点名不副实的感觉。我们在大榕树那边下的车，然后就去看了看大榕树，路遇神棍，缘起一炷香，神明非贪财之辈，又岂会怪我少捐这一点功德钱呢？以后景点的庙还是远观不可近拜。</p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./2.JPG\" alt=\"\"></p>\n<p>大榕树还真是大，粗如枝干的气根直插大地，仿佛在大地的花屁股上打了好几针。出了大榕树便租了一台电动车，也不贵，不记时，天明到天黑。</p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./3.JPG\" alt=\"\"></p>\n<p>于是我们就骑着车往回走，顺便回到镇上。一路吹着热风、看着景色，也是另一番滋味。</p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./4.JPG\" alt=\"\"></p>\n<p>在西街那边打电话，叫他们的人来取车，然后退了我们押金。我们就去西街逛了一下。当地人说，白天游客都被带到景点去了，人比较少，有的都是一些散客。阳朔的西街集合了小车、手信、酒吧、饮食等众多的小店。阳朔最出名的两<br>道菜是啤酒鱼和酿大田螺，其中啤酒鱼当地人说哪里味道都差不多，景区的里面贵一点。我们逛累了就找了一家静吧歇息了一下~</p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./7.JPG\" alt=\"\"></p>\n<p>酒吧的驻场歌手都是几个场来回跑的，可能下午人比较少，歌手也是偶尔唱唱</p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./6.JPG\" alt=\"\"></p>\n<p>按照电视情节，看到这情景，通常男主都会主动上去献唱一首，博得群众演员的青睐。不过，我这嘹亮的歌声就不嫌丑了，毕竟导演也不在这。逛完一圈，我们就去江边走走了。<br><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./9.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./10.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./11.JPG\" alt=\"\"></p>\n<p>阳朔主要是两条江，漓江和遇龙河，图上是西街后面的漓江，景色还是挺美丽的，还有市民在那游泳，小屁孩在玩耍。漓江和遇龙河都可以漂流，漓江是有浆的，遇龙河是手动竹筏。有人说漓江是大家闺秀，遇龙河是小家碧玉，两者各有<br>千秋。不过我们这次都没去！哈哈！别问为什么，热辣辣的天，只想在空调底下看蓝天白云。</p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./12.JPG\" alt=\"\"></p>\n<p>这鲜豆腐挺好吃的</p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./13.JPG\" alt=\"\"></p>\n<p>朦朦胧胧的大片既视感</p>\n<p>第二天，早上在酒店吃了简单的自助早餐，真的是吃过的最简单的自动早餐。中午退了房，又去西街吃了个饭，然后再逛了一下</p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./5.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./8.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./14.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./17.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./15.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./16.JPG\" alt=\"\"></p>\n<p>小女朋友最喜欢的还是这地道的螺蛳粉，小店，绝对称得上物美价廉。</p>\n<p>下午四点多便去车站坐车去动车站了。</p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./18.JPG\" alt=\"\"></p>\n<p>简短的两天时间，没去什么大景点，毕竟只是想来这睡睡觉，呼吸一下新鲜空气，放松一下自己</p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./19.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/19/2017-08-05-yangshuoyouji/./20.JPG\" alt=\"\"></p>\n<p>大自然的恩宠，阳朔的景色还是挺美丽的。</p>\n"},{"layout":"post","title":"记一次node捉取表格数据的实践","date":"2017-09-10T12:40:20.000Z","_content":"\n\n最近在公司办理了人才引入，递交了资料，然后就等待公示；公示的名单会在改网页中展示http://www.hrssgz.gov.cn/vsgzpiapp01/GZPI/Gateway/PersonIntroducePublicity.aspx，点进去查看一番\n觉得坑爹的是每页只显示几条，而且还有60页之多，这简直是反人类。于是便想着把所有的数据搞下来！\n\n![](step1.png)\n\n第一步肯定是F12看看请求的格式了，又翻页看了一下请求，大致了解了流程：\n\n- 每次请求会拿到__VIEWSTATEGENERATOR、__VIEWSTATE等着些后端的code值\n- __EVENTTARGET表明是第一页还是尾页、或者上一页下一页\n- ToPage为当前的页码\n- 接口的地址都是这一个/vsgzpiapp01/GZPI/Gateway/PersonIntroducePublicity.aspx\n- 采用post的方式请求\n\nhttp请求体\n\n![](./step2.png)\n\n页面跳转处理\n\n![](./step3.png)\n\n跳转执行函数\n\n![](./step4.png)\n\n第二步模拟请求，获取返回的html，截取数据拿到第一页的表格，存储起来，并拿第二页的请求参数\n\n这里借助了两个npm的包request、cheerio\n\n- request一个node发送http请求十分好用的包，可以任意拼装http头部所有字段，模拟现实的浏览器请求也不成问题\n- cheerio可以让你再node中像在浏览器里一样使用jquery的包，可以方便地操作dom节点\n\n具体实现如下，会把结果写入到当前的一个data.html文件里：\n\n```\nvar fs = require('fs'),\n    request = require('request'),\n    cheerio = require('cheerio')\n\n// 缓存的结果\nvar result = ''\n\nfunction write(str){\n    fs.writeFile('./data.html', str, function (err) {\n        if (err) throw err;\n    });\n}\n\n// 为了好看一点，包装一下\nfunction wrapHtml(str) {\n    var header = '<tr class=\"ListHeader\" align=\"center\"> <td>姓名</td><td>单位名称</td><td>批复结果</td><td>审批单位</td><td>公示开始时间</td><td>公示结束时间</td> </tr>'\n    str = '<table>' + header + str +'</table>'\n    return '<!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>最新名单</title> </head> <body> '+str+'</body > </html>'\n}\n\nfunction query(data){\n    request.post({\n        url: 'http://www.hrssgz.gov.cn/vsgzpiapp01/GZPI/Gateway/PersonIntroducePublicity.aspx',\n        formData: data\n    }, function (error, response, body) {\n        var startIndex = body.indexOf('<tr class=\"ListItem\">')\n        var endIndex = body.indexOf('</table>')\n        result += body.slice(startIndex, endIndex)\n        var formData = getFormData(body)\n\t\t//如果formdata没值标示没有下一页了，也就可以结束了\n        if(formData){\n            query(formData)\n        }else{\n            write(wrapHtml(result))\n            console.log('读取完成');\n        }\n    })\n}\n\n//在body中获取下一页的参数\nfunction getFormData (body) {\n    const $ = cheerio.load(body)\n    if($('#NextLBtn').attr('disabled') == 'disabled'){\n        return false\n    }\n    var total = $('#PageCount').text()\n    var cur = $('#ToPage').val()\n    console.log('继续读取第'+Number(+cur + 1)+'页，' + '共'+total+'页');\n    return {\n        __EVENTTARGET: 'NextLBtn',\n        __VIEWSTATE: $('#__VIEWSTATE').val(),\n        __VIEWSTATEGENERATOR: $('#__VIEWSTATEGENERATOR').val(),\n        ToPage: cur\n    }\n}\n//开始拿第一页的数据\nquery()\n```\n\n下面是执行的结果\n\n![](./step5.png)\n\n总的来说流程还是比较简单的，拿到表格之后也可以随意搜索名字了。node确实是给前端带来了很大的改变，让前端可以从浏览器走出去，可以任意的操作计算机系统的资源，而目前更是广泛应用到静态服务器、SSR、资源打包优化、桌面应用等。\n可以说Web2.0让js死而复生，node让js脱胎换骨。js如火如荼也很大程度上得益于当今项目开源的浪潮，前不久更是看到了一些开源的神经网络js库，相信不久的将来，在AI、VR等新技术领域js也定能分得一杯羹。\n\n其实作为IT人士，一直觉得我们不应该太过局限于工作，与技能结合起来，让能力更好地改变我们的生活，结合生活我们才能有所创造。铁饭碗不是来源于组织的强大稳健，而是产品与技术创新。\n","source":"_posts/2017-09-10-get-data.markdown","raw":"---\nlayout: post\ntitle:  \"记一次node捉取表格数据的实践\"\ndate:   2017-09-10 20:40:20\ncategories: \"实战应用\"\n---\n\n\n最近在公司办理了人才引入，递交了资料，然后就等待公示；公示的名单会在改网页中展示http://www.hrssgz.gov.cn/vsgzpiapp01/GZPI/Gateway/PersonIntroducePublicity.aspx，点进去查看一番\n觉得坑爹的是每页只显示几条，而且还有60页之多，这简直是反人类。于是便想着把所有的数据搞下来！\n\n![](step1.png)\n\n第一步肯定是F12看看请求的格式了，又翻页看了一下请求，大致了解了流程：\n\n- 每次请求会拿到__VIEWSTATEGENERATOR、__VIEWSTATE等着些后端的code值\n- __EVENTTARGET表明是第一页还是尾页、或者上一页下一页\n- ToPage为当前的页码\n- 接口的地址都是这一个/vsgzpiapp01/GZPI/Gateway/PersonIntroducePublicity.aspx\n- 采用post的方式请求\n\nhttp请求体\n\n![](./step2.png)\n\n页面跳转处理\n\n![](./step3.png)\n\n跳转执行函数\n\n![](./step4.png)\n\n第二步模拟请求，获取返回的html，截取数据拿到第一页的表格，存储起来，并拿第二页的请求参数\n\n这里借助了两个npm的包request、cheerio\n\n- request一个node发送http请求十分好用的包，可以任意拼装http头部所有字段，模拟现实的浏览器请求也不成问题\n- cheerio可以让你再node中像在浏览器里一样使用jquery的包，可以方便地操作dom节点\n\n具体实现如下，会把结果写入到当前的一个data.html文件里：\n\n```\nvar fs = require('fs'),\n    request = require('request'),\n    cheerio = require('cheerio')\n\n// 缓存的结果\nvar result = ''\n\nfunction write(str){\n    fs.writeFile('./data.html', str, function (err) {\n        if (err) throw err;\n    });\n}\n\n// 为了好看一点，包装一下\nfunction wrapHtml(str) {\n    var header = '<tr class=\"ListHeader\" align=\"center\"> <td>姓名</td><td>单位名称</td><td>批复结果</td><td>审批单位</td><td>公示开始时间</td><td>公示结束时间</td> </tr>'\n    str = '<table>' + header + str +'</table>'\n    return '<!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>最新名单</title> </head> <body> '+str+'</body > </html>'\n}\n\nfunction query(data){\n    request.post({\n        url: 'http://www.hrssgz.gov.cn/vsgzpiapp01/GZPI/Gateway/PersonIntroducePublicity.aspx',\n        formData: data\n    }, function (error, response, body) {\n        var startIndex = body.indexOf('<tr class=\"ListItem\">')\n        var endIndex = body.indexOf('</table>')\n        result += body.slice(startIndex, endIndex)\n        var formData = getFormData(body)\n\t\t//如果formdata没值标示没有下一页了，也就可以结束了\n        if(formData){\n            query(formData)\n        }else{\n            write(wrapHtml(result))\n            console.log('读取完成');\n        }\n    })\n}\n\n//在body中获取下一页的参数\nfunction getFormData (body) {\n    const $ = cheerio.load(body)\n    if($('#NextLBtn').attr('disabled') == 'disabled'){\n        return false\n    }\n    var total = $('#PageCount').text()\n    var cur = $('#ToPage').val()\n    console.log('继续读取第'+Number(+cur + 1)+'页，' + '共'+total+'页');\n    return {\n        __EVENTTARGET: 'NextLBtn',\n        __VIEWSTATE: $('#__VIEWSTATE').val(),\n        __VIEWSTATEGENERATOR: $('#__VIEWSTATEGENERATOR').val(),\n        ToPage: cur\n    }\n}\n//开始拿第一页的数据\nquery()\n```\n\n下面是执行的结果\n\n![](./step5.png)\n\n总的来说流程还是比较简单的，拿到表格之后也可以随意搜索名字了。node确实是给前端带来了很大的改变，让前端可以从浏览器走出去，可以任意的操作计算机系统的资源，而目前更是广泛应用到静态服务器、SSR、资源打包优化、桌面应用等。\n可以说Web2.0让js死而复生，node让js脱胎换骨。js如火如荼也很大程度上得益于当今项目开源的浪潮，前不久更是看到了一些开源的神经网络js库，相信不久的将来，在AI、VR等新技术领域js也定能分得一杯羹。\n\n其实作为IT人士，一直觉得我们不应该太过局限于工作，与技能结合起来，让能力更好地改变我们的生活，结合生活我们才能有所创造。铁饭碗不是来源于组织的强大稳健，而是产品与技术创新。\n","slug":"2017-09-10-get-data","published":1,"updated":"2018-05-26T16:15:42.547Z","comments":1,"photos":[],"link":"","_id":"cjjoevogu000t0gupj1r6ho5j","content":"<p>最近在公司办理了人才引入，递交了资料，然后就等待公示；公示的名单会在改网页中展示<a href=\"http://www.hrssgz.gov.cn/vsgzpiapp01/GZPI/Gateway/PersonIntroducePublicity.aspx，点进去查看一番\" target=\"_blank\" rel=\"external\">http://www.hrssgz.gov.cn/vsgzpiapp01/GZPI/Gateway/PersonIntroducePublicity.aspx，点进去查看一番</a><br>觉得坑爹的是每页只显示几条，而且还有60页之多，这简直是反人类。于是便想着把所有的数据搞下来！</p>\n<p><img src=\"/2017/09/10/2017-09-10-get-data/step1.png\" alt=\"\"></p>\n<p>第一步肯定是F12看看请求的格式了，又翻页看了一下请求，大致了解了流程：</p>\n<ul>\n<li>每次请求会拿到<strong>VIEWSTATEGENERATOR、</strong>VIEWSTATE等着些后端的code值</li>\n<li>__EVENTTARGET表明是第一页还是尾页、或者上一页下一页</li>\n<li>ToPage为当前的页码</li>\n<li>接口的地址都是这一个/vsgzpiapp01/GZPI/Gateway/PersonIntroducePublicity.aspx</li>\n<li>采用post的方式请求</li>\n</ul>\n<p>http请求体</p>\n<p><img src=\"/2017/09/10/2017-09-10-get-data/./step2.png\" alt=\"\"></p>\n<p>页面跳转处理</p>\n<p><img src=\"/2017/09/10/2017-09-10-get-data/./step3.png\" alt=\"\"></p>\n<p>跳转执行函数</p>\n<p><img src=\"/2017/09/10/2017-09-10-get-data/./step4.png\" alt=\"\"></p>\n<p>第二步模拟请求，获取返回的html，截取数据拿到第一页的表格，存储起来，并拿第二页的请求参数</p>\n<p>这里借助了两个npm的包request、cheerio</p>\n<ul>\n<li>request一个node发送http请求十分好用的包，可以任意拼装http头部所有字段，模拟现实的浏览器请求也不成问题</li>\n<li>cheerio可以让你再node中像在浏览器里一样使用jquery的包，可以方便地操作dom节点</li>\n</ul>\n<p>具体实现如下，会把结果写入到当前的一个data.html文件里：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&apos;fs&apos;),</span><br><span class=\"line\">    request = require(&apos;request&apos;),</span><br><span class=\"line\">    cheerio = require(&apos;cheerio&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 缓存的结果</span><br><span class=\"line\">var result = &apos;&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">function write(str)&#123;</span><br><span class=\"line\">    fs.writeFile(&apos;./data.html&apos;, str, function (err) &#123;</span><br><span class=\"line\">        if (err) throw err;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 为了好看一点，包装一下</span><br><span class=\"line\">function wrapHtml(str) &#123;</span><br><span class=\"line\">    var header = &apos;&lt;tr class=&quot;ListHeader&quot; align=&quot;center&quot;&gt; &lt;td&gt;姓名&lt;/td&gt;&lt;td&gt;单位名称&lt;/td&gt;&lt;td&gt;批复结果&lt;/td&gt;&lt;td&gt;审批单位&lt;/td&gt;&lt;td&gt;公示开始时间&lt;/td&gt;&lt;td&gt;公示结束时间&lt;/td&gt; &lt;/tr&gt;&apos;</span><br><span class=\"line\">    str = &apos;&lt;table&gt;&apos; + header + str +&apos;&lt;/table&gt;&apos;</span><br><span class=\"line\">    return &apos;&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;最新名单&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &apos;+str+&apos;&lt;/body &gt; &lt;/html&gt;&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function query(data)&#123;</span><br><span class=\"line\">    request.post(&#123;</span><br><span class=\"line\">        url: &apos;http://www.hrssgz.gov.cn/vsgzpiapp01/GZPI/Gateway/PersonIntroducePublicity.aspx&apos;,</span><br><span class=\"line\">        formData: data</span><br><span class=\"line\">    &#125;, function (error, response, body) &#123;</span><br><span class=\"line\">        var startIndex = body.indexOf(&apos;&lt;tr class=&quot;ListItem&quot;&gt;&apos;)</span><br><span class=\"line\">        var endIndex = body.indexOf(&apos;&lt;/table&gt;&apos;)</span><br><span class=\"line\">        result += body.slice(startIndex, endIndex)</span><br><span class=\"line\">        var formData = getFormData(body)</span><br><span class=\"line\">\t\t//如果formdata没值标示没有下一页了，也就可以结束了</span><br><span class=\"line\">        if(formData)&#123;</span><br><span class=\"line\">            query(formData)</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            write(wrapHtml(result))</span><br><span class=\"line\">            console.log(&apos;读取完成&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//在body中获取下一页的参数</span><br><span class=\"line\">function getFormData (body) &#123;</span><br><span class=\"line\">    const $ = cheerio.load(body)</span><br><span class=\"line\">    if($(&apos;#NextLBtn&apos;).attr(&apos;disabled&apos;) == &apos;disabled&apos;)&#123;</span><br><span class=\"line\">        return false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var total = $(&apos;#PageCount&apos;).text()</span><br><span class=\"line\">    var cur = $(&apos;#ToPage&apos;).val()</span><br><span class=\"line\">    console.log(&apos;继续读取第&apos;+Number(+cur + 1)+&apos;页，&apos; + &apos;共&apos;+total+&apos;页&apos;);</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        __EVENTTARGET: &apos;NextLBtn&apos;,</span><br><span class=\"line\">        __VIEWSTATE: $(&apos;#__VIEWSTATE&apos;).val(),</span><br><span class=\"line\">        __VIEWSTATEGENERATOR: $(&apos;#__VIEWSTATEGENERATOR&apos;).val(),</span><br><span class=\"line\">        ToPage: cur</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//开始拿第一页的数据</span><br><span class=\"line\">query()</span><br></pre></td></tr></table></figure>\n<p>下面是执行的结果</p>\n<p><img src=\"/2017/09/10/2017-09-10-get-data/./step5.png\" alt=\"\"></p>\n<p>总的来说流程还是比较简单的，拿到表格之后也可以随意搜索名字了。node确实是给前端带来了很大的改变，让前端可以从浏览器走出去，可以任意的操作计算机系统的资源，而目前更是广泛应用到静态服务器、SSR、资源打包优化、桌面应用等。<br>可以说Web2.0让js死而复生，node让js脱胎换骨。js如火如荼也很大程度上得益于当今项目开源的浪潮，前不久更是看到了一些开源的神经网络js库，相信不久的将来，在AI、VR等新技术领域js也定能分得一杯羹。</p>\n<p>其实作为IT人士，一直觉得我们不应该太过局限于工作，与技能结合起来，让能力更好地改变我们的生活，结合生活我们才能有所创造。铁饭碗不是来源于组织的强大稳健，而是产品与技术创新。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在公司办理了人才引入，递交了资料，然后就等待公示；公示的名单会在改网页中展示<a href=\"http://www.hrssgz.gov.cn/vsgzpiapp01/GZPI/Gateway/PersonIntroducePublicity.aspx，点进去查看一番\">http://www.hrssgz.gov.cn/vsgzpiapp01/GZPI/Gateway/PersonIntroducePublicity.aspx，点进去查看一番</a><br>觉得坑爹的是每页只显示几条，而且还有60页之多，这简直是反人类。于是便想着把所有的数据搞下来！</p>\n<p><img src=\"/2017/09/10/2017-09-10-get-data/step1.png\" alt=\"\"></p>\n<p>第一步肯定是F12看看请求的格式了，又翻页看了一下请求，大致了解了流程：</p>\n<ul>\n<li>每次请求会拿到<strong>VIEWSTATEGENERATOR、</strong>VIEWSTATE等着些后端的code值</li>\n<li>__EVENTTARGET表明是第一页还是尾页、或者上一页下一页</li>\n<li>ToPage为当前的页码</li>\n<li>接口的地址都是这一个/vsgzpiapp01/GZPI/Gateway/PersonIntroducePublicity.aspx</li>\n<li>采用post的方式请求</li>\n</ul>\n<p>http请求体</p>\n<p><img src=\"/2017/09/10/2017-09-10-get-data/./step2.png\" alt=\"\"></p>\n<p>页面跳转处理</p>\n<p><img src=\"/2017/09/10/2017-09-10-get-data/./step3.png\" alt=\"\"></p>\n<p>跳转执行函数</p>\n<p><img src=\"/2017/09/10/2017-09-10-get-data/./step4.png\" alt=\"\"></p>\n<p>第二步模拟请求，获取返回的html，截取数据拿到第一页的表格，存储起来，并拿第二页的请求参数</p>\n<p>这里借助了两个npm的包request、cheerio</p>\n<ul>\n<li>request一个node发送http请求十分好用的包，可以任意拼装http头部所有字段，模拟现实的浏览器请求也不成问题</li>\n<li>cheerio可以让你再node中像在浏览器里一样使用jquery的包，可以方便地操作dom节点</li>\n</ul>\n<p>具体实现如下，会把结果写入到当前的一个data.html文件里：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&apos;fs&apos;),</span><br><span class=\"line\">    request = require(&apos;request&apos;),</span><br><span class=\"line\">    cheerio = require(&apos;cheerio&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 缓存的结果</span><br><span class=\"line\">var result = &apos;&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">function write(str)&#123;</span><br><span class=\"line\">    fs.writeFile(&apos;./data.html&apos;, str, function (err) &#123;</span><br><span class=\"line\">        if (err) throw err;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 为了好看一点，包装一下</span><br><span class=\"line\">function wrapHtml(str) &#123;</span><br><span class=\"line\">    var header = &apos;&lt;tr class=&quot;ListHeader&quot; align=&quot;center&quot;&gt; &lt;td&gt;姓名&lt;/td&gt;&lt;td&gt;单位名称&lt;/td&gt;&lt;td&gt;批复结果&lt;/td&gt;&lt;td&gt;审批单位&lt;/td&gt;&lt;td&gt;公示开始时间&lt;/td&gt;&lt;td&gt;公示结束时间&lt;/td&gt; &lt;/tr&gt;&apos;</span><br><span class=\"line\">    str = &apos;&lt;table&gt;&apos; + header + str +&apos;&lt;/table&gt;&apos;</span><br><span class=\"line\">    return &apos;&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;最新名单&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &apos;+str+&apos;&lt;/body &gt; &lt;/html&gt;&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function query(data)&#123;</span><br><span class=\"line\">    request.post(&#123;</span><br><span class=\"line\">        url: &apos;http://www.hrssgz.gov.cn/vsgzpiapp01/GZPI/Gateway/PersonIntroducePublicity.aspx&apos;,</span><br><span class=\"line\">        formData: data</span><br><span class=\"line\">    &#125;, function (error, response, body) &#123;</span><br><span class=\"line\">        var startIndex = body.indexOf(&apos;&lt;tr class=&quot;ListItem&quot;&gt;&apos;)</span><br><span class=\"line\">        var endIndex = body.indexOf(&apos;&lt;/table&gt;&apos;)</span><br><span class=\"line\">        result += body.slice(startIndex, endIndex)</span><br><span class=\"line\">        var formData = getFormData(body)</span><br><span class=\"line\">\t\t//如果formdata没值标示没有下一页了，也就可以结束了</span><br><span class=\"line\">        if(formData)&#123;</span><br><span class=\"line\">            query(formData)</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            write(wrapHtml(result))</span><br><span class=\"line\">            console.log(&apos;读取完成&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//在body中获取下一页的参数</span><br><span class=\"line\">function getFormData (body) &#123;</span><br><span class=\"line\">    const $ = cheerio.load(body)</span><br><span class=\"line\">    if($(&apos;#NextLBtn&apos;).attr(&apos;disabled&apos;) == &apos;disabled&apos;)&#123;</span><br><span class=\"line\">        return false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var total = $(&apos;#PageCount&apos;).text()</span><br><span class=\"line\">    var cur = $(&apos;#ToPage&apos;).val()</span><br><span class=\"line\">    console.log(&apos;继续读取第&apos;+Number(+cur + 1)+&apos;页，&apos; + &apos;共&apos;+total+&apos;页&apos;);</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        __EVENTTARGET: &apos;NextLBtn&apos;,</span><br><span class=\"line\">        __VIEWSTATE: $(&apos;#__VIEWSTATE&apos;).val(),</span><br><span class=\"line\">        __VIEWSTATEGENERATOR: $(&apos;#__VIEWSTATEGENERATOR&apos;).val(),</span><br><span class=\"line\">        ToPage: cur</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//开始拿第一页的数据</span><br><span class=\"line\">query()</span><br></pre></td></tr></table></figure>\n<p>下面是执行的结果</p>\n<p><img src=\"/2017/09/10/2017-09-10-get-data/./step5.png\" alt=\"\"></p>\n<p>总的来说流程还是比较简单的，拿到表格之后也可以随意搜索名字了。node确实是给前端带来了很大的改变，让前端可以从浏览器走出去，可以任意的操作计算机系统的资源，而目前更是广泛应用到静态服务器、SSR、资源打包优化、桌面应用等。<br>可以说Web2.0让js死而复生，node让js脱胎换骨。js如火如荼也很大程度上得益于当今项目开源的浪潮，前不久更是看到了一些开源的神经网络js库，相信不久的将来，在AI、VR等新技术领域js也定能分得一杯羹。</p>\n<p>其实作为IT人士，一直觉得我们不应该太过局限于工作，与技能结合起来，让能力更好地改变我们的生活，结合生活我们才能有所创造。铁饭碗不是来源于组织的强大稳健，而是产品与技术创新。</p>\n"},{"layout":"post","title":"追忆厦门鼓浪屿","date":"2017-08-20T12:40:20.000Z","header_image":"https://dimg03.c-ctrip.com/images/fd/tg/g3/M06/24/42/CggYG1YDjVOAYL5HAAuB_J_Kaao324_R_1600_10000_Mtg_7.jpg","_content":"\n还记得上次去鼓浪屿的时候还是2015年的10月份，黄金周刚过，我和小艺用周末的时间飞了过去厦门。这是我们俩第一次一起坐飞机！为了早早抛弃杂心的琐事，周五晚上，我们便过去了机场，第二天一大早坐了旅店的小货车过去了值机台\n满怀着激动和紧张的心情。第一次自己登机，总算是顺利。\n\n![](./1.JPG)\n\n见到了即将带我们飞的飞机\n\n经过两个小时的旅程，我们终于抵达了厦门的。正如图中所言，美丽厦门，从这里开始。这座承载着几千年历史的海滨城市，等着我们领略它的美丽动人。\n\n![](./2.JPG)\n\n\n此次厦门之行，我们的计划只有鼓浪屿，所以下机之后，便前往了码头坐轮渡。在船上，可以看到整个厦门，天水相接，与现代的钢筋水泥浑然天成。虽是金秋时节，海风和浪花早已熄灭了这热情高涨的太阳，迎着风，甚是清爽自在。\n真不知当年郑成功是何番心情登上这座美丽的岛屿。\n\n![](./3.JPG)\n\n\n![](./7.JPG)\n\n鼓浪屿离着不远，不多时便抵达了岸边。可能是国庆刚过的原因，这里的人不算太多。整个岛面积不大，岛上不准车辆行走，所以行人基本都是徒步。除了游客便是居民了，民房密密麻麻地遍布着，各种风情小旅馆和特色小吃店，以及\n文艺情怀的小店。真是一个消磨时间的好地方。\n\n![](./14.JPG)\n\n![](./15.JPG)\n\n厦门除了小清新之外，还是有挺多美食的。\n\n![](./5.JPG)\n\n![](./6.JPG)\n\n![](./10.JPG)\n\n![](./11.JPG)\n\n![](./12.JPG)\n\n![](./13.JPG)\n\n在厦门肯定少不了去海边走走，平时深居内陆的我们，对海有一种莫名的喜欢。吹吹海风，听听海声。\n\n![](./16.JPG)\n\n![](./17.JPG)","source":"_posts/2017-08-20-xiamen.markdown","raw":"---\nlayout: post\ntitle:  \"追忆厦门鼓浪屿\"\ndate:   2017-08-20 20:40:20\ncategories: \"闲暇游记\"\nheader_image: 'https://dimg03.c-ctrip.com/images/fd/tg/g3/M06/24/42/CggYG1YDjVOAYL5HAAuB_J_Kaao324_R_1600_10000_Mtg_7.jpg'\n---\n\n还记得上次去鼓浪屿的时候还是2015年的10月份，黄金周刚过，我和小艺用周末的时间飞了过去厦门。这是我们俩第一次一起坐飞机！为了早早抛弃杂心的琐事，周五晚上，我们便过去了机场，第二天一大早坐了旅店的小货车过去了值机台\n满怀着激动和紧张的心情。第一次自己登机，总算是顺利。\n\n![](./1.JPG)\n\n见到了即将带我们飞的飞机\n\n经过两个小时的旅程，我们终于抵达了厦门的。正如图中所言，美丽厦门，从这里开始。这座承载着几千年历史的海滨城市，等着我们领略它的美丽动人。\n\n![](./2.JPG)\n\n\n此次厦门之行，我们的计划只有鼓浪屿，所以下机之后，便前往了码头坐轮渡。在船上，可以看到整个厦门，天水相接，与现代的钢筋水泥浑然天成。虽是金秋时节，海风和浪花早已熄灭了这热情高涨的太阳，迎着风，甚是清爽自在。\n真不知当年郑成功是何番心情登上这座美丽的岛屿。\n\n![](./3.JPG)\n\n\n![](./7.JPG)\n\n鼓浪屿离着不远，不多时便抵达了岸边。可能是国庆刚过的原因，这里的人不算太多。整个岛面积不大，岛上不准车辆行走，所以行人基本都是徒步。除了游客便是居民了，民房密密麻麻地遍布着，各种风情小旅馆和特色小吃店，以及\n文艺情怀的小店。真是一个消磨时间的好地方。\n\n![](./14.JPG)\n\n![](./15.JPG)\n\n厦门除了小清新之外，还是有挺多美食的。\n\n![](./5.JPG)\n\n![](./6.JPG)\n\n![](./10.JPG)\n\n![](./11.JPG)\n\n![](./12.JPG)\n\n![](./13.JPG)\n\n在厦门肯定少不了去海边走走，平时深居内陆的我们，对海有一种莫名的喜欢。吹吹海风，听听海声。\n\n![](./16.JPG)\n\n![](./17.JPG)","slug":"2017-08-20-xiamen","published":1,"updated":"2018-06-02T03:22:23.915Z","comments":1,"photos":[],"link":"","_id":"cjjoevoh3000w0gup2zogs89k","content":"<p>还记得上次去鼓浪屿的时候还是2015年的10月份，黄金周刚过，我和小艺用周末的时间飞了过去厦门。这是我们俩第一次一起坐飞机！为了早早抛弃杂心的琐事，周五晚上，我们便过去了机场，第二天一大早坐了旅店的小货车过去了值机台<br>满怀着激动和紧张的心情。第一次自己登机，总算是顺利。</p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./1.JPG\" alt=\"\"></p>\n<p>见到了即将带我们飞的飞机</p>\n<p>经过两个小时的旅程，我们终于抵达了厦门的。正如图中所言，美丽厦门，从这里开始。这座承载着几千年历史的海滨城市，等着我们领略它的美丽动人。</p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./2.JPG\" alt=\"\"></p>\n<p>此次厦门之行，我们的计划只有鼓浪屿，所以下机之后，便前往了码头坐轮渡。在船上，可以看到整个厦门，天水相接，与现代的钢筋水泥浑然天成。虽是金秋时节，海风和浪花早已熄灭了这热情高涨的太阳，迎着风，甚是清爽自在。<br>真不知当年郑成功是何番心情登上这座美丽的岛屿。</p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./3.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./7.JPG\" alt=\"\"></p>\n<p>鼓浪屿离着不远，不多时便抵达了岸边。可能是国庆刚过的原因，这里的人不算太多。整个岛面积不大，岛上不准车辆行走，所以行人基本都是徒步。除了游客便是居民了，民房密密麻麻地遍布着，各种风情小旅馆和特色小吃店，以及<br>文艺情怀的小店。真是一个消磨时间的好地方。</p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./14.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./15.JPG\" alt=\"\"></p>\n<p>厦门除了小清新之外，还是有挺多美食的。</p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./5.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./6.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./10.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./11.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./12.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./13.JPG\" alt=\"\"></p>\n<p>在厦门肯定少不了去海边走走，平时深居内陆的我们，对海有一种莫名的喜欢。吹吹海风，听听海声。</p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./16.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./17.JPG\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>还记得上次去鼓浪屿的时候还是2015年的10月份，黄金周刚过，我和小艺用周末的时间飞了过去厦门。这是我们俩第一次一起坐飞机！为了早早抛弃杂心的琐事，周五晚上，我们便过去了机场，第二天一大早坐了旅店的小货车过去了值机台<br>满怀着激动和紧张的心情。第一次自己登机，总算是顺利。</p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./1.JPG\" alt=\"\"></p>\n<p>见到了即将带我们飞的飞机</p>\n<p>经过两个小时的旅程，我们终于抵达了厦门的。正如图中所言，美丽厦门，从这里开始。这座承载着几千年历史的海滨城市，等着我们领略它的美丽动人。</p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./2.JPG\" alt=\"\"></p>\n<p>此次厦门之行，我们的计划只有鼓浪屿，所以下机之后，便前往了码头坐轮渡。在船上，可以看到整个厦门，天水相接，与现代的钢筋水泥浑然天成。虽是金秋时节，海风和浪花早已熄灭了这热情高涨的太阳，迎着风，甚是清爽自在。<br>真不知当年郑成功是何番心情登上这座美丽的岛屿。</p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./3.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./7.JPG\" alt=\"\"></p>\n<p>鼓浪屿离着不远，不多时便抵达了岸边。可能是国庆刚过的原因，这里的人不算太多。整个岛面积不大，岛上不准车辆行走，所以行人基本都是徒步。除了游客便是居民了，民房密密麻麻地遍布着，各种风情小旅馆和特色小吃店，以及<br>文艺情怀的小店。真是一个消磨时间的好地方。</p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./14.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./15.JPG\" alt=\"\"></p>\n<p>厦门除了小清新之外，还是有挺多美食的。</p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./5.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./6.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./10.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./11.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./12.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./13.JPG\" alt=\"\"></p>\n<p>在厦门肯定少不了去海边走走，平时深居内陆的我们，对海有一种莫名的喜欢。吹吹海风，听听海声。</p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./16.JPG\" alt=\"\"></p>\n<p><img src=\"/2017/08/20/2017-08-20-xiamen/./17.JPG\" alt=\"\"></p>\n"},{"title":"egg整合数据校验","date":"2018-02-13T16:05:45.000Z","header_image":"https://cn.bing.com/az/hprichbg/rb/happychildday_ZH-CN9412524114_1920x1080.jpg","description":"eggjs整合数据官方的校验插件","_content":"\negg官方的插件egg-validate依赖了[parameter](https://github.com/node-modules/parameter/blob/master/README.md)包，其只做了两个处理\n\n```\n// egg-validate/app.js\napp.validator = new Parameter();\n\n// egg-validate/app/extend/context.js\nvalidate(rules, data) {\n\tdata = data || this.request.body;\n\tconst errors = this.app.validator.validate(rules, data);\n\tif (errors) {\n\t  this.throw(422, 'Validation Failed', {\n\t    code: 'invalid_param',\n\t    errors,\n\t  });\n\t}\n}\n```\n\n\n可见其做了两件事：\n- 1、启动时创建了一个实例\n- 2、封装了一个调用方法，和错误的时候自定义了一个http状态，抛出\n\n-------------------\n\n```\n[\n\t{message: 'should not be empty', code: 'invalid', field: 'name'},\n\t{message: 'should be an integer', code: 'invalid', field: 'age'}\n]\n```\n\n这里有几个不好的地方：\n- 1、没有暴露自定义parameter校验返回的信息，只能用这些提示。不能满足业务需求\n- 2、封装的validate方法个人感觉不够友好，直接抛出错误\n- 3、parameter的实现比较简单，使用比较方便，但对于自定义要求比较高需求灵活性还不够，例如它在对string校验时，为空的提示语不能自定义，只有配置了format的才可以自定义提示\n\n前两点覆盖的方式重写，但重写了，跟直接引用parameter并没有太大区别。所以建议还是直接用parameter这个插件。用法比较简单，直接拓展context上下文。\n\n```\n// extend/context.js\nconst VALIDATOR = Symbol('Application#validator');\t// 定义一个全局唯一的属性\nvar Parameter = require('parameter');\n\nmodule.exports = {\n    get validator () {\n        const that = this\n        if (!this[VALIDATOR]) {\n            this[VALIDATOR] = new Parameter({\n                translate () {\t// 翻译成多语言\n                    const arg = [...arguments]\n                    return that.__(...arg)\t\t\n                }\n            })\n        }\n        return this[VALIDATOR]\n    },\n    validate(rules, data) {\n        data = data || this.request.body;\n        const errors = this.validator.validate(rules, data);\n        console.log(errors)\n        return errors\n    }\n};\n```\n\n### parameter的使用\n\n- 1、插件提示语是英文的，那需要支持多语言，所幸其暴露了translate的配置项，引入egg-i18n即可\n\n- 2、定义了一些简写：\n- `'int'` => `{type: 'int', required: true}`\n- `'integer'` => `{type: 'integer', required: true}`\n- `'number'` => `{type: 'number', required: true}`\n- `'date'` => `{type: 'date', required: true}`\n- `'dateTime'` => `{type: 'dateTime', required: true}`\n- `'id'` => `{type: 'id', required: true}`\n- `'boolean'` => `{type: 'boolean', required: true}`\n- `'bool'` => `{type: 'bool', required: true}`\n- `'string'` => `{type: 'string', required: true, allowEmpty: false}`\n- `'email'` => `{type: 'email', required: true, allowEmpty: false, format: EMAIL_RE}`\n- `'password'` => `{type: 'password', required: true, allowEmpty: false, format: PASSWORD_RE, min: 6}`\n- `'object'` => `{type: 'object', required: true}`\n- `'array'` => `{type: 'array', required: true}`\n- `[1, 2]` => `{type: 'enum', values: [1, 2]}`\n- `/\\d+/` => `{type: 'string', required: true, allowEmpty: false, format: /\\d+/}`\n\n- 3、一个简单的例子：\n\n```\nconst error = this.ctx.validate({\n    content: 'string',\n    difficulty: ['1', '2', '3', '4', '5'],\n    type: ['1', '2', '3', '4'],\n    options: {\n        type: 'array',\n        itemType: 'object',\n        required: false,\n        rule: {\n            text: {type: 'string', format: /^\\S{6,}$/, message: '选项的内容不能少于3个字'}\n        }\n    }\n})\n```\n\n需要注意一点，ctx.request.body或者ctx.request.query里拿到的只有字符串或者对象，没有数字类型，所以别用int或者integer","source":"_posts/2018-02-14-egg-validate.md","raw":"---\ntitle: egg整合数据校验\ndate: 2018-02-14 00:05:45\ncategories: \"实战应用\"\ntags: [\"eggjs\", \"node\"]\nheader_image: 'https://cn.bing.com/az/hprichbg/rb/happychildday_ZH-CN9412524114_1920x1080.jpg'\ndescription: \"eggjs整合数据官方的校验插件\"\n---\n\negg官方的插件egg-validate依赖了[parameter](https://github.com/node-modules/parameter/blob/master/README.md)包，其只做了两个处理\n\n```\n// egg-validate/app.js\napp.validator = new Parameter();\n\n// egg-validate/app/extend/context.js\nvalidate(rules, data) {\n\tdata = data || this.request.body;\n\tconst errors = this.app.validator.validate(rules, data);\n\tif (errors) {\n\t  this.throw(422, 'Validation Failed', {\n\t    code: 'invalid_param',\n\t    errors,\n\t  });\n\t}\n}\n```\n\n\n可见其做了两件事：\n- 1、启动时创建了一个实例\n- 2、封装了一个调用方法，和错误的时候自定义了一个http状态，抛出\n\n-------------------\n\n```\n[\n\t{message: 'should not be empty', code: 'invalid', field: 'name'},\n\t{message: 'should be an integer', code: 'invalid', field: 'age'}\n]\n```\n\n这里有几个不好的地方：\n- 1、没有暴露自定义parameter校验返回的信息，只能用这些提示。不能满足业务需求\n- 2、封装的validate方法个人感觉不够友好，直接抛出错误\n- 3、parameter的实现比较简单，使用比较方便，但对于自定义要求比较高需求灵活性还不够，例如它在对string校验时，为空的提示语不能自定义，只有配置了format的才可以自定义提示\n\n前两点覆盖的方式重写，但重写了，跟直接引用parameter并没有太大区别。所以建议还是直接用parameter这个插件。用法比较简单，直接拓展context上下文。\n\n```\n// extend/context.js\nconst VALIDATOR = Symbol('Application#validator');\t// 定义一个全局唯一的属性\nvar Parameter = require('parameter');\n\nmodule.exports = {\n    get validator () {\n        const that = this\n        if (!this[VALIDATOR]) {\n            this[VALIDATOR] = new Parameter({\n                translate () {\t// 翻译成多语言\n                    const arg = [...arguments]\n                    return that.__(...arg)\t\t\n                }\n            })\n        }\n        return this[VALIDATOR]\n    },\n    validate(rules, data) {\n        data = data || this.request.body;\n        const errors = this.validator.validate(rules, data);\n        console.log(errors)\n        return errors\n    }\n};\n```\n\n### parameter的使用\n\n- 1、插件提示语是英文的，那需要支持多语言，所幸其暴露了translate的配置项，引入egg-i18n即可\n\n- 2、定义了一些简写：\n- `'int'` => `{type: 'int', required: true}`\n- `'integer'` => `{type: 'integer', required: true}`\n- `'number'` => `{type: 'number', required: true}`\n- `'date'` => `{type: 'date', required: true}`\n- `'dateTime'` => `{type: 'dateTime', required: true}`\n- `'id'` => `{type: 'id', required: true}`\n- `'boolean'` => `{type: 'boolean', required: true}`\n- `'bool'` => `{type: 'bool', required: true}`\n- `'string'` => `{type: 'string', required: true, allowEmpty: false}`\n- `'email'` => `{type: 'email', required: true, allowEmpty: false, format: EMAIL_RE}`\n- `'password'` => `{type: 'password', required: true, allowEmpty: false, format: PASSWORD_RE, min: 6}`\n- `'object'` => `{type: 'object', required: true}`\n- `'array'` => `{type: 'array', required: true}`\n- `[1, 2]` => `{type: 'enum', values: [1, 2]}`\n- `/\\d+/` => `{type: 'string', required: true, allowEmpty: false, format: /\\d+/}`\n\n- 3、一个简单的例子：\n\n```\nconst error = this.ctx.validate({\n    content: 'string',\n    difficulty: ['1', '2', '3', '4', '5'],\n    type: ['1', '2', '3', '4'],\n    options: {\n        type: 'array',\n        itemType: 'object',\n        required: false,\n        rule: {\n            text: {type: 'string', format: /^\\S{6,}$/, message: '选项的内容不能少于3个字'}\n        }\n    }\n})\n```\n\n需要注意一点，ctx.request.body或者ctx.request.query里拿到的只有字符串或者对象，没有数字类型，所以别用int或者integer","slug":"2018-02-14-egg-validate","published":1,"updated":"2018-06-02T03:08:29.822Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjoevoh6000y0gupmiwvbt4f","content":"<p>egg官方的插件egg-validate依赖了<a href=\"https://github.com/node-modules/parameter/blob/master/README.md\" target=\"_blank\" rel=\"external\">parameter</a>包，其只做了两个处理</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span><a class=\"code-caption-copy\">Copy Code</a></p><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// egg-validate/app.js</span><br><span class=\"line\">app.validator = new Parameter();</span><br><span class=\"line\"></span><br><span class=\"line\">// egg-validate/app/extend/context.js</span><br><span class=\"line\">validate(rules, data) &#123;</span><br><span class=\"line\">\tdata = data || this.request.body;</span><br><span class=\"line\">\tconst errors = this.app.validator.validate(rules, data);</span><br><span class=\"line\">\tif (errors) &#123;</span><br><span class=\"line\">\t  this.throw(422, &apos;Validation Failed&apos;, &#123;</span><br><span class=\"line\">\t    code: &apos;invalid_param&apos;,</span><br><span class=\"line\">\t    errors,</span><br><span class=\"line\">\t  &#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p>\n<p>可见其做了两件事：</p>\n<ul>\n<li>1、启动时创建了一个实例</li>\n<li>2、封装了一个调用方法，和错误的时候自定义了一个http状态，抛出</li>\n</ul>\n<hr>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span><a class=\"code-caption-copy\">Copy Code</a></p><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">\t&#123;message: &apos;should not be empty&apos;, code: &apos;invalid&apos;, field: &apos;name&apos;&#125;,</span><br><span class=\"line\">\t&#123;message: &apos;should be an integer&apos;, code: &apos;invalid&apos;, field: &apos;age&apos;&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure><p></p>\n<p>这里有几个不好的地方：</p>\n<ul>\n<li>1、没有暴露自定义parameter校验返回的信息，只能用这些提示。不能满足业务需求</li>\n<li>2、封装的validate方法个人感觉不够友好，直接抛出错误</li>\n<li>3、parameter的实现比较简单，使用比较方便，但对于自定义要求比较高需求灵活性还不够，例如它在对string校验时，为空的提示语不能自定义，只有配置了format的才可以自定义提示</li>\n</ul>\n<p>前两点覆盖的方式重写，但重写了，跟直接引用parameter并没有太大区别。所以建议还是直接用parameter这个插件。用法比较简单，直接拓展context上下文。</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span><a class=\"code-caption-copy\">Copy Code</a></p><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// extend/context.js</span><br><span class=\"line\">const VALIDATOR = Symbol(&apos;Application#validator&apos;);\t// 定义一个全局唯一的属性</span><br><span class=\"line\">var Parameter = require(&apos;parameter&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    get validator () &#123;</span><br><span class=\"line\">        const that = this</span><br><span class=\"line\">        if (!this[VALIDATOR]) &#123;</span><br><span class=\"line\">            this[VALIDATOR] = new Parameter(&#123;</span><br><span class=\"line\">                translate () &#123;\t// 翻译成多语言</span><br><span class=\"line\">                    const arg = [...arguments]</span><br><span class=\"line\">                    return that.__(...arg)\t\t</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return this[VALIDATOR]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    validate(rules, data) &#123;</span><br><span class=\"line\">        data = data || this.request.body;</span><br><span class=\"line\">        const errors = this.validator.validate(rules, data);</span><br><span class=\"line\">        console.log(errors)</span><br><span class=\"line\">        return errors</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p></p>\n<h3 id=\"parameter的使用\"><a href=\"#parameter的使用\" class=\"headerlink\" title=\"parameter的使用\"></a>parameter的使用</h3><ul>\n<li><p>1、插件提示语是英文的，那需要支持多语言，所幸其暴露了translate的配置项，引入egg-i18n即可</p>\n</li>\n<li><p>2、定义了一些简写：</p>\n</li>\n<li><code>&#39;int&#39;</code> =&gt; <code>{type: &#39;int&#39;, required: true}</code></li>\n<li><code>&#39;integer&#39;</code> =&gt; <code>{type: &#39;integer&#39;, required: true}</code></li>\n<li><code>&#39;number&#39;</code> =&gt; <code>{type: &#39;number&#39;, required: true}</code></li>\n<li><code>&#39;date&#39;</code> =&gt; <code>{type: &#39;date&#39;, required: true}</code></li>\n<li><code>&#39;dateTime&#39;</code> =&gt; <code>{type: &#39;dateTime&#39;, required: true}</code></li>\n<li><code>&#39;id&#39;</code> =&gt; <code>{type: &#39;id&#39;, required: true}</code></li>\n<li><code>&#39;boolean&#39;</code> =&gt; <code>{type: &#39;boolean&#39;, required: true}</code></li>\n<li><code>&#39;bool&#39;</code> =&gt; <code>{type: &#39;bool&#39;, required: true}</code></li>\n<li><code>&#39;string&#39;</code> =&gt; <code>{type: &#39;string&#39;, required: true, allowEmpty: false}</code></li>\n<li><code>&#39;email&#39;</code> =&gt; <code>{type: &#39;email&#39;, required: true, allowEmpty: false, format: EMAIL_RE}</code></li>\n<li><code>&#39;password&#39;</code> =&gt; <code>{type: &#39;password&#39;, required: true, allowEmpty: false, format: PASSWORD_RE, min: 6}</code></li>\n<li><code>&#39;object&#39;</code> =&gt; <code>{type: &#39;object&#39;, required: true}</code></li>\n<li><code>&#39;array&#39;</code> =&gt; <code>{type: &#39;array&#39;, required: true}</code></li>\n<li><code>[1, 2]</code> =&gt; <code>{type: &#39;enum&#39;, values: [1, 2]}</code></li>\n<li><p><code>/\\d+/</code> =&gt; <code>{type: &#39;string&#39;, required: true, allowEmpty: false, format: /\\d+/}</code></p>\n</li>\n<li><p>3、一个简单的例子：</p>\n</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span><a class=\"code-caption-copy\">Copy Code</a></p><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const error = this.ctx.validate(&#123;</span><br><span class=\"line\">    content: &apos;string&apos;,</span><br><span class=\"line\">    difficulty: [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;],</span><br><span class=\"line\">    type: [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;],</span><br><span class=\"line\">    options: &#123;</span><br><span class=\"line\">        type: &apos;array&apos;,</span><br><span class=\"line\">        itemType: &apos;object&apos;,</span><br><span class=\"line\">        required: false,</span><br><span class=\"line\">        rule: &#123;</span><br><span class=\"line\">            text: &#123;type: &apos;string&apos;, format: /^\\S&#123;6,&#125;$/, message: &apos;选项的内容不能少于3个字&apos;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><p></p>\n<p>需要注意一点，ctx.request.body或者ctx.request.query里拿到的只有字符串或者对象，没有数字类型，所以别用int或者integer</p>\n","site":{"data":{}},"excerpt":"","more":"<p>egg官方的插件egg-validate依赖了<a href=\"https://github.com/node-modules/parameter/blob/master/README.md\">parameter</a>包，其只做了两个处理</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span><a class=\"code-caption-copy\">Copy Code</a></p><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// egg-validate/app.js</span><br><span class=\"line\">app.validator = new Parameter();</span><br><span class=\"line\"></span><br><span class=\"line\">// egg-validate/app/extend/context.js</span><br><span class=\"line\">validate(rules, data) &#123;</span><br><span class=\"line\">\tdata = data || this.request.body;</span><br><span class=\"line\">\tconst errors = this.app.validator.validate(rules, data);</span><br><span class=\"line\">\tif (errors) &#123;</span><br><span class=\"line\">\t  this.throw(422, &apos;Validation Failed&apos;, &#123;</span><br><span class=\"line\">\t    code: &apos;invalid_param&apos;,</span><br><span class=\"line\">\t    errors,</span><br><span class=\"line\">\t  &#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p>\n<p>可见其做了两件事：</p>\n<ul>\n<li>1、启动时创建了一个实例</li>\n<li>2、封装了一个调用方法，和错误的时候自定义了一个http状态，抛出</li>\n</ul>\n<hr>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span><a class=\"code-caption-copy\">Copy Code</a></p><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">\t&#123;message: &apos;should not be empty&apos;, code: &apos;invalid&apos;, field: &apos;name&apos;&#125;,</span><br><span class=\"line\">\t&#123;message: &apos;should be an integer&apos;, code: &apos;invalid&apos;, field: &apos;age&apos;&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure><p></p>\n<p>这里有几个不好的地方：</p>\n<ul>\n<li>1、没有暴露自定义parameter校验返回的信息，只能用这些提示。不能满足业务需求</li>\n<li>2、封装的validate方法个人感觉不够友好，直接抛出错误</li>\n<li>3、parameter的实现比较简单，使用比较方便，但对于自定义要求比较高需求灵活性还不够，例如它在对string校验时，为空的提示语不能自定义，只有配置了format的才可以自定义提示</li>\n</ul>\n<p>前两点覆盖的方式重写，但重写了，跟直接引用parameter并没有太大区别。所以建议还是直接用parameter这个插件。用法比较简单，直接拓展context上下文。</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span><a class=\"code-caption-copy\">Copy Code</a></p><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// extend/context.js</span><br><span class=\"line\">const VALIDATOR = Symbol(&apos;Application#validator&apos;);\t// 定义一个全局唯一的属性</span><br><span class=\"line\">var Parameter = require(&apos;parameter&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    get validator () &#123;</span><br><span class=\"line\">        const that = this</span><br><span class=\"line\">        if (!this[VALIDATOR]) &#123;</span><br><span class=\"line\">            this[VALIDATOR] = new Parameter(&#123;</span><br><span class=\"line\">                translate () &#123;\t// 翻译成多语言</span><br><span class=\"line\">                    const arg = [...arguments]</span><br><span class=\"line\">                    return that.__(...arg)\t\t</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return this[VALIDATOR]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    validate(rules, data) &#123;</span><br><span class=\"line\">        data = data || this.request.body;</span><br><span class=\"line\">        const errors = this.validator.validate(rules, data);</span><br><span class=\"line\">        console.log(errors)</span><br><span class=\"line\">        return errors</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p></p>\n<h3 id=\"parameter的使用\"><a href=\"#parameter的使用\" class=\"headerlink\" title=\"parameter的使用\"></a>parameter的使用</h3><ul>\n<li><p>1、插件提示语是英文的，那需要支持多语言，所幸其暴露了translate的配置项，引入egg-i18n即可</p>\n</li>\n<li><p>2、定义了一些简写：</p>\n</li>\n<li><code>&#39;int&#39;</code> =&gt; <code>{type: &#39;int&#39;, required: true}</code></li>\n<li><code>&#39;integer&#39;</code> =&gt; <code>{type: &#39;integer&#39;, required: true}</code></li>\n<li><code>&#39;number&#39;</code> =&gt; <code>{type: &#39;number&#39;, required: true}</code></li>\n<li><code>&#39;date&#39;</code> =&gt; <code>{type: &#39;date&#39;, required: true}</code></li>\n<li><code>&#39;dateTime&#39;</code> =&gt; <code>{type: &#39;dateTime&#39;, required: true}</code></li>\n<li><code>&#39;id&#39;</code> =&gt; <code>{type: &#39;id&#39;, required: true}</code></li>\n<li><code>&#39;boolean&#39;</code> =&gt; <code>{type: &#39;boolean&#39;, required: true}</code></li>\n<li><code>&#39;bool&#39;</code> =&gt; <code>{type: &#39;bool&#39;, required: true}</code></li>\n<li><code>&#39;string&#39;</code> =&gt; <code>{type: &#39;string&#39;, required: true, allowEmpty: false}</code></li>\n<li><code>&#39;email&#39;</code> =&gt; <code>{type: &#39;email&#39;, required: true, allowEmpty: false, format: EMAIL_RE}</code></li>\n<li><code>&#39;password&#39;</code> =&gt; <code>{type: &#39;password&#39;, required: true, allowEmpty: false, format: PASSWORD_RE, min: 6}</code></li>\n<li><code>&#39;object&#39;</code> =&gt; <code>{type: &#39;object&#39;, required: true}</code></li>\n<li><code>&#39;array&#39;</code> =&gt; <code>{type: &#39;array&#39;, required: true}</code></li>\n<li><code>[1, 2]</code> =&gt; <code>{type: &#39;enum&#39;, values: [1, 2]}</code></li>\n<li><p><code>/\\d+/</code> =&gt; <code>{type: &#39;string&#39;, required: true, allowEmpty: false, format: /\\d+/}</code></p>\n</li>\n<li><p>3、一个简单的例子：</p>\n</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span><a class=\"code-caption-copy\">Copy Code</a></p><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const error = this.ctx.validate(&#123;</span><br><span class=\"line\">    content: &apos;string&apos;,</span><br><span class=\"line\">    difficulty: [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;],</span><br><span class=\"line\">    type: [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;],</span><br><span class=\"line\">    options: &#123;</span><br><span class=\"line\">        type: &apos;array&apos;,</span><br><span class=\"line\">        itemType: &apos;object&apos;,</span><br><span class=\"line\">        required: false,</span><br><span class=\"line\">        rule: &#123;</span><br><span class=\"line\">            text: &#123;type: &apos;string&apos;, format: /^\\S&#123;6,&#125;$/, message: &apos;选项的内容不能少于3个字&apos;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><p></p>\n<p>需要注意一点，ctx.request.body或者ctx.request.query里拿到的只有字符串或者对象，没有数字类型，所以别用int或者integer</p>\n"},{"title":"二月冲绳之旅","date":"2018-03-02T06:30:39.000Z","_content":"\n这是我俩第一次的出国之旅，考虑到英语水平有限和治安环境因素，选了一个离我国最近的地方——冲绳。在这之前又考虑过泰国、新加坡，想到那些地方国人太多，就先hold住了。签证是找自己公司代办，给钱就行。当时距离春节还有几个星期，公司的人说要赶紧了，领事馆那边有可能在节前暂停办理的。所以赶紧去排了4.5寸的大头贴，交了资料，所幸不多久就办好了。公司代办还是挺方便地，啥都不用干，交资料就行。\n\n交通工具：广州出发去南沙做轮船过香港，香港直飞冲绳\n\n这里有两个地方可以知晓一下：\n\n1、南沙有两班去香港的船，一个是到中环城，一个是到香港机场；有签证可直接过去7天；到香港机场的需要是当天或者第二天早上10点之前的飞机，它的方便之处是直接在这边搞好行李托管和登记，直接去到机场的候机大厅。\n\n2、大陆直飞冲绳的飞机不多，上海才有，实惠的更是少之又少；而香港班次选择比较多，价格也便宜，我们选的是一架A330，总体感觉还好。\n\n### 2月19日广州出发香港\n\n妹子说想坐一下轮船，我们的机票是第二天11点的，不能直接坐去香港机场了，所以下午在南沙坐下的末班轮船过了香港，历时1.5个小时。坐船的时候感觉很平坦，不怎么摇晃，人也不多，感觉还是十分nice的。到了香港之后，在那边逛了一下，吃了个饭，然后做机场大巴过去了香港机场。港币是直接在这边的提款机取的。大约一个小时左右，从中环抵达了香港机场，在那边办理了行李托运，然后就找个地方休息了一下，漫漫长夜，别问我怎么度过~哈哈！\n\n第二天一早，我们便起来去吃了个简单的早餐。漫长的等待，终于等到登记时刻。在那边发现，香港人都挺喜欢一家人出去旅行的，而且小学生的英语还特别牛逼，简直秒杀我等。\n\n...未完待续","source":"_posts/2018-02-19-chongsheng.md","raw":"---\ntitle: 二月冲绳之旅\ndate: 2018-02-30 14:30:39\ncategories: \"闲暇游记\"\n---\n\n这是我俩第一次的出国之旅，考虑到英语水平有限和治安环境因素，选了一个离我国最近的地方——冲绳。在这之前又考虑过泰国、新加坡，想到那些地方国人太多，就先hold住了。签证是找自己公司代办，给钱就行。当时距离春节还有几个星期，公司的人说要赶紧了，领事馆那边有可能在节前暂停办理的。所以赶紧去排了4.5寸的大头贴，交了资料，所幸不多久就办好了。公司代办还是挺方便地，啥都不用干，交资料就行。\n\n交通工具：广州出发去南沙做轮船过香港，香港直飞冲绳\n\n这里有两个地方可以知晓一下：\n\n1、南沙有两班去香港的船，一个是到中环城，一个是到香港机场；有签证可直接过去7天；到香港机场的需要是当天或者第二天早上10点之前的飞机，它的方便之处是直接在这边搞好行李托管和登记，直接去到机场的候机大厅。\n\n2、大陆直飞冲绳的飞机不多，上海才有，实惠的更是少之又少；而香港班次选择比较多，价格也便宜，我们选的是一架A330，总体感觉还好。\n\n### 2月19日广州出发香港\n\n妹子说想坐一下轮船，我们的机票是第二天11点的，不能直接坐去香港机场了，所以下午在南沙坐下的末班轮船过了香港，历时1.5个小时。坐船的时候感觉很平坦，不怎么摇晃，人也不多，感觉还是十分nice的。到了香港之后，在那边逛了一下，吃了个饭，然后做机场大巴过去了香港机场。港币是直接在这边的提款机取的。大约一个小时左右，从中环抵达了香港机场，在那边办理了行李托运，然后就找个地方休息了一下，漫漫长夜，别问我怎么度过~哈哈！\n\n第二天一早，我们便起来去吃了个简单的早餐。漫长的等待，终于等到登记时刻。在那边发现，香港人都挺喜欢一家人出去旅行的，而且小学生的英语还特别牛逼，简直秒杀我等。\n\n...未完待续","slug":"2018-02-19-chongsheng","published":1,"updated":"2018-06-02T08:07:03.535Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjoevoha00100gupo79hv48g","content":"<p>这是我俩第一次的出国之旅，考虑到英语水平有限和治安环境因素，选了一个离我国最近的地方——冲绳。在这之前又考虑过泰国、新加坡，想到那些地方国人太多，就先hold住了。签证是找自己公司代办，给钱就行。当时距离春节还有几个星期，公司的人说要赶紧了，领事馆那边有可能在节前暂停办理的。所以赶紧去排了4.5寸的大头贴，交了资料，所幸不多久就办好了。公司代办还是挺方便地，啥都不用干，交资料就行。</p>\n<p>交通工具：广州出发去南沙做轮船过香港，香港直飞冲绳</p>\n<p>这里有两个地方可以知晓一下：</p>\n<p>1、南沙有两班去香港的船，一个是到中环城，一个是到香港机场；有签证可直接过去7天；到香港机场的需要是当天或者第二天早上10点之前的飞机，它的方便之处是直接在这边搞好行李托管和登记，直接去到机场的候机大厅。</p>\n<p>2、大陆直飞冲绳的飞机不多，上海才有，实惠的更是少之又少；而香港班次选择比较多，价格也便宜，我们选的是一架A330，总体感觉还好。</p>\n<h3 id=\"2月19日广州出发香港\"><a href=\"#2月19日广州出发香港\" class=\"headerlink\" title=\"2月19日广州出发香港\"></a>2月19日广州出发香港</h3><p>妹子说想坐一下轮船，我们的机票是第二天11点的，不能直接坐去香港机场了，所以下午在南沙坐下的末班轮船过了香港，历时1.5个小时。坐船的时候感觉很平坦，不怎么摇晃，人也不多，感觉还是十分nice的。到了香港之后，在那边逛了一下，吃了个饭，然后做机场大巴过去了香港机场。港币是直接在这边的提款机取的。大约一个小时左右，从中环抵达了香港机场，在那边办理了行李托运，然后就找个地方休息了一下，漫漫长夜，别问我怎么度过~哈哈！</p>\n<p>第二天一早，我们便起来去吃了个简单的早餐。漫长的等待，终于等到登记时刻。在那边发现，香港人都挺喜欢一家人出去旅行的，而且小学生的英语还特别牛逼，简直秒杀我等。</p>\n<p>…未完待续</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这是我俩第一次的出国之旅，考虑到英语水平有限和治安环境因素，选了一个离我国最近的地方——冲绳。在这之前又考虑过泰国、新加坡，想到那些地方国人太多，就先hold住了。签证是找自己公司代办，给钱就行。当时距离春节还有几个星期，公司的人说要赶紧了，领事馆那边有可能在节前暂停办理的。所以赶紧去排了4.5寸的大头贴，交了资料，所幸不多久就办好了。公司代办还是挺方便地，啥都不用干，交资料就行。</p>\n<p>交通工具：广州出发去南沙做轮船过香港，香港直飞冲绳</p>\n<p>这里有两个地方可以知晓一下：</p>\n<p>1、南沙有两班去香港的船，一个是到中环城，一个是到香港机场；有签证可直接过去7天；到香港机场的需要是当天或者第二天早上10点之前的飞机，它的方便之处是直接在这边搞好行李托管和登记，直接去到机场的候机大厅。</p>\n<p>2、大陆直飞冲绳的飞机不多，上海才有，实惠的更是少之又少；而香港班次选择比较多，价格也便宜，我们选的是一架A330，总体感觉还好。</p>\n<h3 id=\"2月19日广州出发香港\"><a href=\"#2月19日广州出发香港\" class=\"headerlink\" title=\"2月19日广州出发香港\"></a>2月19日广州出发香港</h3><p>妹子说想坐一下轮船，我们的机票是第二天11点的，不能直接坐去香港机场了，所以下午在南沙坐下的末班轮船过了香港，历时1.5个小时。坐船的时候感觉很平坦，不怎么摇晃，人也不多，感觉还是十分nice的。到了香港之后，在那边逛了一下，吃了个饭，然后做机场大巴过去了香港机场。港币是直接在这边的提款机取的。大约一个小时左右，从中环抵达了香港机场，在那边办理了行李托运，然后就找个地方休息了一下，漫漫长夜，别问我怎么度过~哈哈！</p>\n<p>第二天一早，我们便起来去吃了个简单的早餐。漫长的等待，终于等到登记时刻。在那边发现，香港人都挺喜欢一家人出去旅行的，而且小学生的英语还特别牛逼，简直秒杀我等。</p>\n<p>…未完待续</p>\n"}],"PostAsset":[{"_id":"source/_posts/2017-08-05-yangshuoyouji/19.JPG","slug":"19.JPG","post":"cjjoevogl000r0gupo0u2pckk","modified":0,"renderable":0},{"_id":"source/_posts/2017-09-10-get-data/step2.png","slug":"step2.png","post":"cjjoevogu000t0gupj1r6ho5j","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-05-yangshuoyouji/1.JPG","slug":"1.JPG","post":"cjjoevogl000r0gupo0u2pckk","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-05-yangshuoyouji/11.JPG","slug":"11.JPG","post":"cjjoevogl000r0gupo0u2pckk","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-05-yangshuoyouji/2.JPG","slug":"2.JPG","post":"cjjoevogl000r0gupo0u2pckk","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-05-yangshuoyouji/3.JPG","slug":"3.JPG","post":"cjjoevogl000r0gupo0u2pckk","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-05-yangshuoyouji/18.JPG","slug":"18.JPG","post":"cjjoevogl000r0gupo0u2pckk","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-05-yangshuoyouji/9.JPG","slug":"9.JPG","post":"cjjoevogl000r0gupo0u2pckk","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-20-xiamen/10.JPG","slug":"10.JPG","post":"cjjoevoh3000w0gup2zogs89k","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-20-xiamen/12.JPG","slug":"12.JPG","post":"cjjoevoh3000w0gup2zogs89k","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-20-xiamen/14.JPG","slug":"14.JPG","post":"cjjoevoh3000w0gup2zogs89k","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-20-xiamen/17.JPG","slug":"17.JPG","post":"cjjoevoh3000w0gup2zogs89k","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-20-xiamen/2.JPG","slug":"2.JPG","post":"cjjoevoh3000w0gup2zogs89k","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-05-yangshuoyouji/8.JPG","slug":"8.JPG","post":"cjjoevogl000r0gupo0u2pckk","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-20-xiamen/8.JPG","slug":"8.JPG","post":"cjjoevoh3000w0gup2zogs89k","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-20-xiamen/9.JPG","slug":"9.JPG","post":"cjjoevoh3000w0gup2zogs89k","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-20-xiamen/16.JPG","slug":"16.JPG","post":"cjjoevoh3000w0gup2zogs89k","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-20-xiamen/4.JPG","slug":"4.JPG","post":"cjjoevoh3000w0gup2zogs89k","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-05-yangshuoyouji/14.JPG","slug":"14.JPG","post":"cjjoevogl000r0gupo0u2pckk","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-05-yangshuoyouji/15.JPG","slug":"15.JPG","post":"cjjoevogl000r0gupo0u2pckk","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-05-yangshuoyouji/16.JPG","slug":"16.JPG","post":"cjjoevogl000r0gupo0u2pckk","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-05-yangshuoyouji/4.JPG","slug":"4.JPG","post":"cjjoevogl000r0gupo0u2pckk","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-05-yangshuoyouji/5.JPG","slug":"5.JPG","post":"cjjoevogl000r0gupo0u2pckk","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-20-xiamen/13.JPG","slug":"13.JPG","post":"cjjoevoh3000w0gup2zogs89k","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-20-xiamen/6.JPG","slug":"6.JPG","post":"cjjoevoh3000w0gup2zogs89k","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-20-xiamen/7.JPG","slug":"7.JPG","post":"cjjoevoh3000w0gup2zogs89k","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-20-xiamen/5.JPG","slug":"5.JPG","post":"cjjoevoh3000w0gup2zogs89k","modified":0,"renderable":0},{"_id":"source/_posts/2017-09-09-about-es6/about-es6.jpg","slug":"about-es6.jpg","post":"cjjoevogd000p0gupfmv5nvoc","modified":0,"renderable":0},{"_id":"source/_posts/2017-09-10-get-data/step1.png","slug":"step1.png","post":"cjjoevogu000t0gupj1r6ho5j","modified":0,"renderable":0},{"_id":"source/_posts/2017-09-10-get-data/step3.png","slug":"step3.png","post":"cjjoevogu000t0gupj1r6ho5j","modified":0,"renderable":0},{"_id":"source/_posts/2017-09-10-get-data/step4.png","slug":"step4.png","post":"cjjoevogu000t0gupj1r6ho5j","modified":0,"renderable":0},{"_id":"source/_posts/2017-09-10-get-data/step5.png","slug":"step5.png","post":"cjjoevogu000t0gupj1r6ho5j","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-20-xiamen/1.JPG","slug":"1.JPG","post":"cjjoevoh3000w0gup2zogs89k","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-20-xiamen/11.JPG","slug":"11.JPG","post":"cjjoevoh3000w0gup2zogs89k","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-20-xiamen/15.JPG","slug":"15.JPG","post":"cjjoevoh3000w0gup2zogs89k","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-20-xiamen/3.JPG","slug":"3.JPG","post":"cjjoevoh3000w0gup2zogs89k","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-05-yangshuoyouji/6.JPG","slug":"6.JPG","post":"cjjoevogl000r0gupo0u2pckk","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-05-yangshuoyouji/10.JPG","slug":"10.JPG","post":"cjjoevogl000r0gupo0u2pckk","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-05-yangshuoyouji/12.JPG","slug":"12.JPG","post":"cjjoevogl000r0gupo0u2pckk","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-05-yangshuoyouji/13.JPG","slug":"13.JPG","post":"cjjoevogl000r0gupo0u2pckk","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-05-yangshuoyouji/17.JPG","slug":"17.JPG","post":"cjjoevogl000r0gupo0u2pckk","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-05-yangshuoyouji/20.JPG","slug":"20.JPG","post":"cjjoevogl000r0gupo0u2pckk","modified":0,"renderable":0},{"_id":"source/_posts/2017-08-05-yangshuoyouji/7.JPG","slug":"7.JPG","post":"cjjoevogl000r0gupo0u2pckk","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjjoevoew00050gupo75ru6wh","category_id":"cjjoevoen00030gupnpliubud","_id":"cjjoevofc00090gupnvtix5bw"},{"post_id":"cjjoevoe800010gupy410wsqp","category_id":"cjjoevoen00030gupnpliubud","_id":"cjjoevofl000c0gup10zmyubp"},{"post_id":"cjjoevof700080gupq5nhp5pn","category_id":"cjjoevof100070gup2582yfkk","_id":"cjjoevofn000e0gupbavksx2b"},{"post_id":"cjjoevoei00020gupbz9jq4u9","category_id":"cjjoevof100070gup2582yfkk","_id":"cjjoevofr000h0gup52xqnjpt"},{"post_id":"cjjoevofm000d0gupfa8e27z6","category_id":"cjjoevof100070gup2582yfkk","_id":"cjjoevoft000j0gupwgbcc5qk"},{"post_id":"cjjoevoeq00040gup3aktzvvd","category_id":"cjjoevof100070gup2582yfkk","_id":"cjjoevog2000m0gupwglo7a7m"},{"post_id":"cjjoevofo000f0guplg2v78pi","category_id":"cjjoevof100070gup2582yfkk","_id":"cjjoevogc000o0gup10oh938b"},{"post_id":"cjjoevofr000i0gupls0xgpol","category_id":"cjjoevof100070gup2582yfkk","_id":"cjjoevogk000q0gup200g10s0"},{"post_id":"cjjoevof000060gupsrh6stee","category_id":"cjjoevof100070gup2582yfkk","_id":"cjjoevogs000s0gupjul80lx2"},{"post_id":"cjjoevofu000k0gupxlkwppip","category_id":"cjjoevof100070gup2582yfkk","_id":"cjjoevoh2000v0gupwp0ax18o"},{"post_id":"cjjoevog3000n0gup691l42dx","category_id":"cjjoevof100070gup2582yfkk","_id":"cjjoevoh5000x0gupnqitfeav"},{"post_id":"cjjoevofc000a0gupzozkzavy","category_id":"cjjoevofw000l0gup5l2ggzew","_id":"cjjoevoh9000z0gupt3jojrmi"},{"post_id":"cjjoevogd000p0gupfmv5nvoc","category_id":"cjjoevof100070gup2582yfkk","_id":"cjjoevohd00130gupce3ppj1x"},{"post_id":"cjjoevogl000r0gupo0u2pckk","category_id":"cjjoevoh1000u0guptmvt9ibd","_id":"cjjoevohe00140gupj89e1oep"},{"post_id":"cjjoevoha00100gupo79hv48g","category_id":"cjjoevoh1000u0guptmvt9ibd","_id":"cjjoevohi00160gupujxf0wcs"},{"post_id":"cjjoevogu000t0gupj1r6ho5j","category_id":"cjjoevohb00110gupxa8tngxv","_id":"cjjoevohk00180gupm50tasy4"},{"post_id":"cjjoevoh3000w0gup2zogs89k","category_id":"cjjoevoh1000u0guptmvt9ibd","_id":"cjjoevohn001b0gupdt4ge9vd"},{"post_id":"cjjoevoh6000y0gupmiwvbt4f","category_id":"cjjoevohb00110gupxa8tngxv","_id":"cjjoevoho001d0gupsd29wh0t"}],"PostTag":[{"post_id":"cjjoevoh6000y0gupmiwvbt4f","tag_id":"cjjoevohc00120gupsccvw0a8","_id":"cjjoevohm001a0gupr9z1noby"},{"post_id":"cjjoevoh6000y0gupmiwvbt4f","tag_id":"cjjoevohi00170gupw1bwpbdo","_id":"cjjoevohn001c0gup93uxtzrp"}],"Tag":[{"name":"eggjs","_id":"cjjoevohc00120gupsccvw0a8"},{"name":"node","_id":"cjjoevohi00170gupw1bwpbdo"}]}}